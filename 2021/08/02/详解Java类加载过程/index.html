<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>详解Java类加载过程 | Zephyr&#39;s Capsule</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="iOS, Python, Swift, Objective-C, JavaScript">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="详解Java类加载过程 | Zephyr&#39;s Capsule">
    <meta name="twitter:description" content="iOS, Python, Swift, Objective-C, JavaScript">

    <meta property="og:type" content="article">
    <meta property="og:title" content="详解Java类加载过程 | Zephyr&#39;s Capsule">
    <meta property="og:description" content="iOS, Python, Swift, Objective-C, JavaScript">

    
    <meta name="author" content="Zephyr">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Zephyr&#39;s Capsule" href="/atom.xml">
    

    <link rel="canonical" href="http://anye3210.github.io/2021/08/02/详解Java类加载过程/"/>

    
    <link rel="author" href="https://plus.google.com"/>
    
      
</head>

<body class="home-template no-js">
    <script src="https://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Zephyr&#39;s Capsule 的主页"><img src="/images/avatar.jpg" width="80" alt="Zephyr&#39;s Capsule logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Zephyr&#39;s Capsule">Zephyr&#39;s Capsule</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">Stay hungry stay foolish</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">不断前行</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/favourite">收藏</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/zephyrw" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        
        <li class="navigation__item">
            <a href="http://stackoverflow.com/" title="Stack Overflow" target="_blank">
                <i class='social fa fa-stack-overflow'></i>
                <span class="label">Stack Overflow</span>
            </a>
        </li>
        

  <!-- Google Plus -->
  
  <li class="navigation__item">
    <a href="https://plus.google.com" title="Google+" target="_blank">
      <i class='social fa fa-google-plus-square'></i>
      <span class="label">Google+</span>
    </a>
  </li>


<!-- Facebook -->

  <li class="navigation__item">
    <a href="https://www.facebook.com/" title="上Facebook找我" target="_blank">
      <i class='social fa fa-facebook'></i>
      <span class="label">Facebook</span>
    </a>
  </li>

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2021-08-02T14:53:13.000Z" class="post-list__meta--date date">2021-08-02</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/Java/">Java</a>, <a class="tag-link" href="/tags/初始化/">初始化</a>, <a class="tag-link" href="/tags/符号引用/">符号引用</a>, <a class="tag-link" href="/tags/类加载/">类加载</a>
 </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">详解Java类加载过程</h1>
  </header>

  <section class="post">
    <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类从被加载到虚拟机开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。整个过程如下图所示：</p>
<img src="https://i.loli.net/2021/08/02/265OIqCLtMSwJkY.png" alt="类加载的生命周期.png" style="zoom:50%;">

<p>加载、验证、准备、初始化和卸载这五个阶段顺序是确定的，类的加载过程这些阶段必须按这个顺序开始（注意这里强调的开始的顺序，进行和完成可能是交叉混合着的）。由于 Java 支持动态绑定，在动态绑定时解析阶段会在初始化之后执行。</p>
<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>上面讲到类的分为七个阶段，那么什么情况下会开始类的加载呢？</p>
<p>思考这个问题我们可以从两个维度出发，一个是 JVM 规范维度，一个是从虚拟机运行的维度；</p>
<a id="more"></a>

<h3 id="JVM-规范维度"><a href="#JVM-规范维度" class="headerlink" title="JVM 规范维度"></a>JVM 规范维度</h3><p> JVM 规范没有强制约束类的加载时机，但 Java 虚拟机严格规定了有且只有5种情况必须立即对类进行”初始化”，执行初始化自然必须先执行前面的步骤。</p>
<ul>
<li>遇到 new、getstatic、putstatic、或 invokestatic 这4条字节码指令时，如果类没有初始化，则需要先触发其初始化。其对应的场景分别为：<strong>使用 new 关键字初始化实例对象</strong>的时候、<strong>读取或设置一个类的静态字段</strong>（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候和<strong>调用一个类的静态方法</strong>的时候；</li>
<li>使用 java.lang.reflect 包的方法对类进行<strong>反射调用</strong>的时候，如果类没有进行初始化，则需要先触发其初始化；</li>
<li>当初始化一个类的时候，如果发现其<strong>父类没有初始化</strong>，则需要先触发其父类的初始化；</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法那个类），虚拟机会先<strong>初始化这个主类</strong>；</li>
<li>当使用 JDK1.7 开始的<strong>动态语言支持</strong>时，如果 􏱏􏰑􏰣􏲝java.lang.invoke.MethodHandle􏲟􏲡􏰿􏱆 实例最后的解析结果为 􏰏􏰲􏱨􏰐􏰑REF_getStatic、􏱦REF_putStatic、􏱦REF_invokeStatic 的方法句柄􏰏􏲶􏵁􏸁􏸂􏰛􏱢􏴪􏱑􏲝􏲶􏵁􏸁􏸂 􏳨􏱣􏲏􏰏􏰇􏴣􏳝􏱔􏱊􏱾􏱩􏱪􏱚􏰛􏴋􏱂􏱃􏳔􏴰􏰡，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<h3 id="虚拟机运行维度"><a href="#虚拟机运行维度" class="headerlink" title="虚拟机运行维度"></a>虚拟机运行维度</h3><p>从虚拟机运行的维度来说，有两种时机会触发类加载：</p>
<ul>
<li>预加载</li>
<li>运行时加载</li>
</ul>
<h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p>虚拟机启动时加载，加载的是<code>JAVA_HOME/lib/</code>下的<code>rt.jar</code>下的<code>.class</code>文件，这个jar包里面的内容是程序运行时非常常 常用到的，像<code>java.lang.*</code>、<code>java.util. java.io.</code>等等，因此随着虚拟机一起加载。</p>
<p>要证明这一点很简单，写一个空的<code>main</code>函数，设置虚拟机参数为<code>-XX:+TraceClassLoading</code>来获取类加载信息，运行一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Opened /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Object from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.io.Serializable from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Comparable from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.CharSequence from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="运行时加载"><a href="#运行时加载" class="headerlink" title="运行时加载"></a>运行时加载</h4><p>虚拟机在用到一个.class文件的时候，会先去内存中查看一下这个.class文件有没有被加载，如果没有就会按照类的全限定名来加载这个类。</p>
<h2 id="详解类加载过程"><a href="#详解类加载过程" class="headerlink" title="详解类加载过程"></a>详解类加载过程</h2><h3 id="加载（重要）"><a href="#加载（重要）" class="headerlink" title="加载（重要）"></a>加载（重要）</h3><p>加载阶段主要做了三件事：</p>
<ul>
<li>获取 .class 文件的二进制流；</li>
<li>将类信息、静态变量、字节码、常量这些 .class 文件中的内容放入方法区中；</li>
<li>在内存中生成一个代表这个.class文件的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机比较特殊，这个Class对象是放在方法区中的。</li>
</ul>
<p>虚拟机规范对这三点的要求并不具体，因此虚拟机实现与具体应用的灵活度都是相当大的。</p>
<p>这种灵活度对于开发者来说主要体现在第一步，由于虚拟机规范并没有规定二进制字节流的来源，开发者可以从以下几个渠道获取：</p>
<ul>
<li>从zip包中获取，这就是以后jar、ear、war格式的基础 </li>
<li>从网络中获取，典型应用就是Applet </li>
<li>运行时计算生成，典型应用就是动态代理技术 </li>
<li>由其他文件生成，典型应用就是JSP，即由JSP生成对应的.class文件 </li>
<li>从数据库中读取，这种场景比较少见</li>
</ul>
<h3 id="链接（理解）"><a href="#链接（理解）" class="headerlink" title="链接（理解）"></a>链接（理解）</h3><p>链接分为三个步骤：验证、准备和解析</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证阶段主要是为了确保 .class 文件的字节流中包含的信息符合当前虚拟机要求，并且不会危害虚拟机自身的安全。</p>
<p>正如前面所说，二进制字节流可能有很多种来源，虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节 流而导致系统崩溃，所以<strong>验证是虚拟机对自身保护的一项重要工作</strong>。</p>
<p>验证阶段大致会完成以下四个阶段的检验动作：</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证  </li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<p>验证阶段与加载阶段是交叉进行的，加载阶段还没有结束验证阶段就已经开始了。</p>
<p>这个阶段也是最耗费时间的，如果我们所运行的全部代码（包括自己编写的及第三方依赖包中的代码）都已经被反复使用和验证过，那么可以考虑使用 <code>􏱏􏰑􏳨􏱉􏱊􏰏􏶶􏲹􏰋􏰌􏳹􏳟􏳠􏲰􏷠􏰍􏲢􏰏􏵀􏰁􏸗􏲶􏳟􏰹􏰏􏰋 􏰌􏳺􏱁􏲿􏷼􏱯􏵂􏳆􏱌􏱍􏱋􏱥􏳻􏱾􏰛􏱵􏱙􏰸􏲟􏹵􏳾􏳿􏱳􏱭􏱮􏶖􏶗􏱌􏱍-Xverify􏳙none􏵑􏱠􏴦􏴲 􏹯􏰪􏲹􏲺􏰏􏰇􏱥􏳻􏹶􏹵􏰛􏱮􏹷􏶅􏰄􏰅􏰆􏰇􏰈􏰉􏰏􏱶</code>参数来关闭大部分类验证措施，以缩短虚拟机类加载时间。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置其<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中分配 。</p>
<p>这里的<strong>类变量</strong>是指不被 final 修饰的 static 变量，这里设置的<strong>初始值</strong>指的是赋零值。</p>
<p>各个数据类型对应的零值如下：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">零值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">(short)0</td>
</tr>
<tr>
<td align="center">chart</td>
<td align="center">‘\u0000’</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">(byte)0</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0d</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">null</td>
</tr>
</tbody></table>
<p>这里需要注意一下，类变量由于在这个阶段会有一个初始值，所有代码里可以不指定初始值直接使用，但其他变量不行，使用前必须有初值，否则会编译出错。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>这里就需要了解符号引用和直接引用的概念：</p>
<h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><p>符号引用是<strong>以一组符号来描述所引用的目标</strong>，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。</p>
<p>下面以简单的代码来理解符号引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zephyr.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String serial;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>javap -verbose SymbolClass</code>反编译一下这个类，我们主要看看常量池部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#26         // com/zephyr/demo/SymbolClass.count:I</span><br><span class="line">   #3 = Class              #27            // com/zephyr/demo/SymbolClass</span><br><span class="line">   #4 = Class              #28            // java/lang/Object</span><br><span class="line">   #5 = Utf8               serial</span><br><span class="line">   #6 = Utf8               Ljava/lang/String;</span><br><span class="line">   #7 = Utf8               count</span><br><span class="line">   #8 = Utf8               I</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lcom/zephyr/demo/SymbolClass;</span><br><span class="line">  #16 = Utf8               calculate</span><br><span class="line">  #17 = Utf8               getCount</span><br><span class="line">  #18 = Utf8               ()I</span><br><span class="line">  #19 = Utf8               main</span><br><span class="line">  #20 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               args</span><br><span class="line">  #22 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               SymbolClass.java</span><br><span class="line">  #25 = NameAndType        #9:#10         // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 = NameAndType        #7:#8          // count:I</span><br><span class="line">  #27 = Utf8               com/zephyr/demo/SymbolClass</span><br><span class="line">  #28 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>

<p>上面带<code>Utf8</code>的那一行就是符号引用，每行最前面的就是符号，后面就是引用的值。对于变量来说都会有两行成对出现，比如#7 是 count，#8就是 count 的类型 Integer(常量池里简写为 I )。方法如果有返回值，方法和返回值也会成对出现，比如 #17 和 #18，分别代表的方法和返回值类型。</p>
<p>简单理解符号引用就是对于类、变量、方法的描述。􏵱􏵲􏷞􏱍􏱮􏰣􏲻􏵱􏵲􏴦􏰺􏰭􏳨􏷞􏱍􏰏􏲽􏷯􏰛􏵱􏵲􏱭 并且􏱮􏰜􏸛􏱐􏱫􏰠􏰏􏰙􏱽􏴽􏰛􏴫􏱃􏱌􏱍􏱶􏱈􏳰􏺂􏲯􏰔􏲨􏵰􏱄􏲽􏷯􏴬􏱭符号引用和虚拟机的内存布局是没有关系的，引用的目标未必已经加载到内存中了。</p>
<h5 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h5><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p>
<p>直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。</p>
<h5 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h5><p>Java 本身是一个静态语言，但后面又加入了动态加载特性，因此我们理解解析阶段需要从这两方面来考虑。</p>
<p>如果不涉及动态加载，那么一个符号的解析结果是可以缓存的，这样可以避免多次解析同一个符号，因为第一次解析成功后面多次解析也必然成功，第一次解析异常后面重新解析也会是同样的结果。</p>
<p>如果使用了动态加载，前面使用动态加载解析过的符号后面重新解析结果可能会不同。使用动态加载时解析过程发生在在程序执行到这条指令的时候，这就是为什么前面讲的动态加载时解析会在初始化后执行。</p>
<p>整个解析阶段主要做了下面几个工作：</p>
<ul>
<li>类或接口的解析</li>
<li>类方法解析</li>
<li>接口方法解析</li>
<li>字段解析</li>
</ul>
<h3 id="初始化（重要）"><a href="#初始化（重要）" class="headerlink" title="初始化（重要）"></a>初始化（重要）</h3><p>初始化是整个类加载过程的最后一个阶段。整个类加载的五个阶段只有加载和初始化是开发者可以参与的，因此初始化阶段也是需要重点关注的阶段。</p>
<p>初始化阶段简单来说就是执行类的构造器方法（<code>&lt;clinit&gt;()</code> ），要注意的是这里的构造器方法<code>&lt;clinit&gt;()</code>并不是开发者写的，而是<strong>编译器自动生成的</strong>。</p>
<h4 id="代码顺序的影响"><a href="#代码顺序的影响" class="headerlink" title="代码顺序的影响"></a>代码顺序的影响</h4><p>编译器编译的时候会按代码顺序进行收集，声明在静态代码块（static {} 块）之后的静态变量，只能在静态代码块里赋值，不能访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClinit</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">		i = <span class="number">0</span>; <span class="comment">// 可以给变量赋值</span></span><br><span class="line">		System.out.print(i); <span class="comment">// 在这里访问编译器会提示“非法向前引用” </span></span><br><span class="line">   &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="父类与子类-lt-clinit-gt-方法执行顺序"><a href="#父类与子类-lt-clinit-gt-方法执行顺序" class="headerlink" title="父类与子类&lt;clinit&gt;()方法执行顺序"></a>父类与子类<code>&lt;clinit&gt;()</code>方法执行顺序</h4><p>Java 虚拟机会保证父类的<code>&lt;clinit&gt;()</code>方法执行完成后才执行子类的<code>&lt;clinit&gt;()</code>方法，这也就意味着<strong>父类的静态代码块一定会先于子类执行</strong>的。</p>
<p>这里需要注意的是，如果父类的静态代码块有耗时操作，子类可能会被阻塞迟迟加载不了。</p>
<h4 id="编译器生成-lt-clinit-gt-方法的条件"><a href="#编译器生成-lt-clinit-gt-方法的条件" class="headerlink" title="编译器生成&lt;clinit&gt;()方法的条件"></a>编译器生成<code>&lt;clinit&gt;()</code>方法的条件</h4><p>编译器生成<code>&lt;clinit&gt;()</code>方法的前提是有变量赋值操作或者有静态代码块需要执行。接口虽然没有静态代码块但是有变量赋值操作，所以接口会生成<code>&lt;clinit&gt;()</code>方法。</p>
<p><strong>注意：</strong>接口或者接口的实现类在执行<code>&lt;clinit&gt;()</code>方法之前不一定会去执行父类的<code>&lt;clinit&gt;()</code>方法，仅当父类或者被实现的接口变量被使用才会调用这个方法。</p>

  </section>

</article>
<section class="read-more">
           
    
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2021/07/31/JMM-Java-内存模型/" title="JMM - Java 内存模型">JMM - Java 内存模型</a></h2>
                <p class="excerpt">
                
                JMM定义JMM 即 Java Memory Model，也叫 Java 内存模型。JMM 就是一种规范，它定义了什么情况开发者不需要去感知计算机的各种重排序，什么情况需要开发者去干涉重排序，以保证程序的执行结果可预测。
JMM的由来计算机这么多年来整体运行速度不断地提升，除了像CPU时钟频率、内存读写速度等硬件性能不断提升之外，还要归功于计算机科学家对于计算机对于各种指令处理效率的不断优化，包括超标量流水线技术，动态指令调度，猜测执行，多级缓存技术等。在这其中，允许重排序对于计算机运行效率的提升产生了重要的作用，但同时也带来了一些问题。计算机只能确保单线程情况下重排序对于运行结果没有影响，对于多线程就无能为力了。这个时候就需要一个规范来保证开发者既能享受重排序带来的性能的提升又能让复杂情况下的运行结果可控，JMM 就是这样一个规范。JMM 规定了 JVM 必须遵循的一组最小保证，这组保证规定了对变量的操作何时对其他线程可见。换句话说，JMM 对内存可见性作出了一些承诺，在承诺之外，开发者需要自己去处理内存可见性问题。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2021-07-31T14:57:14.000Z" class="post-list__meta--date date">2021-07-31</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/Java/">Java</a>, <a class="tag-link" href="/tags/happen-before/">happen-before</a>, <a class="tag-link" href="/tags/内存可见性/">内存可见性</a>, <a class="tag-link" href="/tags/内存模型/">内存模型</a>, <a class="tag-link" href="/tags/重排序/">重排序</a>
</span><a class="btn-border-small" href="/2021/07/31/JMM-Java-内存模型/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

            
<section class="post-comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="http://anye3210.github.io/2021/08/02/详解Java类加载过程/" data-title="详解Java类加载过程" data-url="http://anye3210.github.io/2021/08/02/详解Java类加载过程/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"Zephyr&#39;s Capsule"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->
</section>


            <footer class="footer">
	<span class="footer__copyright">
	        <div style="width:200px;margin:0 auto; padding:0px;">
               <p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">©2019 Zephyr</p>
            </div>
    </span>
    <span class="footer__copyright">
        <div style="width:300px;margin:0 auto; padding:20px 0;">
                <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=50010802002929" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="/images/beian.png" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">渝公网安备 50010802002929号</p></a>
            </div>
    </span>
</footer>
        </div>
    </div>

    

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-87098157-1', 'auto');
	ga('send', 'pageview');
</script>

    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    
    </script>
    
</body>
</html>
