<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zephyr&#39;s Capsule</title>
  
  <subtitle>Stay hungry stay foolish</subtitle>
  <link href="http://anye3210.github.io/atom.xml" rel="self"/>
  
  <link href="http://anye3210.github.io/"/>
  <updated>2021-08-22T09:28:18.535Z</updated>
  <id>http://anye3210.github.io/</id>
  
  <author>
    <name>Zephyr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>详解 Netty</title>
    <link href="http://anye3210.github.io/2021/08/22/%E8%AF%A6%E8%A7%A3-Netty/"/>
    <id>http://anye3210.github.io/2021/08/22/%E8%AF%A6%E8%A7%A3-Netty/</id>
    <published>2021-08-22T09:26:09.000Z</published>
    <updated>2021-08-22T09:28:18.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解-Netty"><a href="#详解-Netty" class="headerlink" title="详解 Netty"></a>详解 Netty</h1><h2 id="什么是-Netty"><a href="#什么是-Netty" class="headerlink" title="什么是 Netty"></a>什么是 Netty</h2><p>简单来说 Netty 就是 JBOSS 开源的一个基于 NIO 的网络编程框架。它可以帮助我们快速开发高性能高可靠性的网络 IO 程序。</p><p>Netty 在 Java 语言中使用非常广泛，涉及到网络通信的基本上都使用 Netty，很少会直接去使用原生的 NIO 组件或者是其他框架。并且像Dubbo、RocketMQ、Zookeeper、ElasticSearch 这些知名的中间件所使用的网络通讯框架都是基于 Netty 去实现的。</p><p>Netty 是在原生 NIO 的基础上发展起来的框架，其中的许多理念都非常像，所以学习 Netty 前需要了解一下原生 NIO 编程。</p><h2 id="原生-NIO-编程"><a href="#原生-NIO-编程" class="headerlink" title="原生 NIO 编程"></a>原生 NIO 编程</h2><p>在了解原生 NIO 编程之前需要了解一个基础概念 Socket。</p><span id="more"></span><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Netty  是基于 TCP 协议的，我们知道 TCP 协议三个重要的特点分别是面向连接、可靠的和字节流。要达成这三点建立连接时需要客户端与服务端达成三个信息的共享，分别是：</p><ul><li><strong>Socket：</strong>包含五个信息：连接使用的协议、本地主机 IP 地址和端口号、远程主机的 IP 地址和端口号</li><li><strong>序列号：</strong>解决乱序问题</li><li><strong>容器大小：</strong>用来做流量控制</li></ul><p>Socket 就是两台主机之间的逻辑连接的端点，TCP 所说的面向连接，指的就是面向客户端和服务端两个 Socket 之间的连接。</p><p>这里要注意的是，服务端会涉及到两种 socket，一种叫做监听 socket ，一种叫做已完成连接 socket 。当监听 Socket 发现连接成功了之后会返回一个已完成连接 socket 文件描述符，用于后续传输数据。</p><h3 id="原生-NIO-组件"><a href="#原生-NIO-组件" class="headerlink" title="原生 NIO 组件"></a>原生 NIO 组件</h3><p>Netty 底层其实用了很多 Java 原生的 NIO 的组件，Netty 自定义的组件中有些理念也来自于原生的 NIO 组件。因此学习 Netty 之前需要了解一下原生的 NIO 组件的一些知识。</p><p>这里主要讲三个非常重要的组件：Channel (通道)、Buffer (缓冲区)、Selector (选择器)。</p><p> 下图展示了这三个组件在 NIO 模型中发挥的作用：</p><img src="https://i.loli.net/2021/08/22/9sGjUgyXezJ5av4.png" style="zoom:50%"><h4 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer (缓冲区)"></a>Buffer (缓冲区)</h4><p>Buffer 本质上就是一块可以读写数据的内存块，我们在使用的时候可以把它理解成一个数组。</p><p>下图是 Buffer 各个类的继承关系：</p><img src="https://i.loli.net/2021/08/22/3NTLKafyeZRFAxq.png" style="zoom:50%"><p>这里着重讲一下 ByteBuffer ，ByteBuffer 在原生 NIO 编程时使用频率是最高的。下面主要讲一下它的使用。</p><blockquote><p>注意 ByteBuffer 初始化时其实是 创建并返回了一个它的子类 HeapByteBuffer 对象，我们操作的也是它的子类。</p></blockquote><p>首先是初始化，初始化主要通过两种方式：</p><ul><li>**allocate(int capacity)**：创建 byte 类型的指定长度的缓冲区；</li><li><strong>wrap(byte[] array)：</strong>创建 byte 类型的有内容的缓冲区。</li></ul><p>在学习数据操作之前，有几个 ByteBuffer 非常重要的参数和方法需要了解一下：</p><ul><li><strong>position</strong>：当前读取或写入的起始坐标；</li><li><strong>limite：</strong>最多可以操作到哪个索引；</li><li><strong>capacity：</strong>缓冲区的总长度；</li><li><strong>remaining()：</strong>这个方法返回的是 limit - position 的计算值，代表还有多少空间可以操作。</li></ul><p>数据操作主要是两个方法：</p><ul><li><strong>put()：</strong>插入字节，它是一个重载方法，可以传入不同形式的字节；</li><li><strong>get()：</strong>读取字节，不传参获取  position 位置的字节并让 position + 1，也可以通过参数读取指定位置的字节。</li></ul><p>下图是添加字节时各属性值的变化：</p><img src="https://i.loli.net/2021/08/22/Wmd3OUF8Pu2wIxv.png" style="zoom:50%"><p>ByteBuffer 虽然即支持读也支持写，但同一时间只能是其中一种模式，模式切换需要调用相应的方法。</p><p>下图是调用 flip() 方法将写模式切换为读时各属性的变化：</p><img src="https://i.loli.net/2021/08/22/puSvFJXtLQHOw6T.png" style="zoom:50%"><p>下图调用 clear() 方法将读切换为写时各属性的变化：</p><img src="https://i.loli.net/2021/08/22/EUAXwtHRFs3fx45.png" style="zoom:50%"><h4 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel (通道)"></a>Channel (通道)</h4><p>通常来说 NIO 所有的操作都是由通道开始的，它跟我们平常使用的流（InputStream，OutputStream）有点类似。但也有些区别：</p><ul><li>通道可以读也可以写，流是单向的，所以需要输入流输出流；</li><li>通道可以异步读写</li><li>通道总是基于缓冲区来读写（将数据从通道读取到 buffer 或者将数据以 buffer 的形式写入到通道）</li></ul><p>下图是 Channel 的继承关系：</p><img src="https://i.loli.net/2021/08/22/hX9ZpyTK8v7Oinx.png" style="zoom:50%"><p>常用的 Channel 主要有四种：</p><ul><li><strong>FileChannel：</strong>用于文件数据的读写；</li><li><strong>DatagramChannel：</strong>用于 UDP 数据的读写；</li><li><strong>ServerSocketChannel 和 SocketChannel：</strong>用于 TCP 数据的读写，前者代表服务端的通道，后者代表客户端。</li></ul><p>使用 ServerSocketChannel 和 SocketChannel 进行 NIO 编程与直接使用 ServerSocket 和 Socket 类似，这里就不赘述了。</p><h4 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector (选择器)"></a>Selector (选择器)</h4><p>Selector 是多路复用器的一种，虽然它的性能不是最好的，但它几乎在所有平台上都支持，具有良好的跨平台性。</p><p>Selector 是实现一个线程处理多个客户端请求的核心组件， Channel 注册到 Selector 上之后，如果有就绪事件产生，Selector 就会去获取事件然后针对事件进行相应的处理。</p><p>Selector 常用方法如下：</p><ul><li><strong>open() ：</strong>静态方法，获取一个选择器对象；</li><li><strong>select()：</strong>调用后阻塞线程，阻塞期间会监控所有注册的通道，当有就绪事件需要操作时，会将 SelectionKey 放入集合并返回事件数量；</li><li><strong>select(1000)：</strong>只阻塞 1000 毫秒，阻塞期间与上面的方法相同；</li><li><strong>selectedKeys()：</strong>返回集合中保存的全部 SelectionKey 。</li></ul><p>这些方法多次提到了 SelectionKey ，那么 SelectionKey 是什么呢？</p><p>SelectionKey 就是用来描述各种就绪事件的类，通过它能获取到当前的就绪事件类型。</p><p>SelectionKey 通过 4 个常量来定义 4 种不同的就绪事件：</p><ul><li><strong>OP_READ：</strong>值为 1 &lt;&lt; 0，读就绪事件，表示通道中有可读数据，可以执行读操作；</li><li><strong>OP_WRITE：</strong>值为 1 &lt;&lt; 2，写就绪事件，表示可以向通道写数据了；</li><li><strong>OP_CONNECT：</strong>值为 1 &lt;&lt; 3，连接就绪事件，代表客户端与服务器连接已经建立成功了；</li><li><strong>OP_ACCEPT：</strong> = 1 &lt;&lt; 4，接收连接就绪事件，表示服务器监听到了客户端连接。</li></ul><p>SelectionKey 通过以下 4 个静态方法判断当前是否是对应的就绪事件：</p><ul><li>isReadable()：是否是读就绪事件；</li><li>isWritable()：是否是写就绪事件；</li><li>isConnectable()：是否是连接就绪事件；</li><li>isAcceptable()：是否是接收连接就绪事件。</li></ul><h3 id="原生-NIO-组件编程示例"><a href="#原生-NIO-组件编程示例" class="headerlink" title="原生 NIO 组件编程示例"></a>原生 NIO 组件编程示例</h3><p>下面是使用 Selector 、Channel 和 ByteBuffer 进行 NIO 编程的示例。</p><p>服务器端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zephyr.selector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端-选择器 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOSelectorServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//打开一个服务端通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//绑定对应的端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">//通道默认是阻塞的，需要设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//创建选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//将服务端通道注册到选择器上,并指定注册监听的事件为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动成功...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//检查选择器是否有事件</span></span><br><span class="line">            <span class="keyword">int</span> select = selector.select(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (select == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取事件集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//判断事件是否是客户端连接事件 SelectionKey.isAcceptable()</span></span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">//得到客户端通道,并将通道注册到选择器上, 并指定监听事件为OP_READ</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端已连接......&quot;</span> + socketChannel);</span><br><span class="line">                    <span class="comment">//必须设置通道为非阻塞, 因为selector需要轮询监听每个通道的事件</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//并指定监听事件为OP_READ</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断是否是客户端读就绪事件SelectionKey.isReadable()</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//得到客户端通道,读取数据到缓冲区</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> read = socketChannel.read(byteBuffer);</span><br><span class="line">                    <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端消息:&quot;</span> +</span><br><span class="line">                                <span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, read,</span><br><span class="line">                                        StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="comment">//给客户端回写数据</span></span><br><span class="line">                        socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;yo yo yo, hi man&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从集合中删除对应的事件, 因为防止二次处理.</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zephyr.selector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//打开通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置连接IP和端口号</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;What&#x27;s up.&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        <span class="comment">//读取服务器写回的数据</span></span><br><span class="line">        ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> read=socketChannel.read(readBuffer);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端消息:&quot;</span> + <span class="keyword">new</span> String(readBuffer.array(), <span class="number">0</span>, read, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        socketChannel.close(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么需要-Netty"><a href="#为什么需要-Netty" class="headerlink" title="为什么需要 Netty"></a>为什么需要 Netty</h2><p>上面讲了原生 NIO 相关的知识，那么问题就来了，既然原生就有完备的 NIO 编程的各个组件，为什么还需要 Netty 呢。</p><p>主要原因还是因为原生 NIO 存在一些弊端：</p><ul><li><strong>NIO 的类库和 API 繁杂：</strong>开发者需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等原生组件；</li><li><strong>有一定的门槛：</strong>必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序；</li><li><strong>开发工作量和难度都非常大：</strong>例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等；</li><li><strong>JDK NIO 的 Bug：</strong>臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。</li></ul><p>而 Netty 这个框架就很好地解决了这些问题，前三个比较好理解，简单讲一下第 4 个问题是怎么被解决的。</p><p>第 4 个问题讲到了 Selector 空轮询的 Bug，那么，什么是空轮询呢？</p><p>空轮询是指本来 Selector 调用 select() 方法如果没有就绪事件在设置的时间到之前是阻塞的，但由于 Linux 底层实现有问题，导致在没有就绪事件时也有概率直接返回，而 select() 方法一般都是放在 while (true) 循环里的，这时就会开始不断地空轮询，直到 CPU 使用率飙到 100% 。</p><p>Netty 解决这个问题主要分别两步：</p><ul><li><strong>检测空轮询：</strong>判断阻塞时间小于 timeoutMillis (初始化的超时参数)，且 select 执行次数大于阈值；</li><li><strong>重建 Selector ：</strong>新创建一个 Selector 并把旧 Selector 的 Channel 注册到这个 Selector 上，然后关闭这个 Selector；</li></ul><h2 id="Netty-线程模型"><a href="#Netty-线程模型" class="headerlink" title="Netty 线程模型"></a>Netty 线程模型</h2><p>接着我们学习一下 Netty 的线程模型，了解了 Netty 的线程模型之后我们对 Netty 的整体架构也就有了一个大致的了解。</p><p>由于 Netty 的线程模型是基于 Reactor 模型改进而来的，因此先讲讲 Reactor 模型，有助于我们对 Netty 线程模型的理解 。</p><h3 id="Reactor-模型"><a href="#Reactor-模型" class="headerlink" title="Reactor 模型"></a>Reactor 模型</h3><p>Reactor 模型是指当服务器接收到多个请求时，服务器程序会把它们分派到不同的方法或线程去处理。Reactor 模式也被称作 Dispatcher 模式。它的核心是多路复用器，多路复用器收到事件后会进行分发，这点是网络服务器高并发的关键。</p><p>Reactor 模型分为三种：单 Reactor 单线程、单 Reactor 多线程和多 Reactor 多线程。</p><p>这三种模型按顺序来看理解起来复杂度不断提升，也会更接近 Netty 的线程模型，下面来分别看看这三种模型。</p><h4 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h4><p>这个最好理解，只有一个线程，只是会把建立连接和处理请求这两种任务分发给不同的类去处理，如下图所示：</p><img src="https://i.loli.net/2021/08/22/5ze6rEIHLyKbjOf.png" style="zoom:50%"><p>整个流程简单来讲就是 Reactor 通过 Selector 监听事件，收到事件使用 dispatch 对事件进行分发，如果是连接事件就由 Acceptor 进行处理，处理完成会创建一个 Handler 对后续业务进行处理。后面的数据请求都会由 Handler 进行处理。</p><p>优点：</p><ul><li>模型简单，不会有多线程的那些问题</li></ul><p>缺点：</p><ul><li>性能问题：单线程无法发挥多核 CPU 的性能</li><li>可靠性问题：处理业务时往往容易出问题，当 Handler 出问题了，由于只有一个线程，整个节点也挂了</li></ul><h4 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h4><p>这个线程模型针对前面的问题作出了一定的优化，多出了处理业务的线程池，如下图所示：</p><img src="https://i.loli.net/2021/08/22/EdjKkUA3FiYMW2h.png" style="zoom:50%"><p>前面的流程与单 Reactor 单线程是一致的，到 Handler 这一步就不一样了。这个模型 Handler 只负责读取数据和发送数据部分，业务处理交给了 Worker 线程，而 Worker 线程是由 Worker 线程池统一管理的。</p><p>优点：</p><ul><li>可以充分利用多核 CPU 的处理能力</li></ul><p>缺点：</p><ul><li>多线程资源共享和访问处理会比较复杂，在主线程处理所有的连接、监听和响应也会出现性能瓶颈</li></ul><h4 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h4><p> 主从 Reactor 多线程模型又在前面的模型基础上做了进一步优化，增加了子 Reactor ，如下图所示：</p><img src="https://i.loli.net/2021/08/22/grdMeEPsibBuDFL.png" style="zoom:50%"><p>整个流程大概可以分为以下几步：</p><ul><li>主线程的 MainReactor 负责监听连接请求，收到连接请求会由 Acceptor 进行处理，成功建立连接之后 MainReactor 会把连接分派给 SubReactor ，由 SubReactor 监听和处理数据请求；</li><li>SubReactor 监听到数据请求，会派发给 Handler 处理，Handler 只会处理读取数据和发送数据部分，中间业务处理部分也是放在线程池中完成。</li></ul><p>优点：</p><ul><li>MainReactor 与 SubReactor 职责分明，一个处理连接事件，一个处理数据请求；</li><li>MainReactor 与 SubReactor 交互逻辑比较简单，MainReactor 单向地将建立好的连接传递出去；</li><li>多 Reactor 设计能在高并发场景拥有更好的性能。</li></ul><p>缺点：</p><ul><li>编程复杂度较高</li></ul><p>主从 Reactor 多线程模式是业界非常成熟的服务器程序设计模式，在很多中间件中都使用到了这种模式，像 Nginx、Memcached、Netty 等。这种模式也被称为 1 + M + N  模式，分别代指相对少的连接线程（不一定为 1 ），多个 I/O 线程和多个业务处理线程。</p><h3 id="Netty-线程模型-1"><a href="#Netty-线程模型-1" class="headerlink" title="Netty 线程模型"></a>Netty 线程模型</h3><p>Netty 线程模型是基于主从 Reactor 多线程模型优化而来的，整体架构如下图所示：</p><img src="https://i.loli.net/2021/08/22/aP4C5w82fmFhJEz.png" style="zoom:50%"><p>Netty 的线程模型主要分为两部分，分别是 BossGroup 和 WorkerGroup，它们都分别管理一个或多个 NioEventLoop。每个 NioEventLoop 对应着一个线程，一个 Selector，一个 Executor 和一个 TaskQueue。</p><p>NioEventLoop 可以理解成一个事件循环，当程序启动后每个 NioEventLoop 都会通过 Executor 启动一个线程，开始执行事件循环，在循环中 Selector 会通过 select 方法阻塞并监听就绪事件，当有事件到来时通过 processSeelectedKeys 方法处理 Selector  事件，之后再通过 runAllTasks 方法处理其他的任务。</p><p>与前面介绍的 主从 Reactor 多线程模型类似，BossGoup 负责连接事件，当建立连接之后会生成一个 NioSocketChannel 并注册到 WorkGroup 其中一个 NioEventLoop 的 Selector 上。WokerGroup 中的 NioEventLoop 负责处理数据请求，当请求到来时会调用 processSelectedKeys 方法，其中的业务处理会依次经过 Pipeline 中的多个 Handler。</p><h2 id="Netty-编程"><a href="#Netty-编程" class="headerlink" title="Netty 编程"></a>Netty 编程</h2><p>学习完 Netty 线程模型，我们来看一下使用 Netty 写出来的程序大概是什么样的。</p><h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><p>Nettry 服务器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">// 创建 BossGroup</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建 WorkerGroup</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">// 创建服务器启动类</span></span><br><span class="line">        ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">// 添加配置</span></span><br><span class="line">        bootstrap.group(bossGroup, workerGroup) <span class="comment">// 设置 BossGroup 和 ChildGroup</span></span><br><span class="line">                .channel(NioServerSocketChannel.class) <span class="comment">// 设置 Channel 具体类</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置连接队列</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE) <span class="comment">// 设置开启保活机制</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                      <span class="comment">// 把自定义 Handler 添加到 pipeline</span></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler()); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 绑定端口号</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>)).sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动成功！&quot;</span>);</span><br><span class="line">        <span class="comment">// 阻塞直到通道关闭</span></span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line">        <span class="comment">// 优雅地关闭 BossGroup</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        <span class="comment">// 优雅地关闭 WorkerGroup</span></span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义服务器端 ChannelHandler 代码，只列出了主要几个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext channelHandlerContext, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) o;</span><br><span class="line">        System.out.println(byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        Channel channel = channelHandlerContext.pipeline().channel();</span><br><span class="line">        System.out.println(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext channelHandlerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        channelHandlerContext.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;这是服务器的响应信息...&quot;</span>.getBytes(CharsetUtil.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext channelHandlerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通道注册&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><p>Netty 客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 EventLoopGroup</span></span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建启动类</span></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">// 设置参数</span></span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel.class) <span class="comment">// 设置 Channel 的类</span></span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 添加自定义 Handler</span></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>)).sync();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端启动成功！&quot;</span>);</span><br><span class="line">        <span class="comment">// 阻塞直到通道判断</span></span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line">        <span class="comment">// 优雅地关闭 EventLoopGroup</span></span><br><span class="line">        eventLoopGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义客户端 ChannelHandler 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext channelHandlerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        channelHandlerContext.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;这是客户端发来的消息&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext channelHandlerContext, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) o;</span><br><span class="line">        System.out.println(byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext channelHandlerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;通道注册&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对原生 NIO 编程比较熟悉理解上面的代码应该比较容易，同时也能看出使用 Netty 框架编程的难度是远远小于原生 NIO 的。</p><p>下面我们就详细了解一下上面代码涉及的这些 Netty 组件。</p><h2 id="Netty-的核心组件"><a href="#Netty-的核心组件" class="headerlink" title="Netty 的核心组件"></a>Netty 的核心组件</h2><h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><p>ChannelHandler 是一个接口，继承于它的两个接口 ChannelInboundHandler 和 ChannelOutboundHandler 定义了很多事件处理方法，我们可以通过实现这些方法或者重写子类的方法的来实现相应的业务逻辑。</p><p>ChannelHandler 的继承关系如图所示：</p><img src="https://i.loli.net/2021/08/22/hYUlJ2BbQ6Gp9PX.png" style="zoom:50%"><p>如果通过实现上述接口来开发，需要实现的方法中常用的有以下几个：</p><ul><li><code>public void channelActive(ChannelHandlerContext ctx)</code>  通道就绪事件；</li><li><code>public void channelRead(ChannelHandlerContext ctx, Object msg)</code> 通道读取数据事件；</li><li><code>public void channelReadComplete(ChannelHandlerContext ctx) </code> 数据读取完毕事件；</li><li><code>public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</code> 通道发生异常事件。</li></ul><p>但一般开发中自定义 Handler 会直接继承 <strong>SimpleChannelInboundHandler</strong> ，我们自己必须要实现的就只有 </p><p><code>protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s)</code> 这个方法，这种开发方式在继承的时候传入泛型指定出入站消息类型，配合编解码器使用会非常的方便。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChatRoomServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Channel active&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h3><p>ChannelHandlerContext 是 ChannelHandler 的上下文，它的核心就是 ChannelHandler ，它同时也保存了 Channel、Pipeline、Executor (NioEventLoop) 等信息。</p><p>它的继承关系如下图所示：</p><img src="https://i.loli.net/2021/08/22/eoS2B1HpzixqZms.png" sytle="zoom:50%"><p>Netty 中的 Context 分为三种： HeadContext 、TailContext 和 DefaultChannelHandlerContext 。</p><p>HeadContext 和 TailContext 比较特殊，它既是 ChannelHandlerContext 也是 ChannelHandler (实现了 Handler 的接口)。</p><p>我们通过 ChannelPipeline 的 addLast()  方法添加的 Handler 都会封装成 DefaultChannelHandlerContext 。</p><h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><p>ChannelPipeline 是一个接口，我们平常编程用到的一般是它的实现类 DefaultChannelPipeline 。</p><img src="https://i.loli.net/2021/08/22/qiEPlfDxIBjSh7H.png" style="zoom:50%"><h4 id="Pipeline-队列"><a href="#Pipeline-队列" class="headerlink" title="Pipeline 队列"></a>Pipeline 队列</h4><p>DefaultChannelPipline 其实就是一个管道，它维护了一个 ChannelHandlerContext 的双链表队列。</p><p>在 Pipeline 初始化时会创建头节点和尾节点，它们的类型分别是 HeadContext 和 TailContext，所以整个链表至少有两个节点。</p><p>中间的节点类型都是 DefaultChannelHandlerContext 。</p><p>链表如图所示：</p><img src="https://i.loli.net/2021/08/22/lBiekSwTsbvqJNG.png" style="zoom:50%"><h4 id="ChannelHandler-的传递性"><a href="#ChannelHandler-的传递性" class="headerlink" title="ChannelHandler 的传递性"></a>ChannelHandler 的传递性</h4><p>前面说过 Handler  分为 InboundHander 和 OutboundHandler ，消息入站时只会访问 InboundHander ，消息出站时只会访问 OutboundHander 。如果既是 InboundHandler 又是 OutboundHandler 出站入站都会访问。</p><p>而 InboundHandler 与 OutboundHandler 都具有传递性，不过传递方法有些区别：</p><ul><li> InboundHander 是向后传递，需要调用 ChannelHandlerContext 的 fireChannel…() ，比如如果是传递 ChannelRead() 方法就要调用 fireChannelRead() ，那么下一个节点的 ChannelRead() 方法就会被调用；</li><li> OutboundHandler 是向前传递，需要调用 ChannelHanderContext 的同名方法，比如如果是传递 write() 方法调用的也是 write() ，这里下一个节点的 write() 方法就会被调用。</li></ul><p>正常我们在开发中对数据的读写使用一个节点就够了，不需要使用这种传递性，这种传递性一般用在编解码器上。</p><p>无论是我们写子类自定义的编解码器还是使用 Netty 提供的编解码器，它们内部都会自动调用这些传递方法，开发者对这些是无感知的。</p><p>我们了解这些传递性的最大意义在于确定在添加 Handler 到 pipeline 中时（Handle 会被封装成 DefaultChannelHandlerContext 然后添加到队列中去）的顺序：</p><ul><li>先添加编解码器，并且解码器在前，编码器在后；</li><li>先添加 OutboundHandler ，后添加 InboundHandler。</li></ul><h4 id="Pipeline-消息入站"><a href="#Pipeline-消息入站" class="headerlink" title="Pipeline 消息入站"></a>Pipeline 消息入站</h4><p>消息入站首先是 Selector 监听到读就绪事件，接着判断就绪事件如果是读事件就调用通道的 read() 方法，通道会把消息读到 ByteBuf 里，然后把 ByteBuf 传递给 Pipeline 自已去处理。</p><p>Pipeline 会直接把 ByteBuf 交给 HeadContext 去处理，而 HeadContext  没有具体的处理逻辑，会直接传递给下一个节点去处理。</p><p>下图就是 Pipeline 节点的处理顺序：</p><img src="https://i.loli.net/2021/08/22/9Inv2tYPLGW3mkr.png" style="zoom:50%"><h4 id="Pipeline-消息出站"><a href="#Pipeline-消息出站" class="headerlink" title="Pipeline 消息出站"></a>Pipeline 消息出站</h4><p>消息出站与入站最大的不同是发起方。入站的消息是通过 Selector 监听到的。而出站是程序主动发起的。</p><p>对外写消息有三种方式：</p><ul><li>调用 channel 的 writeAndFlush()，它内部会直接调用 pipeline.writeAndFlush(msg)，最终会从队列尾部开始调用；</li><li>调用 pipeline 的 writeAndFlush()，它内部会直接调用 tail.writeAndFlush(msg)，最终也是从队列尾部开始调用；</li><li>调用 channelHandlerContext 的 writeAndFlush()，它内部会以当前节点为起点找到下一个 OutboundHandler 让它去处理，最终就是从这个节点的下一个 OutboundHander 开始处理。</li></ul><p>下图展示了各个节点处理顺序：</p><img src="https://i.loli.net/2021/08/22/oiJubvXxjAkFdQ1.png" style="zoom:50%"><h3 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h3><p>NioEventLoop 就是一个事件循环类，几乎所有事件处理都会经过这个类，它的继承关系如下：</p><img src="https://i.loli.net/2021/08/22/Y1wofKhseubE7c4.png" style="zoom:50%"><h3 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a>NioEventLoopGroup</h3><p>NioEventLoopGroup 就是 NioEventLoop 组，负责管理 NioEventLoop，当有 Channel 需要注册的时候，NioEventLoopGroup 会轮询找到下一个 NioEventLoop 注册上去。在 NioEventLoopGroup 上作出的配置最终都会作用到 NioEventLoop 上。</p><h3 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h3><p>在程序初始化的时候我们可以通过 ChannelOption 对 Channel 设置一些参数，常用的参数有两个：SO_BACKLOG 和 SO_KEEPALIVE。</p><p>下面分别讲讲这两个参数 ：</p><h4 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h4><p>这个参数主要是用来控制 Accept 队列的大小的 （早期的 Linux 内核是控制的 SYN 队列的大小）。</p><p>这里展开说一下这两个队列，它们都是由 Linux 内核维护的。一个是保存第一次握手的 SYN 的队列，系统会依次从这个队列取出 SYN 并进行响应，一个是保存三次握手完成后的 Accept 队列，调用 accept 方法就能拿到已完成连接的 socket，反应在 Netty 里面就是返回一个新的 Channel。</p><h4 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h4><p>这个参数对应的是连接的保活机制 ，如果不设置这个参数，请求完成连接就会被关闭。设置了这个参数之后，连接关闭的条件变成了如果客户端与服务器 2 个小时没有数据交互，那么客户端就会开始发探活数据报文，如果多次发送都没有响应，就断开连接。</p><h3 id="ServerBootstrap-和-Bootstrap"><a href="#ServerBootstrap-和-Bootstrap" class="headerlink" title="ServerBootstrap 和 Bootstrap"></a>ServerBootstrap 和 Bootstrap</h3><p>服务端和客户端的启动类，负责对 Netty 的各个组件进行配置。</p><p>服务器端配置代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(bossGroup, workerGroup) <span class="comment">// 设置 BossGroup 和 ChildGroup</span></span><br><span class="line">  .channel(NioServerSocketChannel.class) <span class="comment">// 设置 Channel 具体类</span></span><br><span class="line">  .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置连接队列</span></span><br><span class="line">  .childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE) <span class="comment">// 设置开启保活机制</span></span><br><span class="line">  .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 把自定义 Handler 添加到 pipeline</span></span><br><span class="line">      socketChannel.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>下图是 ChannelFuture 的继承关系</p><img src="https://i.loli.net/2021/08/22/B7YbqyROxSZ3AJP.png" style="zoom:50%"><p>从图中可以看出，它继承的 Future 接口是 Netty 自定义的接口，这个接口同时也继承自 Java 原生的 Future 接口。</p><p>在 Netty 中最常用的是 ChannelFuture 的子类  DefaultChannelPromise ，而这个类大部分功能都是由 DefaultPromise 实现的。</p><p>DefaultPromise 阻塞线程使用的是 Object 的 wait() 方法，而原生 Future 的子类 FutureTask 阻塞线程使用的是 LockSupport 的 park() 方法。</p><p>ChannelFuture 支持添加 ChannelFutureListener ，监听各种事件。</p><h3 id="Unpooled"><a href="#Unpooled" class="headerlink" title="Unpooled"></a>Unpooled</h3><p>这个类如果我们在使用 Netty 编程时不使用编解码器就会经常用到，它可以通过传入的字符串快速生成一个 ByteBuf (Netty 独有的类，类似于原生的 ByteBuffer，只是它在 ByteBuffer 的基础上做了封装) 对象。常用的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuf <span class="title">copiedBuffer</span><span class="params">(CharSequence string, Charset charset)</span></span></span><br></pre></td></tr></table></figure><h3 id="StringDecoder-和-StringEncoder"><a href="#StringDecoder-和-StringEncoder" class="headerlink" title="StringDecoder 和 StringEncoder"></a>StringDecoder 和 StringEncoder</h3><p>这两个类分别是 Netty 提供的解码器和编码器，它们同时也是 ChannelHandler 的子类。有了这两个编解码器，就不再需要与 ByteBuf 打交道，代码写起来也更简洁方便。</p><h4 id="StringDecoder"><a href="#StringDecoder" class="headerlink" title="StringDecoder"></a>StringDecoder</h4><p>下图是解码器类 StringDecoder 的继承关系，注意它的父类是实现了 ChannelInboundHandler 接口的，作用在消息入站的时候：</p><img src="https://i.loli.net/2021/08/22/yEiTlxcZsRIKv7X.png" style="zoom:50%"><p>如果有特殊需求需要自定义解码器也是可以的，只要实现 MessageToMessageDecoder 接口就可以了。</p><p>写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        list.add(byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StringEncoder"><a href="#StringEncoder" class="headerlink" title="StringEncoder"></a>StringEncoder</h4><p>下图是编码器类 StringEncoder 的继承关系，注意它的父类是实现了 ChannelOutboundHandler 接口的，作用在消息出站：</p><img src="https://i.loli.net/2021/08/22/NESwH3XGtTZDefz.png" style="zoom:50%"><p>如果要自定义编码器，实现 MessageToMessageEncoder 接口就行了。</p><p>写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        list.add(Unpooled.copiedBuffer(s, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果嫌为自定义编码器和自定义解码器分别创建一个类太麻烦，还可以直接继承 MessageToMessageCodec 接口。</p><p>这个接口继承关系如下，注意它的父类同时实现了 ChannelInboundHandler 和 ChannelOutboundHandler ，作用在消息入站和出站：</p><img src="https://i.loli.net/2021/08/22/I3dmTlZWBx4svH2.png" style="zoom:50%"><p>写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        list.add(Unpooled.copiedBuffer(s, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        list.add(byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LineBasedFrameDecoder-与-DelimiterBasedFrameDecoder"><a href="#LineBasedFrameDecoder-与-DelimiterBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder 与 DelimiterBasedFrameDecoder"></a>LineBasedFrameDecoder 与 DelimiterBasedFrameDecoder</h3><p>这两个类也都是解码器，但它们解决的问题与上面所讲的编解码器不同，这两个类主要是解决粘包拆包的问题。</p><p>那么问题来了，什么是粘包和拆包？为什么会出现粘包和拆包呢？</p><p>首先来说说什么是粘包和拆包：</p><p>在文章开始讲了 TCP 的三个重要的特点：面向连接、可靠的和字节流。而 Netty 底层是基于 TCP 的，它的客户端与服务端交互时发送的数据在传输层都是通过字节流传输的，字节流是没有界线的概念的，这时服务器在读取数据时就可能在一次读取中读取到到客户端分几次发的数据，这就叫粘包。如果客户端发送一次数据，服务器分几次才能完整读到，这就是拆包。</p><p>粘包拆包大致如下图所示：</p><img src="https://i.loli.net/2021/08/22/jiSeLqO5RJmKTA8.png" style="zoom:50%"><p>粘包拆包大致有以下几个原因：</p><ul><li><strong>socket缓冲区与滑动窗口:</strong> 在发送数据的时，发送方必须要先确认接收方的窗口没有被填充满，如果没有填满，则可以发送</li><li><strong>MSS/MTU限制</strong></li><li><strong>Nagle算法：</strong>Nagle算法是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。</li></ul><p>Netty 中解决粘包拆包的方法：</p><ul><li>FixedLengthFrameDecoder：固定长度拆包器，使用固定长度进行拆分；</li><li><strong>LineBasedFrameDecoder：</strong>行拆包器，使用换行符进行拆分；</li><li><strong>DelimiterBasedFrameDecoder：</strong>分隔符拆包器，使用自定义的分隔符进行拆分；</li><li>LengthFieldBasedFrameDecoder：基于数据包长度的拆包器，基于应用层协议中传过来的长度进行拆分。</li></ul><p>最常用的就是中间两个 LineBasedFrameDecoder 和 DelimiterBasedFrameDecoder。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 Netty 编程相关的知识点。Netty 的组件非常多，可以自定义的地方也非常多，但熟悉这些组件之后使用它们编程会非常方便快捷。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;详解-Netty&quot;&gt;&lt;a href=&quot;#详解-Netty&quot; class=&quot;headerlink&quot; title=&quot;详解 Netty&quot;&gt;&lt;/a&gt;详解 Netty&lt;/h1&gt;&lt;h2 id=&quot;什么是-Netty&quot;&gt;&lt;a href=&quot;#什么是-Netty&quot; class=&quot;headerlink&quot; title=&quot;什么是 Netty&quot;&gt;&lt;/a&gt;什么是 Netty&lt;/h2&gt;&lt;p&gt;简单来说 Netty 就是 JBOSS 开源的一个基于 NIO 的网络编程框架。它可以帮助我们快速开发高性能高可靠性的网络 IO 程序。&lt;/p&gt;
&lt;p&gt;Netty 在 Java 语言中使用非常广泛，涉及到网络通信的基本上都使用 Netty，很少会直接去使用原生的 NIO 组件或者是其他框架。并且像Dubbo、RocketMQ、Zookeeper、ElasticSearch 这些知名的中间件所使用的网络通讯框架都是基于 Netty 去实现的。&lt;/p&gt;
&lt;p&gt;Netty 是在原生 NIO 的基础上发展起来的框架，其中的许多理念都非常像，所以学习 Netty 前需要了解一下原生 NIO 编程。&lt;/p&gt;
&lt;h2 id=&quot;原生-NIO-编程&quot;&gt;&lt;a href=&quot;#原生-NIO-编程&quot; class=&quot;headerlink&quot; title=&quot;原生 NIO 编程&quot;&gt;&lt;/a&gt;原生 NIO 编程&lt;/h2&gt;&lt;p&gt;在了解原生 NIO 编程之前需要了解一个基础概念 Socket。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://anye3210.github.io/tags/java/"/>
    
    <category term="netty" scheme="http://anye3210.github.io/tags/netty/"/>
    
    <category term="网络编程" scheme="http://anye3210.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="nio" scheme="http://anye3210.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>多图详解AQS</title>
    <link href="http://anye3210.github.io/2021/08/09/%E5%A4%9A%E5%9B%BE%E8%AF%A6%E8%A7%A3AQS/"/>
    <id>http://anye3210.github.io/2021/08/09/%E5%A4%9A%E5%9B%BE%E8%AF%A6%E8%A7%A3AQS/</id>
    <published>2021-08-08T16:31:01.000Z</published>
    <updated>2021-08-22T07:03:30.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h2><p>AQS 的全称是 AbstractQueuedSynchronizer ，从字面理解它就是抽象的队列同步器。它是可重入锁、各种同步工具类（共享锁）和条件等待唤醒机制实现的基石。</p><p>AQS 有一个重要的属性 state，它的值直接关系着其他线程能否获取到锁。</p><p>如果我们看过可重入锁、各种同步工具类（共享锁）的源码，会发现这些锁的关注点都在于通过 AQS 的 state 值或者能否通过 CAS 修改 state 的值来判断当前线程能否获取到锁（这里判断是否能获取到锁都是靠 AQS 的子类 Sync 和 Sync的子类实现的，而这些子类的具体方法是锁自己去实现的——归根到底这部分就是锁来实现的）。如果获取锁成功，直接扣减 AQS 的 State 值，不会涉及到 AQS。但如果当前线程获取锁失败，那么剩下的包括阻塞唤醒线程、重新发起获取锁之类的操作全都都会扔给 AQS 。简单来说就是 AQS 包揽了同步机制的各种工作。这就是为什么理解了 AQS 再去理解各种锁就会非常容易，它的重要性也就不言而喻了。</p><p>下图就是线程获取锁的大致流程：</p><span id="more"></span><img src="https://i.loli.net/2021/08/09/xgLhv4a6AZTDUEV.png" alt="xgLhv4a6AZTDUEV.png" style="zoom:50%;"><p>下面就是使用 AQS 实现的最简单的独占锁，从代码也可以看出 AQS 大大降低了开发锁的难度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.tryRelease(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AQS-的在-ReentrantLock-中的应用"><a href="#AQS-的在-ReentrantLock-中的应用" class="headerlink" title="AQS 的在 ReentrantLock 中的应用"></a>AQS 的在 ReentrantLock 中的应用</h2><p>各种锁对于 AQS 的使用方式大致相同，这里以 ReentrantLock 为例来讲解。</p><p>ReentrantLock 的实现比上面的例子会复杂一点，但大体思路是相同的。</p><p>ReentrantLock 并不是直接继承自 AQS，它实现了 Lock 的接口并对外提供锁的各种功能。它通过内部的 AQS 子类 <strong>Sync</strong> 来使用 AQS 的功能，这样设计的好处在于锁的功能和同步器的功能划分更清晰，方便扩展和维护。</p><p>由于 ReentrantLock 支持公平锁和非公平锁，<strong>Sync</strong> 又有两个分别实现了公平锁和非公平锁功能的子类 <strong>FairSync</strong> 和 <strong>NonfairSync</strong> 。继承关系如下图所示：</p><img src="https://i.loli.net/2021/08/09/7lTu1qIycXO2Qp4.png" style="zoom:50%"><p>这里着重讲一下 ReentrantLock 的 <code>lock()</code>和<code>unlock</code>方法。<code>lock()</code>方法内部就一句代码``sync.lock();<code>实际是调用的 **FairSync** 或 **NonfairSync** 的</code>lock()<code>方法，而</code>unlock<code>方法是直接通过 **Sync** 类来调用 AQS 的</code>release()`方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sync.lock(); <span class="comment">// 实际是调用的 FairSync 或 NonfairSync 的`lock()`方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sync.release(<span class="number">1</span>); <span class="comment">// AQS的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再看看<strong>FairSync</strong> 或 <strong>NonfairSync</strong> 的<code>lock()</code>方法的具体实现：</p><h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a><strong>FairSync</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">acquire(<span class="number">1</span>); <span class="comment">// AQS的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a><strong>NonfairSync</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// 尝试直接获取锁</span></span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 获取锁成功后设置当前线程为独占线程</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>); <span class="comment">// AQS的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，加锁解锁其实本质都是去调用 AQS 的<code>acquire()</code>和 <code>release()</code>方法。这两个方法在后面会详细讲解。</p><p>在 <strong>Sync</strong>和 <strong>Sync</strong> 的子类里还有两个重要的方法：<code>tryAcquire()</code>和<code>tryRelease()</code>，它们都是AQS 为独占锁提供的勾子方法，分别代表尝试获取锁和尝试释放锁。其中<code>tryRelease()</code>是由 <strong>Sync</strong> 来实现的，<code>tryAcquire()</code>是由 <strong>Sync</strong> 的子类来实现的。这点其实也比较好理解，ReentrantLock 支持公平锁和非公平锁，这两种锁的差异就体现的尝试获取锁这里，而释放锁的逻辑是一致的。由于 ReentrantLock 不是本文的重点，这两个方法就不详细说了。</p><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>条件等待和条件唤醒功能一般都是 ReentrantLock 与 AQS 的内部类 ConditionObject 配合实现的。一个 ReentrantLock 可以创建多个 ConditionObject 实例，每个实例对应一个条件队列，以保证每个实例都有自己的等待唤醒逻辑，不会相互影响。</p><p>条件队列里的线程对应的节点被唤醒时会被放到 ReentrantLock 的同步队列里，让同步队列去完成唤醒和重新尝试获取锁的工作。可以理解为条件队列是依赖同步队列的，它们协同才能完成条件等待和条件唤醒功能。</p><h2 id="AQS-的构成"><a href="#AQS-的构成" class="headerlink" title="AQS 的构成"></a>AQS 的构成</h2><p>讲完应用，下面讲讲AQS 的构成。</p><p> AQS 的继承关系如下图所示：</p><img src="https://i.loli.net/2021/08/09/g4zQC65wZVFnjB3.png" style="zoom:50%;"><p>从图中可以看出 AQS 继承了另外一个抽象类 AbstractOwnableSynchronizer，这个类的功能其实就是持有一个不能被序列化的属性 exclusiveOwnerThread ，它代表独占线程。在属性中记录持有独占锁的线程的目的就是为了实现可重入功能，当下一次获取这个锁的线程与当前持有锁的线程相同时，就可以获取到锁，同时 AQS 的 state 值会加1。</p><p>图中红线部分标识了 AQS 的两个内部类，一个是 Node， 一个是 ConditionObject。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node就是 AQS 实现各种队列的基本组成单元。它有以下几个属性：</p><ul><li><strong>waitStatus：</strong>代表节点状态：CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)、0（初始状态）</li><li><strong>prev：</strong>代表同步队列的上一个节点</li><li><strong>next：</strong>代表同步队列的下一个节点</li><li><strong>thread：</strong>节点对应的线程</li><li><strong>nextWaiter：</strong>在同步队列里用来标识节点是独占锁节点还是共享锁节点，在条件队列里代表条件条件队列的下一个节点</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>AQS 总共有两种队列，一种是同步队列，代表的是正常获取锁释放锁的队列，一种是条件队列，代表的是每个 ConditionObject 对应的队列，这两种队列都是 <strong>FIFO</strong> 队列，也就是先进先出队列。</p><h5 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h5><p>而同步队列的节点分为两种，一种是独占锁的节点，一种是共享锁的节点，它们唯一的区别就是 nextWaiter 这个指针的值。如果是独占锁的节点，nextWaiter 的值是 null，如果是共享锁的节点，nextWaiter 会指向一个静态变量 SHARED 节点。独占锁队列和共享锁队列如下图所示：</p><img src="https://i.loli.net/2021/08/09/EaweKZPbOm8FALt.png" style="zoom:50%;"><h5 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h5><p>条件队列是单链，它没有空的头节点，每个节点都有对应的线程。条件队列头节点和尾节点的指针分别是 firstWaiter 和 lastWaiter ，如下图所示：</p><img src="https://i.loli.net/2021/08/09/NGZIuyFCjr5UYLw.png" style="zoom:50%;"><h4 id="waiteStatus"><a href="#waiteStatus" class="headerlink" title="waiteStatus"></a>waiteStatus</h4><p>讲完队列我们来着重看一下节点的这个属性，它代表着节点的等待状态。这个属性非常重要，如果不理解它，后面 AQS 源码部分也会很难理解。</p><p>首先看一下 waiteStatus 的取值：</p><ul><li><strong>CANCELLED</strong> 取消状态，值为1</li><li><strong>0</strong> 初始状态</li><li><strong>SIGNAL</strong> 通知状态，值为 -1</li><li><strong>CONDITION</strong> 条件等待状态，值为 -2</li><li><strong>PROPAGATE</strong> 传播状态，值为 -3</li></ul><p>这些状态我们一个一个看。</p><p><strong>CANCELLED</strong> 代表着取消状态，它的值是 1，注意这些状态里只有它的值是大于 0 的，所以源码里判断是取消状态是直接通过 waiteStatus 值是否大于 0 来判断。</p><p>如果 waiterStatus 的值为 0，有两种情况：1、节点状态值没有被更新过（同步队列里最后一个节点的状态）；2、在唤醒线程之前头节点状态会被被修改为 0。</p><p><strong>SIGNAL</strong> 代表着通知状态，这个状态下的节点如果被唤醒，就有义务去唤醒它的后继节点。这也就是为什么一个节点的线程阻塞之前必须保证前一个节点是 SIGNAL 状态。</p><p><strong>CONDITION</strong> 代表条件等待状态，条件等待队列里每一个节点都是这个状态，它的节点被移到同步队列之后状态会修改为 0。</p><p><strong>PROPAGATE</strong> 传播状态，在一些地方用于修复 bug 和提高性能，减少不必要的循环。</p><h2 id="park-和-unpark"><a href="#park-和-unpark" class="headerlink" title="park() 和 unpark()"></a>park() 和 unpark()</h2><p>讲 AQS 源码之前有一个重要的概念需要理解一下，那就是 Unsafe 这个类的 <code>park()</code> 和 <code>unpark()</code> 方法。</p><p>注意在 AQS 里并没有直接调用 Unsafe 的这两个方法，而是通过 LockSupport 间接调用的 Unsafe 的这两个方法，LockSupport 里面封装了一些参数来简化调用过程。</p><p>Unsafe 的这两个方法其实就是对许可的管理，<code>park()</code> 方法是让线程去获取一个许可，如果获取失败就阻塞当前线程，<code>unpark()</code> 方法是释放一个许可，如果当前线程是阻塞的，会唤醒当前线程。</p><p>这个许可简单理解就像一个人要去过一个城关，规定有令牌才能过，没有令牌就得等着。<code>park()</code>方法就是城关的守卫来检查你的令牌，你能拿出来就过去了，没拿出来就得原地等着。<code>unpark()</code>方法就是有人送来一块令牌，如果发现你已经有了，就不送了，如果发现你正好没有，就送给你。而如果这个时候你刚好等在城门口，那么你顺手就把刚得到的令牌给守卫，守卫就放你过去了。</p><h2 id="AQS-源码分析"><a href="#AQS-源码分析" class="headerlink" title="AQS 源码分析"></a>AQS 源码分析</h2><p>AQS 源码分析分为三部分：独占锁部分、共享锁部分和条件等待条件通知部分。</p><h3 id="独占锁部分"><a href="#独占锁部分" class="headerlink" title="独占锁部分"></a>独占锁部分</h3><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h4><p>首先是 <code>acquire()</code> 方法，下面是源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">// 这里 Node.EXCLUSIVE 的值是 null</span></span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>tryAcquire(arg)</code>方法是由具体的锁来实现的，这个方法主要是尝试获取锁，获取成功就不会再执行其他代码了，这个方法结束。获取失败会进入下一步<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>。这里有个方法嵌套，我们先看<code>addWaiter(Node.EXCLUSIVE)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 如果尾节点不为空，就把节点放在尾节点后面并设置为新的尾节点</span></span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 尝试把节点设置为新的尾节点</span></span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法前半段比较好理解，先创建一个节点，如果有尾节点，就让这个节点指向当前的尾节点，并把它设置成新的尾节点，设置失败也没关系，后面会进入一个重要方法<code>enq()</code>。如果当前没有尾节点，会直接进入到<code>enq()</code>方法。下面是<code>enq()</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Node t = tail;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 如果尾节点为空，那么队列也为空，新建一个头节点，让 head 和 tail 都指向它</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果有尾节点，把传入的节点放入队尾</span></span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next = node;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个方法就做两件事：</p><p>1、判断如果没有尾节点，那么队列肯定是空的，也不会有头节点，这个时候就要去新增一个空节点，通过 CAS 将这个空节点设置成头节点，然后 tail 指针也指向这个空节点。</p><p>2、如果有尾节点，就把当前节点放在尾节点后面，然后通过 CAS 尝试将 tail 指针指向这个节点，直到成功为止。</p><p>下图展示了初始队列为空时节点的变化，队列不为空的情况也类似于下图单节点到双节点的情况，都是在尾节点后续追加节点。</p><img src="https://i.loli.net/2021/08/09/rnOF1qiIH8flaVZ.png" style="zoom:50%;"><p>看完了<code>addWaiter()</code>方法，接下来就是另一个非常重要的方法<code>acquireQueued()</code>，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 核验并获取前一个节点，如果前一个节点不存在，直接抛异常</span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果前一个节点就是头节点，让这个节点的线程尝试获取锁</span></span><br><span class="line">setHead(node); <span class="comment">//获取锁成功后把当前节点设置为头节点</span></span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// 将之前头节点的 next 指针置空，后面 GC 时会回收这个节点</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 判断是否应该阻塞当前线程（核心是判断并修正前面节点的 waitStatus）</span></span><br><span class="line">parkAndCheckInterrupt()) <span class="comment">// 阻塞当前线程、返回并清除中断标记</span></span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也分两种情况：</p><p>1、当前活跃的线程对应的节点就是同步队列的第二个节点，那么就让当前线程去尝试获取锁，直到成功为止，如果获取锁成功就把这个节点设置成头节点；</p><p>2、当前活跃线程是第三个或者更后面的节点，那么就会进入判断是否需要阻塞并进而阻塞的逻辑。</p><p>出现第一种情况有两种可能：</p><p>1、这个节点刚入队列而且这个队列只有头节点和这个节点；</p><p>2、本来这个节点是排在后面的，前面的节点一个个被唤醒之后它的位置也不断往前移，最终它作为第二个节点也被唤醒了。</p><p>整个方法的大致流程如下图所示：</p><img src="https://i.loli.net/2021/08/09/lAL2CIwd9HnaZoD.png" style="zoom:50%;"><p>下面重点讲一下第二种情况，也就是涉及阻塞线程的情况。</p><p>先看看<code>shouldParkAfterFailedAcquire()</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 判断前面节点状态为 SIGNAL ，返回 true</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果前面的节点状态为取消（CANCEL值为1）,就一直向前查找，直到找到状态不为取消的节点，把它放在这个节点后面</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">// 如果前面节点不是取消也不是 SIGNAL 状态，将其设置为 SIGNAL 状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是判断前一个节点的状态：</p><p>1、如果是 SIGNAL 就返回 true 表示可以阻塞当前线程；</p><p>2、如果前面节点状态大于零，也就是取消状态，那么一直往前移直到它前面的节点不是取消状态；</p><p>3、如果不是前两种状态，那么把前一个节点状态设置成 SIGNAL 。</p><p>除了第一种状态，后面两种状态都会返回 false，后面经过循环再次进去这个方法。</p><img src="https://i.loli.net/2021/08/09/XV7xBqUAHsNCguW.png" style="zoom:50%;"><p>当前面一个方法返回 true 时，就会进入下一个判断，也就是<code>parkAndCheckInterrupt()</code>方法，下面是方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 阻塞当前线程</span></span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 返回并清除当前线程中断状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，就做两件事：阻塞当前线程和返回并清除中断状态。</p><p>上面就是<code>acquire()</code>部分的源码，接着讲与它对应的另一个方法<code>release()</code>。</p><h4 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h4><p>下面是 <code>release()</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 尝试释放锁，如果成功则唤醒后继节点的线程</span></span><br><span class="line">Node h = head;</span><br><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">unparkSuccessor(h); <span class="comment">// 唤醒后面节点中第一个非取消状态节点的线程</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法的开始做了一个判断：</p><p>1、如果当前线程释放锁失败，就直接返回了；</p><p>2、如果释放锁成功，那么就会接着判断头节点是否为空和头节点 waitStatus 是否不为 0 。</p><p>这里判断头节点状态是一个比较重要的点。为什么头节点的状态一定不能为 0 呢？从后面要讲到源码可以知道，在唤醒头节点的后继之前会做一个将头节点状态置为 0 的操作（虽然这个操作不一定成功）。如果头节点的状态为 0 了，说明正在释放后继节点，这时候也就不再需要释放了，直接返回 true。</p><p>头节点状态判断之后，就会进入到释放后继节点这一步，也就是<code>unparkSuccessor()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ws = node.waitStatus; <span class="comment">// 这里取的是头节点的状态</span></span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">  compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 尝试将头节点状态设置为 0，不保证能设置成功</span></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果后面这个节点状态为取消，那么就找到一个位置最靠前的非取消状态的节点</span></span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">    <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">      s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">  LockSupport.unpark(s.thread); <span class="comment">// 唤醒符合条件的后继节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的核心目标是唤醒头节点符合条件的后继节点。因此前面做了一个判断，如果后面这个节点不是取消状态也不为空，那么就直接唤醒它。如果后面的节点不符合要求，那么就开始从后往前遍历，找到一个最靠前的并且是非取消状态的非空节点，然后唤醒它对应的线程。</p><p>整个方法的流程如下图所示：</p><img src="https://i.loli.net/2021/08/09/UgRt2nJE1VqyS4m.png" style="zoom:50%;"><h3 id="共享锁部分"><a href="#共享锁部分" class="headerlink" title="共享锁部分"></a>共享锁部分</h3><h4 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared()"></a>acquireShared()</h4><p>了解完独占锁的加锁和解锁的逻辑，接着来讲讲共享锁的加锁和解锁逻辑。</p><p>下面是 <code>acquireShared()</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就两行：第一行判断尝试获取锁的返回值是否小于0，这里的返回值是指当前信号量减去传入的信号量的结果，小于0就代表当前信号量不足，获取锁失败，这时候就需要 AQS 接管了；第二行是执行阻塞和唤醒后获取锁的方法。</p><p>下面是<code>doAcquireShared()</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 1、共享节点入队</span></span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 2、尝试获取共享锁（相当于尝试扣减信号量）</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          setHeadAndPropagate(node, r); <span class="comment">// 3、设置头节点并且做一些判断，符合条件会唤醒下一个节点</span></span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          <span class="keyword">if</span> (interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node)</span><br><span class="line">        parkAndCheckInterrupt()) <span class="comment">// 线程会阻塞在这个位置，被唤醒后再继续循环</span></span><br><span class="line">        interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">      cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法大部分代码与前面讲的 <code>acquireQueued()</code> 方法是相同的。这里着重讲不同的地方。</p><p>首先是标记的第 1 处 <code>final Node node = addWaiter(Node.SHARED);</code> 这里参数是传的静态常量 SHARED ，这个值会赋给新生成节点的 nextWaiter 。正如前面说的，通过 nextWaiter 的值我们就能判断这个节点是独占锁的节点还是共享锁的节点。</p><p>然后是标记为 2 的这行代码 <code>int r = tryAcquireShared(arg);</code> 这代表尝试获取锁之后的值，如果剩下的信号量不为负，那就代表获取锁成功了，就会进入到标识为 3 的这个方法。</p><p>下面我们来看看标记为 3 的 <code>setHeadAndPropagate(node, r)</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">  Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">  setHead(node); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||  <span class="comment">// 2</span></span><br><span class="line">      (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">      doReleaseShared();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法代码也不多，主要是两块内容：第一个是 <code>setHead(node)</code> 方法，这个方法让第二个节点变成头节点，置空之前头节点的部分指针；第二块内容做了大量的判断，然后如果符合条件会执行 <code>doReleaseShared();</code>，这个方法也是后面重点要讲的唤醒共享锁同步队列线程的方法。</p><p>这里详细讲一下第二块内容做的这些判断：</p><ul><li><code>propagate &gt; 0</code> ：propagate 是传入的参数，代表获取锁成功之后剩余的信号量，如果为正，说明其他线程也可能获取到锁，就会执行后面的唤醒逻辑；</li><li><code>h == null</code>：之前的头节点是空，这里代表异常情况，也需要唤醒线程避免后面的线程都不会被唤醒的情况出现；</li><li><code>h.waitStatus &lt; 0</code>：这里代表保存旧的头节点和设置新的头节点的间隙又有新的节点将会或已经被阴塞了，这个情况也需要执行唤醒让线程重新尝试获取锁；</li><li><code>(h = head) == null </code>：这里代表新的头节点异常，与旧头节点异常一样需要做唤醒操作；</li><li><code>h.waitStatus &lt; 0</code>：这个代表设置新节点成功到做这个判断的间隙又有新节点将会或已经被阻塞了，同样需要唤醒；</li><li><code>s == null</code>：这个代表队列只有头节点或者发生异常，统一做唤醒操作，主要还是处理异常情况；</li><li><code>s.isShared()</code>：这个判断代表只要是共享节点并且满足唤醒条件都会执行唤醒。</li></ul><p>这个方法里实现了链式唤醒：当一个线程被唤醒并获取到锁，如果满足条件就会去唤醒其他线程来尝试获取锁，这种唤醒能一直传递下去，使得共享锁获取锁的效率大大提升。</p><h4 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared()"></a>releaseShared()</h4><p>接着讲另一个重要的方法<code>releaseShared()</code>，下面是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    doReleaseShared();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法除了返回值，核心代码也只有两行：第一行代表尝试释放锁，释放失败就直接返回了，释放成功就会执行唤醒后继节点线程操作；第二行就是具体的唤醒线程的方法；</p><p>下面是 <code>doReleaseShared()</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">      <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">          <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">               !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">        <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法的循环里对头节点做了大量的判断，头节点的状态满足条件才会执行唤醒操作，我们挨个来看看这些判断的作用：</p><ul><li><code>ws == Node.SIGNAL</code>：从前面的源码可以知道，一个节点阻塞前它前面的节点的 waiteStatus 必须为 SIGNAL ，如果在做唤醒操作这个值就会变，做这个判断主要是确保当前队列没有其他线程在做唤醒操作；</li><li><code>!compareAndSetWaitStatus(h, Node.SIGNAL, 0)</code>：尝试将头节点 waiteStatus 值设置为 0，代表这个 FIFO 队列正在做唤醒操作，注意与独占锁不一样，这里要确保这个值是设置成功的；</li><li><code>ws == 0 &amp;&amp;!compareAndSetWaitStatus(h, 0, Node.PROPAGATE)</code>：这个判断主要是为了确保前面获取到的头节点 waiteStatus 的值与实时获取的头节点 waiteStatus 值相同。什么样的情况下前面做一个判断的间隙这里头节点的状态就变了呢？那就是有新节点入队放在头节点后面并准备阻塞或者已经阻塞了，由于是否阻塞有不确定性，这里就会重新循环获取最新的状态，避免同时做阻塞和唤醒的动作。</li></ul><p>而 <code>unparkSuccessor()</code> 方法前面已经讲过，这里就不重复讲了。 </p><h3 id="条件等待和条件通知"><a href="#条件等待和条件通知" class="headerlink" title="条件等待和条件通知"></a>条件等待和条件通知</h3><p>条件等待和条件通知功能主要由 AQS 内部类 ConditionObject 的两个重要的方法： <code>await()</code> 和 <code>signal()</code> 来实现。</p><h4 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h4><p><code>await()</code>  方法正如字面意思一样，就是等待。它与 Object 对象的 <code>wait()</code> 方法不同的是，Object 的 <code>wait()</code> 方法调用后，任何对象调用 <code>notify</code> 都能唤醒它，而 <code>await()</code> 方法调用后，只有调用 <code>await()</code> 方法的实例调用的 <code>notify()</code> 方法才能唤醒它，因此 <code>await()</code> 是一个条件等待方法。</p><p>方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  Node node = addConditionWaiter(); <span class="comment">// 生成一个新的节点添加到条件队列</span></span><br><span class="line">  <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">// 调用同步队列释放锁的方法</span></span><br><span class="line">  <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123; <span class="comment">// 节点是否已经转移到了同步队列中</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">// 没有被转移就阻塞线程</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>) <span class="comment">// 根据线程中断状态设置 interruptMode </span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) <span class="comment">// 调用同步队列阻塞和尝试获取锁的方法</span></span><br><span class="line">    interruptMode = REINTERRUPT;</span><br><span class="line">  <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters(); <span class="comment">// 把节点等待状态（waitStatus）不为 CONDITION 的节点移除</span></span><br><span class="line">  <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode); <span class="comment">// 根据不同的中断模式决定是抛出中断异常还是重新标记中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别注意的是这个方法是支持中断的，而且方法中很多判断和方法都是与中断有关的，具体哪些地方什么情况会抛出中断异常这里不详细说，这个不是本文的重点。</p><p>首先讲讲 <code>addConditionWaiter()</code> 这个方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node t = lastWaiter;</span><br><span class="line">  <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">  <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">    unlinkCancelledWaiters(); <span class="comment">// 把所有节点等待状态不为 CONDITION 的节点移除</span></span><br><span class="line">    t = lastWaiter;</span><br><span class="line">  &#125;</span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION); <span class="comment">// 新建一个条件队列的节点</span></span><br><span class="line">  <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">    firstWaiter = node;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    t.nextWaiter = node;</span><br><span class="line">  lastWaiter = node;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了两件事：</p><p>1、如果队列不为空而且最后一个节点等待状态异常，就做一个全队列扫描，去掉异常的节点；</p><p>2、把节点入队，这里要做一个判断：如果队列为空，把新节点作为头节点，如果队列非空，把新节点放在队尾。</p><p>接着是 <code>isOnSyncQueue()</code> 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是用来判断当前线程的节点是否已经在同步队列了，这个方法涉及三个判断：</p><p>1、如果节点等待状态是 CONDITION 或者节点的 prev 指针为空（节点在同步队列这个指针才有值），那么一定不是在同步队列；</p><p>2、如果节点的 next 指针不为空，那么一定在同步队列；</p><p>3、遍历同步队列，看队列中有没有节点与这个节点相同。</p><h4 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h4><p><code>signal()</code> 方法是与 <code>await()</code>  方法对应的，一个负责通知，一个负责等待。</p><p>下面是 <code>signal</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  Node first = firstWaiter;</span><br><span class="line">  <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">    doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isHeldExclusively()</code> 这个方法返回的是该线程是否正在独占资源，如果不是的话会抛出异常。</p><p>整个 <code>signal()</code> 方法的重点里面调用的 <code>doSignal()</code> 方法，传入的参数是头节点。</p><p>下面是 <code>doSignal()</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>) <span class="comment">// 判断头节点的下一个节点是否为 null</span></span><br><span class="line">      lastWaiter = <span class="keyword">null</span>; <span class="comment">// 如果队列只有头节点，将 lastWaiter 指针置为 null</span></span><br><span class="line">    first.nextWaiter = <span class="keyword">null</span>; <span class="comment">// 迁移节点前先将节点的 nextWaiter 置为 null</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; <span class="comment">// 把头节点迁移到同步队列中去</span></span><br><span class="line">           (first = firstWaiter) != <span class="keyword">null</span>); <span class="comment">// 没有迁移成功就重新获取头节点判断不为空继续循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也没有太复杂的内容，具体可以看看上面的注释，这里详细讲讲 <code>transferForSignal()</code> 。</p><p>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) <span class="comment">// 将节点 waitStatus 通过 CAS 更新为 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 更新失败说明节点等待状态已经变了，返回 false 重新获取头节点然后重试</span></span><br><span class="line">  Node p = enq(node); <span class="comment">// 将节点放入同步队列中</span></span><br><span class="line">  <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) <span class="comment">// 判断前一个节点等待状态，如果状态是正常的赋值为 SIGNAL</span></span><br><span class="line">    LockSupport.unpark(node.thread); <span class="comment">// 前面节点状态为取消或就会唤醒当前节点，避免后面没办法被唤醒</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个迁移队列变化如下图所示：</p><img src="https://i.loli.net/2021/08/09/QKMvj8ezx4OYsT1.png" style="zoom:50%;"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于 AQS 的全部内容，看到这里大家应该就会有一个直观的感受：AQS 其实核心就是队列，队列又是为各种锁服务的。了解这些队列节点的阻塞唤醒时机对我们去了解各种锁非常有帮助。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是AQS&quot;&gt;&lt;a href=&quot;#什么是AQS&quot; class=&quot;headerlink&quot; title=&quot;什么是AQS&quot;&gt;&lt;/a&gt;什么是AQS&lt;/h2&gt;&lt;p&gt;AQS 的全称是 AbstractQueuedSynchronizer ，从字面理解它就是抽象的队列同步器。它是可重入锁、各种同步工具类（共享锁）和条件等待唤醒机制实现的基石。&lt;/p&gt;
&lt;p&gt;AQS 有一个重要的属性 state，它的值直接关系着其他线程能否获取到锁。&lt;/p&gt;
&lt;p&gt;如果我们看过可重入锁、各种同步工具类（共享锁）的源码，会发现这些锁的关注点都在于通过 AQS 的 state 值或者能否通过 CAS 修改 state 的值来判断当前线程能否获取到锁（这里判断是否能获取到锁都是靠 AQS 的子类 Sync 和 Sync的子类实现的，而这些子类的具体方法是锁自己去实现的——归根到底这部分就是锁来实现的）。如果获取锁成功，直接扣减 AQS 的 State 值，不会涉及到 AQS。但如果当前线程获取锁失败，那么剩下的包括阻塞唤醒线程、重新发起获取锁之类的操作全都都会扔给 AQS 。简单来说就是 AQS 包揽了同步机制的各种工作。这就是为什么理解了 AQS 再去理解各种锁就会非常容易，它的重要性也就不言而喻了。&lt;/p&gt;
&lt;p&gt;下图就是线程获取锁的大致流程：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://anye3210.github.io/tags/Java/"/>
    
    <category term="AQS" scheme="http://anye3210.github.io/tags/AQS/"/>
    
    <category term="锁" scheme="http://anye3210.github.io/tags/%E9%94%81/"/>
    
    <category term="ReentrantLock" scheme="http://anye3210.github.io/tags/ReentrantLock/"/>
    
    <category term="共享锁" scheme="http://anye3210.github.io/tags/%E5%85%B1%E4%BA%AB%E9%94%81/"/>
    
    <category term="Lock" scheme="http://anye3210.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>详解Java类加载过程</title>
    <link href="http://anye3210.github.io/2021/08/02/%E8%AF%A6%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://anye3210.github.io/2021/08/02/%E8%AF%A6%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2021-08-02T14:53:13.000Z</published>
    <updated>2021-08-22T07:14:52.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类从被加载到虚拟机开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。整个过程如下图所示：</p><img src="https://i.loli.net/2021/08/02/265OIqCLtMSwJkY.png" alt="类加载的生命周期.png" style="zoom:50%;" /><p>加载、验证、准备、初始化和卸载这五个阶段顺序是确定的，类的加载过程这些阶段必须按这个顺序开始（注意这里强调的开始的顺序，进行和完成可能是交叉混合着的）。由于 Java 支持动态绑定，在动态绑定时解析阶段会在初始化之后执行。</p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>上面讲到类的分为七个阶段，那么什么情况下会开始类的加载呢？</p><p>思考这个问题我们可以从两个维度出发，一个是 JVM 规范维度，一个是从虚拟机运行的维度；</p><span id="more"></span><h3 id="JVM-规范维度"><a href="#JVM-规范维度" class="headerlink" title="JVM 规范维度"></a>JVM 规范维度</h3><p> JVM 规范没有强制约束类的加载时机，但 Java 虚拟机严格规定了有且只有5种情况必须立即对类进行”初始化”，执行初始化自然必须先执行前面的步骤。</p><ul><li>遇到 new、getstatic、putstatic、或 invokestatic 这4条字节码指令时，如果类没有初始化，则需要先触发其初始化。其对应的场景分别为：<strong>使用 new 关键字初始化实例对象</strong>的时候、<strong>读取或设置一个类的静态字段</strong>（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候和<strong>调用一个类的静态方法</strong>的时候；</li><li>使用 java.lang.reflect 包的方法对类进行<strong>反射调用</strong>的时候，如果类没有进行初始化，则需要先触发其初始化；</li><li>当初始化一个类的时候，如果发现其<strong>父类没有初始化</strong>，则需要先触发其父类的初始化；</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法那个类），虚拟机会先<strong>初始化这个主类</strong>；</li><li>当使用 JDK1.7 开始的<strong>动态语言支持</strong>时，如果 􏱏􏰑􏰣􏲝java.lang.invoke.MethodHandle􏲟􏲡􏰿􏱆 实例最后的解析结果为 􏰏􏰲􏱨􏰐􏰑REF_getStatic、􏱦REF_putStatic、􏱦REF_invokeStatic 的方法句柄􏰏􏲶􏵁􏸁􏸂􏰛􏱢􏴪􏱑􏲝􏲶􏵁􏸁􏸂 􏳨􏱣􏲏􏰏􏰇􏴣􏳝􏱔􏱊􏱾􏱩􏱪􏱚􏰛􏴋􏱂􏱃􏳔􏴰􏰡，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><h3 id="虚拟机运行维度"><a href="#虚拟机运行维度" class="headerlink" title="虚拟机运行维度"></a>虚拟机运行维度</h3><p>从虚拟机运行的维度来说，有两种时机会触发类加载：</p><ul><li>预加载</li><li>运行时加载</li></ul><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p>虚拟机启动时加载，加载的是<code>JAVA_HOME/lib/</code>下的<code>rt.jar</code>下的<code>.class</code>文件，这个jar包里面的内容是程序运行时非常常 常用到的，像<code>java.lang.*</code>、<code>java.util. java.io. </code>等等，因此随着虚拟机一起加载。</p><p>要证明这一点很简单，写一个空的<code>main</code>函数，设置虚拟机参数为<code>-XX:+TraceClassLoading</code>来获取类加载信息，运行一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Opened /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Object from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.io.Serializable from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Comparable from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.CharSequence from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="运行时加载"><a href="#运行时加载" class="headerlink" title="运行时加载"></a>运行时加载</h4><p>虚拟机在用到一个.class文件的时候，会先去内存中查看一下这个.class文件有没有被加载，如果没有就会按照类的全限定名来加载这个类。</p><h2 id="详解类加载过程"><a href="#详解类加载过程" class="headerlink" title="详解类加载过程"></a>详解类加载过程</h2><h3 id="加载（重要）"><a href="#加载（重要）" class="headerlink" title="加载（重要）"></a>加载（重要）</h3><p>加载阶段主要做了三件事：</p><ul><li>获取 .class 文件的二进制流；</li><li>将类信息、静态变量、字节码、常量这些 .class 文件中的内容放入方法区中；</li><li>在内存中生成一个代表这个.class文件的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机比较特殊，这个Class对象是放在方法区中的。</li></ul><p>虚拟机规范对这三点的要求并不具体，因此虚拟机实现与具体应用的灵活度都是相当大的。</p><p>这种灵活度对于开发者来说主要体现在第一步，由于虚拟机规范并没有规定二进制字节流的来源，开发者可以从以下几个渠道获取：</p><ul><li>从zip包中获取，这就是以后jar、ear、war格式的基础 </li><li>从网络中获取，典型应用就是Applet </li><li>运行时计算生成，典型应用就是动态代理技术 </li><li>由其他文件生成，典型应用就是JSP，即由JSP生成对应的.class文件 </li><li>从数据库中读取，这种场景比较少见</li></ul><h3 id="链接（理解）"><a href="#链接（理解）" class="headerlink" title="链接（理解）"></a>链接（理解）</h3><p>链接分为三个步骤：验证、准备和解析</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证阶段主要是为了确保 .class 文件的字节流中包含的信息符合当前虚拟机要求，并且不会危害虚拟机自身的安全。</p><p>正如前面所说，二进制字节流可能有很多种来源，虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节 流而导致系统崩溃，所以<strong>验证是虚拟机对自身保护的一项重要工作</strong>。</p><p>验证阶段大致会完成以下四个阶段的检验动作：</p><ul><li>文件格式验证</li><li>元数据验证  </li><li>字节码验证</li><li>符号引用验证</li></ul><p>验证阶段与加载阶段是交叉进行的，加载阶段还没有结束验证阶段就已经开始了。</p><p>这个阶段也是最耗费时间的，如果我们所运行的全部代码（包括自己编写的及第三方依赖包中的代码）都已经被反复使用和验证过，那么可以考虑使用 <code>􏱏􏰑􏳨􏱉􏱊􏰏􏶶􏲹􏰋􏰌􏳹􏳟􏳠􏲰􏷠􏰍􏲢􏰏􏵀􏰁􏸗􏲶􏳟􏰹􏰏􏰋 􏰌􏳺􏱁􏲿􏷼􏱯􏵂􏳆􏱌􏱍􏱋􏱥􏳻􏱾􏰛􏱵􏱙􏰸􏲟􏹵􏳾􏳿􏱳􏱭􏱮􏶖􏶗􏱌􏱍-Xverify􏳙none􏵑􏱠􏴦􏴲 􏹯􏰪􏲹􏲺􏰏􏰇􏱥􏳻􏹶􏹵􏰛􏱮􏹷􏶅􏰄􏰅􏰆􏰇􏰈􏰉􏰏􏱶</code>参数来关闭大部分类验证措施，以缩短虚拟机类加载时间。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置其<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中分配 。</p><p>这里的<strong>类变量</strong>是指不被 final 修饰的 static 变量，这里设置的<strong>初始值</strong>指的是赋零值。</p><p>各个数据类型对应的零值如下：</p><table><thead><tr><th align="center">数据类型</th><th align="center">零值</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">0</td></tr><tr><td align="center">long</td><td align="center">0L</td></tr><tr><td align="center">short</td><td align="center">(short)0</td></tr><tr><td align="center">chart</td><td align="center">‘\u0000’</td></tr><tr><td align="center">byte</td><td align="center">(byte)0</td></tr><tr><td align="center">boolean</td><td align="center">false</td></tr><tr><td align="center">float</td><td align="center">0.0f</td></tr><tr><td align="center">double</td><td align="center">0.0d</td></tr><tr><td align="center">reference</td><td align="center">null</td></tr></tbody></table><p>这里需要注意一下，类变量由于在这个阶段会有一个初始值，所有代码里可以不指定初始值直接使用，但其他变量不行，使用前必须有初值，否则会编译出错。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>这里就需要了解符号引用和直接引用的概念：</p><h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><p>符号引用是<strong>以一组符号来描述所引用的目标</strong>，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。</p><p>下面以简单的代码来理解符号引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zephyr.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String serial;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>javap -verbose SymbolClass</code>反编译一下这个类，我们主要看看常量池部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#26         // com/zephyr/demo/SymbolClass.count:I</span><br><span class="line">   #3 = Class              #27            // com/zephyr/demo/SymbolClass</span><br><span class="line">   #4 = Class              #28            // java/lang/Object</span><br><span class="line">   #5 = Utf8               serial</span><br><span class="line">   #6 = Utf8               Ljava/lang/String;</span><br><span class="line">   #7 = Utf8               count</span><br><span class="line">   #8 = Utf8               I</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Lcom/zephyr/demo/SymbolClass;</span><br><span class="line">  #16 = Utf8               calculate</span><br><span class="line">  #17 = Utf8               getCount</span><br><span class="line">  #18 = Utf8               ()I</span><br><span class="line">  #19 = Utf8               main</span><br><span class="line">  #20 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #21 = Utf8               args</span><br><span class="line">  #22 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               SymbolClass.java</span><br><span class="line">  #25 = NameAndType        #9:#10         // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 = NameAndType        #7:#8          // count:I</span><br><span class="line">  #27 = Utf8               com/zephyr/demo/SymbolClass</span><br><span class="line">  #28 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><p>上面带<code>Utf8</code>的那一行就是符号引用，每行最前面的就是符号，后面就是引用的值。对于变量来说都会有两行成对出现，比如#7 是 count，#8就是 count 的类型 Integer(常量池里简写为 I )。方法如果有返回值，方法和返回值也会成对出现，比如 #17 和 #18，分别代表的方法和返回值类型。</p><p>简单理解符号引用就是对于类、变量、方法的描述。􏵱􏵲􏷞􏱍􏱮􏰣􏲻􏵱􏵲􏴦􏰺􏰭􏳨􏷞􏱍􏰏􏲽􏷯􏰛􏵱􏵲􏱭 并且􏱮􏰜􏸛􏱐􏱫􏰠􏰏􏰙􏱽􏴽􏰛􏴫􏱃􏱌􏱍􏱶􏱈􏳰􏺂􏲯􏰔􏲨􏵰􏱄􏲽􏷯􏴬􏱭符号引用和虚拟机的内存布局是没有关系的，引用的目标未必已经加载到内存中了。</p><h5 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h5><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p><p>直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。</p><h5 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h5><p>Java 本身是一个静态语言，但后面又加入了动态加载特性，因此我们理解解析阶段需要从这两方面来考虑。</p><p>如果不涉及动态加载，那么一个符号的解析结果是可以缓存的，这样可以避免多次解析同一个符号，因为第一次解析成功后面多次解析也必然成功，第一次解析异常后面重新解析也会是同样的结果。</p><p>如果使用了动态加载，前面使用动态加载解析过的符号后面重新解析结果可能会不同。使用动态加载时解析过程发生在在程序执行到这条指令的时候，这就是为什么前面讲的动态加载时解析会在初始化后执行。</p><p>整个解析阶段主要做了下面几个工作：</p><ul><li>类或接口的解析</li><li>类方法解析</li><li>接口方法解析</li><li>字段解析</li></ul><h3 id="初始化（重要）"><a href="#初始化（重要）" class="headerlink" title="初始化（重要）"></a>初始化（重要）</h3><p>初始化是整个类加载过程的最后一个阶段。整个类加载的五个阶段只有加载和初始化是开发者可以参与的，因此初始化阶段也是需要重点关注的阶段。</p><p>初始化阶段简单来说就是执行类的构造器方法（<code>&lt;clinit&gt;()</code> ），要注意的是这里的构造器方法<code>&lt;clinit&gt;()</code>并不是开发者写的，而是<strong>编译器自动生成的</strong>。</p><h4 id="代码顺序的影响"><a href="#代码顺序的影响" class="headerlink" title="代码顺序的影响"></a>代码顺序的影响</h4><p>编译器编译的时候会按代码顺序进行收集，声明在静态代码块（static {} 块）之后的静态变量，只能在静态代码块里赋值，不能访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClinit</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">i = <span class="number">0</span>; <span class="comment">// 可以给变量赋值</span></span><br><span class="line">System.out.print(i); <span class="comment">// 在这里访问编译器会提示“非法向前引用” </span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="父类与子类-lt-clinit-gt-方法执行顺序"><a href="#父类与子类-lt-clinit-gt-方法执行顺序" class="headerlink" title="父类与子类&lt;clinit&gt;()方法执行顺序"></a>父类与子类<code>&lt;clinit&gt;()</code>方法执行顺序</h4><p>Java 虚拟机会保证父类的<code>&lt;clinit&gt;()</code>方法执行完成后才执行子类的<code>&lt;clinit&gt;()</code>方法，这也就意味着<strong>父类的静态代码块一定会先于子类执行</strong>的。</p><p>这里需要注意的是，如果父类的静态代码块有耗时操作，子类可能会被阻塞迟迟加载不了。</p><h4 id="编译器生成-lt-clinit-gt-方法的条件"><a href="#编译器生成-lt-clinit-gt-方法的条件" class="headerlink" title="编译器生成&lt;clinit&gt;()方法的条件"></a>编译器生成<code>&lt;clinit&gt;()</code>方法的条件</h4><p>编译器生成<code>&lt;clinit&gt;()</code>方法的前提是有变量赋值操作或者有静态代码块需要执行。接口虽然没有静态代码块但是有变量赋值操作，所以接口会生成<code>&lt;clinit&gt;()</code>方法。</p><p><strong>注意：</strong>接口或者接口的实现类在执行<code>&lt;clinit&gt;()</code>方法之前不一定会去执行父类的<code>&lt;clinit&gt;()</code>方法，仅当父类或者被实现的接口变量被使用才会调用这个方法。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;类从被加载到虚拟机开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。整个过程如下图所示：&lt;/p&gt;
&lt;img src=&quot;https://i.loli.net/2021/08/02/265OIqCLtMSwJkY.png&quot; alt=&quot;类加载的生命周期.png&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;加载、验证、准备、初始化和卸载这五个阶段顺序是确定的，类的加载过程这些阶段必须按这个顺序开始（注意这里强调的开始的顺序，进行和完成可能是交叉混合着的）。由于 Java 支持动态绑定，在动态绑定时解析阶段会在初始化之后执行。&lt;/p&gt;
&lt;h2 id=&quot;类加载时机&quot;&gt;&lt;a href=&quot;#类加载时机&quot; class=&quot;headerlink&quot; title=&quot;类加载时机&quot;&gt;&lt;/a&gt;类加载时机&lt;/h2&gt;&lt;p&gt;上面讲到类的分为七个阶段，那么什么情况下会开始类的加载呢？&lt;/p&gt;
&lt;p&gt;思考这个问题我们可以从两个维度出发，一个是 JVM 规范维度，一个是从虚拟机运行的维度；&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://anye3210.github.io/tags/Java/"/>
    
    <category term="类加载" scheme="http://anye3210.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
    <category term="符号引用" scheme="http://anye3210.github.io/tags/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/"/>
    
    <category term="初始化" scheme="http://anye3210.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JMM - Java 内存模型</title>
    <link href="http://anye3210.github.io/2021/07/31/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://anye3210.github.io/2021/07/31/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-07-31T14:57:14.000Z</published>
    <updated>2021-08-22T07:15:54.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JMM定义"><a href="#JMM定义" class="headerlink" title="JMM定义"></a>JMM定义</h2><p>JMM 即 Java Memory Model，也叫 Java 内存模型。JMM 就是一种规范，它定义了什么情况开发者不需要去感知计算机的各种重排序，什么情况需要开发者去干涉重排序，以保证程序的执行结果可预测。</p><h2 id="JMM的由来"><a href="#JMM的由来" class="headerlink" title="JMM的由来"></a>JMM的由来</h2><p>计算机这么多年来整体运行速度不断地提升，除了像CPU时钟频率、内存读写速度等硬件性能不断提升之外，还要归功于计算机科学家对于计算机对于各种指令处理效率的不断优化，包括超标量流水线技术，动态指令调度，猜测执行，多级缓存技术等。在这其中，允许重排序对于计算机运行效率的提升产生了重要的作用，但同时也带来了一些问题。计算机只能确保单线程情况下重排序对于运行结果没有影响，对于多线程就无能为力了。这个时候就需要一个规范来保证开发者既能享受重排序带来的性能的提升又能让复杂情况下的运行结果可控，JMM 就是这样一个规范。JMM 规定了 JVM 必须遵循的一组最小保证，这组保证规定了对变量的操作何时对其他线程可见。换句话说，JMM 对内存可见性作出了一些承诺，在承诺之外，开发者需要自己去处理内存可见性问题。</p><span id="more"></span><h2 id="内存可见性问题"><a href="#内存可见性问题" class="headerlink" title="内存可见性问题"></a>内存可见性问题</h2><p>上面提到了内存可见性问题，那么，什么是内存可见性问题。</p><p>内存可见性问题的核心是 CPU 的缓存与主内存不一致。</p><p>那么，这里就涉及到计算机原理的部分知识，下图是 X86 架构下 CPU 缓存的布局：</p><img src="https://img-blog.csdnimg.cn/5057e1fd41aa4749b0f29a4d2b2d44e3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FueWUzMjEwMA==,size_8,color_FFFFFF,t_70" alt="CPU架构图" style="zoom:50%;" /><p>从图中可以看出 CPU 有多级缓存，每个核心的一二级缓存数据都是该 CPU 核心私有的，由于有缓存一致性协议（例如 MESI ）的存在，各个核心的缓存之间不会存在不同步的问题。</p><p>这里简单讲一下缓存一致性协议 MESI，当各个 CPU 核心都缓存了一个共享变量时，有任何一个核心对它作出了修改都会让其他核心内对应变量的缓存单元失败（这里失效的是整个 CacheLine，不仅仅是变量所占用的区域）并且把修改值同步到主内存。其他核心如果后续要操作这个变量，必须从主内存读，这样就可以保证各个缓存的一致性。</p><p>但引入缓存一致性协议会有很大的性能损耗，为了解决这个问题，又进行了各种优化，这其中就有在计算单元和一级缓存之间引入 StoreBuffer 和 LoadBuffer ，如下图所示：</p><img src="https://img-blog.csdnimg.cn/ba91dcc30047411999c2c10c747f6c2b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FueWUzMjEwMA==,size_8,color_FFFFFF,t_70" alt="加入各种Buffer的CPU架构图组" style="zoom:50%;" /><p>StoreBuffer 和 LoadBuffer 的引入，大大提升了计算机性能，但同时也带来了一些问题：各级缓存之间数据是一致的，但 StoreBuffer 和 LoadBuffer  一级缓存之间的数据却是异步的，这里就会存在一致性问题。</p><p>当一个缓存中的数据被修改后，会存到 StoreBuffer 中，而 StoreBuffer 不会立即把修改后的数据同步到主内存，这时其他核心在主内存中读取到就是旧数据，也就是说一个数据在一个核心的写操作会出现对其他核心不可见的情况，这就是内存可见性问题。</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>上面讲的内存可见性问题其本质就是 CPU 内存重排序，它是重排序的一种。这里讲一下什么是重排序。</p><p>重排序分为三种：编译重排序、CPU 指令重排序和 CPU 内存重排序。</p><ul><li><strong>编译器重排序：</strong>对于没有先后依赖的语句，编译器可以重新调整语句的顺序；</li><li><strong>CPU 指令重排序：</strong>对于没有先后依赖的指令并行执行；</li><li><strong>CPU 内存重排序：</strong>CPU 有自己的缓存，指令的执行顺序与写入主内存的顺序不一定一致。</li></ul><p>编译器重排序对开发者来说是无感知的，我们主要关注的是 CPU 指令重排序和 CPU 内存重排序，这两者都会对运行结果产生影响。</p><p>举个例子：假如有 X，Y，a，b 四个共享变量，我们在两个不同的线程分别执行下面的代码：</p><p>线程一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = 1;</span><br><span class="line">a = Y;</span><br></pre></td></tr></table></figure><p>线程二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y = 1;</span><br><span class="line">b = X;</span><br></pre></td></tr></table></figure><p>这两个线程的执行顺序是不一定的，有可能是顺序执行，也可能是交叉执行，最终结果可能是：</p><ul><li>a = 0, b = 1 (线程一执行 -&gt; 线程二执行)</li><li>b = 0, a = 1 (线程二执行 -&gt; 线程一执行)</li><li>a = 1, b = 1 (两个线程交叉执行)</li></ul><p>上面就是 CPU 指令重排序产生的影响。但实际情况会有第四种结果：</p><ul><li>a = 0, b = 0 （内存重排序）</li></ul><p>导致这个结果的原因是两个线程全部或其中一个的写入操作没有同步到主内存中，因此给 a 或 b 赋值时读取到的还是旧值 0，这就是内存可见性问题。</p><p>CPU 指令重排序问题我们可以通过锁、CAS 等同步机制来解决，编译器重排序和 CPU 内存重排序都可以通过引入内存屏障来解决，这里主要关注内存屏障在 CPU 重排序的应用。</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障是一个比较底层的概念，它能对重排序作一定的限制，不同的内存屏障对重排序限制不同，一般都是组合使用的。作为 Java 开发者我们知道使用 volatile 关键字修饰的变量不会存在内存可见性问题，它的原理其实就是在对变量的操作前后都加入了两个不同的内存屏障，以保证所有的读写组合都不会发生内存可见性问题。</p><p>可以把内存屏障分为四类：</p><ul><li>LoadLoad：禁止读和读的重排序</li><li>StoreStore：禁止写和写的重排序</li><li>LoadStore：禁止读和写的重排序</li><li>StoreLoad：禁止写和读的重排序</li></ul><p>JDK 8 开始，Unsafe 类提供了三个内存屏障方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class Unsafe &#123; </span><br><span class="line">// ...</span><br><span class="line">public native void loadFence(); </span><br><span class="line">public native void storeFence(); </span><br><span class="line">public native void fullFence(); </span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个方法对应的内存屏障如下：</p><ul><li>loadFence = LoadLoad + LoadStore</li><li>storeFence = StoreStore + LoadStore</li><li> fullFence = loadFence + storeFence + StoreLoad</li></ul><p>我们平常在开发中一般不会去主动使用内存屏障，而内存屏障所实现的效果可以用 happen-before 来描述。</p><h2 id="happen-before"><a href="#happen-before" class="headerlink" title="happen-before"></a>happen-before</h2><p>首先来说说什么是 happen-before：它用来描述来个操作之间的内存可见性，如果 A 操作 happen-before 于 B 操作，那么 A 操作的执行结果必须是对 B 操作可见的，这里隐含了一个条件，只有在 A 操作的执行实际发生在 B 操作之前，这个可见性保证才会有效，happen-before 并不会去改变 A 和 B 的执行顺序。</p><p>JMM 规范借助 happen-before 可以更好的描述出来。</p><p>happen-before 有以下四个基本规则：</p><ul><li>单线程中的每个操作，happen-before于该线程中任意后续操作。</li><li>对volatile变量的写，happen-before于后续对这个变量的读。</li><li>对synchronized的解锁，happen-before于后续对这个锁的加锁。</li><li>对final变量的写，happen-before于final域对象的读，happen-before于后续对final变量的读。</li></ul><p>除了以上四个基础规则之外，happen-before 还具有传递性。传递性是指当 A happen-before 于 B，B happen-before 于 C ，那么操作 A 的结果一定对操作 C 可见。</p><p>这四个基本规则再加上 happen-before 的传递性，就构成了 JMM 对开发者的整个承诺。在这个承诺之后的部分，开发者就需要小心处理内存可见性问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JMM定义&quot;&gt;&lt;a href=&quot;#JMM定义&quot; class=&quot;headerlink&quot; title=&quot;JMM定义&quot;&gt;&lt;/a&gt;JMM定义&lt;/h2&gt;&lt;p&gt;JMM 即 Java Memory Model，也叫 Java 内存模型。JMM 就是一种规范，它定义了什么情况开发者不需要去感知计算机的各种重排序，什么情况需要开发者去干涉重排序，以保证程序的执行结果可预测。&lt;/p&gt;
&lt;h2 id=&quot;JMM的由来&quot;&gt;&lt;a href=&quot;#JMM的由来&quot; class=&quot;headerlink&quot; title=&quot;JMM的由来&quot;&gt;&lt;/a&gt;JMM的由来&lt;/h2&gt;&lt;p&gt;计算机这么多年来整体运行速度不断地提升，除了像CPU时钟频率、内存读写速度等硬件性能不断提升之外，还要归功于计算机科学家对于计算机对于各种指令处理效率的不断优化，包括超标量流水线技术，动态指令调度，猜测执行，多级缓存技术等。在这其中，允许重排序对于计算机运行效率的提升产生了重要的作用，但同时也带来了一些问题。计算机只能确保单线程情况下重排序对于运行结果没有影响，对于多线程就无能为力了。这个时候就需要一个规范来保证开发者既能享受重排序带来的性能的提升又能让复杂情况下的运行结果可控，JMM 就是这样一个规范。JMM 规定了 JVM 必须遵循的一组最小保证，这组保证规定了对变量的操作何时对其他线程可见。换句话说，JMM 对内存可见性作出了一些承诺，在承诺之外，开发者需要自己去处理内存可见性问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://anye3210.github.io/tags/Java/"/>
    
    <category term="内存模型" scheme="http://anye3210.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="happen-before" scheme="http://anye3210.github.io/tags/happen-before/"/>
    
    <category term="内存可见性" scheme="http://anye3210.github.io/tags/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
    <category term="重排序" scheme="http://anye3210.github.io/tags/%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【React Native进阶】React Native Reanimated的使用</title>
    <link href="http://anye3210.github.io/2020/12/15/%E3%80%90React-Native%E8%BF%9B%E9%98%B6%E3%80%91React-Native-Reanimated%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://anye3210.github.io/2020/12/15/%E3%80%90React-Native%E8%BF%9B%E9%98%B6%E3%80%91React-Native-Reanimated%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-12-15T15:32:58.000Z</published>
    <updated>2021-08-22T07:17:09.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://anye3210.github.io/2020/12/14/%E3%80%90React-Native%E8%BF%9B%E9%98%B6%E3%80%91react-native-gesture-handler%E7%9A%84%E4%BD%BF%E7%94%A8/">上一篇文章</a>讲解了React Native性能优化的总体思路，并进一步讲解了React Native Gesture Handler的使用。本文讲解另外一个库<a href="https://docs.swmansion.com/react-native-reanimated/docs/about">React Native Reanimated</a>，这个库旨在解决React Native在动画方面的性能问题，让我们能够创建运行在UI线程上的顺滑动画和流畅交互。</p><h2 id="Reanimated实现动机"><a href="#Reanimated实现动机" class="headerlink" title="Reanimated实现动机"></a>Reanimated实现动机</h2><p>上一篇文章讲了React Native中业务逻辑和计算都是在JavaScript线程中，渲染是在UI线程中，两个线程是通信又是异步的，因此渲染并不是实时的，至少会有1桢的延迟，在动画方面也是同样的。</p><p>Reanimated将JavaScript线程上的动画和事件处理逻辑转移到了UI线程。它通过定义Reanimated worklet(可以被移动到一个单独的JavaScript 虚拟机并在UI线程上同步运行的一小段JavaScript代码）来实现。这种机制让我们的触摸事件可以立即被响应并在同一桢上更新UI，不必再担心JavaScript加载和同步这些问题。</p><p><strong>注意：</strong>本文讲解的是当前最新的版本2.0.0-alpha.9，它与版本1有较大的差异。</p><span id="more"></span><h2 id="当前版本的问题和限制"><a href="#当前版本的问题和限制" class="headerlink" title="当前版本的问题和限制"></a>当前版本的问题和限制</h2><p>Reanimated 第二个版本当前还处于早期。由于制作这个库的团队想尽早向公众分享它，这个库还存在一些瑕疵和限制，他们计划很快解决。但有一些限制是来自Reanimated 2所依赖的 React Native 的TurboModules 架构的成熟。这个版本计划解决的一些问题可能需要全面支持TurboModules，而TurboModules尚未向公众开放。</p><p>下面就是这个版本的一些问题：</p><ul><li>安装步骤比较复杂。这源于TurboModules尚未在React Native应用程序模板中推出；</li><li>目前只在Android上支持Hermes JS VM;</li><li>由于这个库使用了JSI进行同步本机方法访问，这导致远程调试就没办法使用了。可以使用Flipper调试JS代码，但不支持将调试器连接到UI线程上运行的JS上下文；</li><li>库在开发模式下重新加载JS捆绑包或热加载时偶尔会崩溃。</li><li>在 worklets 中抛出的JavaScript异常有时会产生非描述性错误，并可能导致应用程序崩溃;</li><li>从React Native传递给 worklets 的对象在 JavaScript 中没有正解的 prototype。因此，此类对象不可枚举，即不能使用“for in”构造、扩展运算符（三个点）或Object.assign等函数。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Reanimated 2主要使用Turbo Modules架构并在C++中构建，该架构尚未完全部署在React Native（特别是在Android上）。因此，安装新的Reanimated除了向package.json添加依赖项外，还需要额外的步骤。</p><p>由于上述原因，React Native的最低支持版本是v0.62。在继续安装之前，请确保我们的项目正在运行在受支持的React Native版本上。</p><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>首先在项目中安装<code>react-native-reanimated</code> alpha 依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; yarn add react-native-reanimated@alpha</span><br></pre></td></tr></table></figure><h2 id="配置-Android"><a href="#配置-Android" class="headerlink" title="配置 Android"></a>配置 Android</h2><p>修改<code>android/app/build.gradle</code>，打开 Hermes 引擎</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project.ext.react = [</span><br><span class="line">  enableHermes: true  // &lt;- here | clean and rebuild if changing</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在<code>MainApplication.java</code>中插入 Reanimated </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import com.facebook.react.bridge.JSIModulePackage; // &lt;- add</span><br><span class="line">import com.swmansion.reanimated.ReanimatedJSIModulePackage; // &lt;- add</span><br><span class="line">...</span><br><span class="line">private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String getJSMainModuleName() &#123;</span><br><span class="line">      return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected JSIModulePackage getJSIModulePackage() &#123;</span><br><span class="line">      return new ReanimatedJSIModulePackage(); // &lt;- add</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="配置iOS"><a href="#配置iOS" class="headerlink" title="配置iOS"></a>配置iOS</h2><p>在 iOS 上的安装是自动的，不需要额外配置。</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="Worklets"><a href="#Worklets" class="headerlink" title="Worklets"></a>Worklets</h2><p>worklets 的最终目标是定义一小段运行在 UI 线程用来更新视图属性和响应事件的 JavaScript 代码。正常这种结构用 JavaScript 来实现就会是一个简单的方法。在这个版本中有一个次级的运行在 UI 线程的 JS 上下文，JavaScript 代码能够在这个上下文里面运行。实现这个 worklets 方法只需要在方法内部第一行加上”worklet”命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function someWorklet(greeting) &#123;</span><br><span class="line">  &#x27;worklet&#x27;;</span><br><span class="line">  console.log(&quot;Hey I&#x27;m running on the UI thread&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在使用这些方法的时候还可以传递参数。每个 worklet 方法如果你直接在代码里面调用就会运行在 React Native 的主线程上，如果使用<code>runOnUI</code>方法调用就可以运行在 UI 线程上。注意这种调用在使用者的视角上看是异步的（即调用与运行不在同一个线程上）。当你传递了参数，那这个参数会被复制到 UI 线程的 JS 上下文中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function someWorklet(greeting) &#123;</span><br><span class="line">  &#x27;worklet&#x27;;</span><br><span class="line">  console.log(greeting, &#x27;From the UI thread&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function onPress() &#123;</span><br><span class="line">  runOnUI(someWorklet)(&#x27;Howdy&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你在 worklet 方法外部定义了一个变量并在方法里使用了它，那么这个变量同样会被复制进来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const width = 135.5;</span><br><span class="line"></span><br><span class="line">function otherWorklet() &#123;</span><br><span class="line">  &#x27;worklet&#x27;;</span><br><span class="line">  console.log(&#x27;Captured width is&#x27;, width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>worklet 也可以从其他的 worklet 方法中获取参数，当这些方法被调用时，它们是在 UI 线程同步运行的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function returningWorklet() &#123;</span><br><span class="line">  &#x27;worklet&#x27;;</span><br><span class="line">  return &quot;I&#x27;m back&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function someWorklet() &#123;</span><br><span class="line">  &#x27;worklet&#x27;;</span><br><span class="line">  let what = returningWorklet();</span><br><span class="line">  console.log(&#x27;On the UI thread, other worklet says&#x27;, what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特性也同样适用于普通方法。需要注意的是，<code>console.log</code>只在 React Native 上下文中定义了的，在 UI 线程是没有这个方法的，因此上面的这些例子中<code>console.log</code>都是运行在 React Native 主线程上的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callback(text) &#123;</span><br><span class="line">  console.log(&#x27;Running on the RN thread&#x27;, text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function someWorklet() &#123;</span><br><span class="line">  &#x27;worklet&#x27;;</span><br><span class="line">  console.log(&quot;I&#x27;m on UI but can call methods from the RN thread&quot;);</span><br><span class="line">  callback(&#x27;can pass arguments too&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用勾子函数（hooks）"><a href="#使用勾子函数（hooks）" class="headerlink" title="使用勾子函数（hooks）"></a>使用勾子函数（hooks）</h3><p>在平常使用时，我们很少自己去去写”worklet”命令去定义 worklet 方法，一般情况都是直接使用这个库中已经定义好的勾子函数，比如：<code>useAnimatedStyle</code>, <code>useDerivedValue</code>, <code>useAnimatedGestureHandler</code>等。当我们使用这些勾子函数时，系统会自动识别到这是一个 worklet 并运行到 UI 线程上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const style = useAnimatedStyle(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;Running on the UI thread&quot;);</span><br><span class="line">  return &#123;</span><br><span class="line">    opacity: 0.5</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Shared-Values"><a href="#Shared-Values" class="headerlink" title="Shared Values"></a>Shared Values</h2><p>Shared Values 是 Reanimated 2.0 最基础的理念之一。它有点类似于 React Native 内置的 <a href="https://reactnative.dev/docs/animated">Animated.API</a>。它们都服务于相似的目标：携带动画所需要的数据，提供响应式和驱动式的动画。下面几个小节会详细介绍 Shared Values 的这些关键角色。后面也会有表格详细对照 Shared Values 与 Animated.Value 区别。</p><h3 id="携带数据"><a href="#携带数据" class="headerlink" title="携带数据"></a>携带数据</h3><p>Shared Values 的主要目的是提供共享内存的概念。在前面学习 worklet 时我们了解到 Reanimated 2.0 的动画代码是使用单独的 JS VM 上下文运行在单独的线程中的。Shared Values 就能够对可变数据保持引用以便这些数据能够在不同的线程中被读取和修改。</p><p>Shared Value 对象对这些共享数据提供了引用，这些共享数据可以通过对象的<code>.value</code>属性来获取和修改。记住无论是获取数据还是修改数据，都需要使用<code>.value</code>(最经常看到的错误就是直接使用 Shared Value 来获取和修改数据而不是使用它的<code>.value</code>属性）。</p><p>为了兼顾安全和速度，Reanimated 2.0 在设计的时候会做一些权衡。使用 worklet 在主线程读取和修改的数据能够立即更新渲染到屏幕上。而在 JavaScript 线程上的更新操作不会立刻执行，变成一个更新计划之后再提交到 UI 线程上执行。这种方式类似于 React Native 的状态管理：我们更新了状态，这些状态不会立即被执行，而是在下一个 re-render 的时候执行。</p><p>创建一个 Shared Value 需要使用勾子函数<code>useSharedValue</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const sharedVal = useSharedValue(3.1415)</span><br></pre></td></tr></table></figure><p>这个 Shared Value 构造器勾子函数需要传入一个参数作为初始变量值。这个初始数据可以是对象、数组、数字、字符串或者布尔值。</p><p>更新 Shared Value 需要使用<code>.value</code>赋一个新的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useSharedValue &#125; from &#x27;react-native-reanimated&#x27;;</span><br><span class="line"></span><br><span class="line">function SomeComponent() &#123;</span><br><span class="line">  const sharedVal = useSharedValue(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Button</span><br><span class="line">      onPress=&#123;() =&gt; (sharedVal.value = Math.random())&#125;</span><br><span class="line">      title=&quot;Randomize&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子我们是在 JavaScript 线程上更新的数据，这个更新是异步的。使用<code>worklet</code>能够让这个更新变成同步的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Animated, &#123; useSharedValue, useAnimatedScrollHandler &#125; from &#x27;react-native-reanimated&#x27;;</span><br><span class="line"></span><br><span class="line">function SomeComponent(&#123; children &#125;) &#123;</span><br><span class="line"></span><br><span class="line">  const scrollOffset = useSharedValue(0);</span><br><span class="line"></span><br><span class="line">  const scrollHandler = useAnimatedScrollHandler(&#123;</span><br><span class="line">    onScroll: event =&gt; &#123;</span><br><span class="line">      scrollOffset.value = event.contentOffset.y;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Animated.ScrollView onScroll=&#123;scrollHandler&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/Animated.ScrollView&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 scroll handler 就是一个 worklet，它的滚动事件是在 UI 线程上运行的。因此它里面的更新也是同步的。</p><h3 id="Shared-Values-的响应性"><a href="#Shared-Values-的响应性" class="headerlink" title="Shared Values 的响应性"></a>Shared Values 的响应性</h3><p>Shared Values 第二个非常重要的特性就是为 Reanimated 提供了响应性的理念。基于这个特性，Shared Value 可以驱动相应的代码在 UI 线程执行，也可以执行开始动画、更新视图等操作。</p><p>当前两种方法创建反应式的 worklet，分别是<code>useAnimatedStyle</code>和<code>useDerivedValue</code>。当这样的勾子函数捕获了一个 Shared Value，每当 Shared Value的数据被更新时，这些勾子函数都会重新运行。Reanimated 引擎会创建一个 Shared Value 与 worklet 对应关系的表以保证我们只执行需要更新的代码以及执行的顺序。比如，当我们有一个 Shared Value <code>x</code>、一个基于<code>x</code>值变化的变量<code>y</code>和同时使用<code>x</code>与<code>y</code>的 animated style，那么当<code>x</code>的值更新时，只会重新运行起源于<code>x</code>的 worklet。在这个例子中，由于 animated style 会基于<code>y</code>的值，<code>y</code>的值会优先更新以保证 animated style 的更新。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Animated, &#123; useSharedValue, useAnimatedStyle &#125; from &#x27;react-native-reanimated&#x27;;</span><br><span class="line"></span><br><span class="line">function Box() &#123;</span><br><span class="line">  const offset = useSharedValue(0);</span><br><span class="line"></span><br><span class="line">  const animatedStyles = useAnimatedStyle(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      transform: [&#123; translateX: offset.value * 255 &#125;],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Animated.View style=&#123;[styles.box, animatedStyles]&#125; /&gt;</span><br><span class="line">      &lt;Button onPress=&#123;() =&gt; (offset.value = Math.random())&#125; title=&quot;Move&quot; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了 Shared Value <code>offset</code>，并把它使用在了<code>useAnimatedStyle</code>这个 worklet 里。<code>offset</code>的初始值是0，然后我们添加了一个按钮通过<code>Math.random()</code>函数更新<code>offset</code>的值。因此每当我们点击一次按钮，<code>offset</code>的值就会更新为一个<code>0</code>到<code>1</code>区间中的平均数。由于 animated style 的 worklet 是响应式的，在这个例子中它是基于<code>offset</code>的值响应，只有初始化的时候或者<code>offset</code>值更新的时候这个 worklet 才会运行。由于在 worklet 里作了一个 <code>* 255</code>的计算，因此实际的<code>translateX</code>在按钮的点击下在<code>0</code>到<code>255</code>变动。</p><p><img src="https://docs.swmansion.com/react-native-reanimated/docs/shared-values/sv-immediate.gif" alt="图片"></p><h3 id="操作动画"><a href="#操作动画" class="headerlink" title="操作动画"></a>操作动画</h3><p>动画是 Reanimated 2里的重中之重，在这个库中有大量帮助我们运行和自定义动画的实用方法。其中一种动画的方式就是使 Shared Value 的值进行动态变化。它可以通过用 reanimated 库里的方法（例如：<code>withTiming</code>、<code>withSpring</code>）把目标值包装起来来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; withTiming &#125; from &#x27;react-native-reanimated&#x27;;</span><br><span class="line"></span><br><span class="line">someSharedValue.value = withTiming(50);</span><br></pre></td></tr></table></figure><p>在上面的代码中<code>offset</code>的值没有直接被设定成<code>50</code>，而是随着时间推移从当前值渐变到<code>50</code>。当然，这种动画形式可以在 UI 线程上实现也可以在 React Native 主线程上实现。下面是完整的从上面小节例子上修改之后的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Animated, &#123; withSpring &#125; from &#x27;react-native-reanimated&#x27;;</span><br><span class="line"></span><br><span class="line">function Box() &#123;</span><br><span class="line">  const offset = useSharedValue(0);</span><br><span class="line"></span><br><span class="line">  const animatedStyles = useAnimatedStyle(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      transform: [&#123; translateX: offset.value * 255 &#125;],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Animated.View style=&#123;[styles.box, animatedStyles]&#125; /&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        onPress=&#123;() =&gt; &#123;</span><br><span class="line">          offset.value = withSpring(Math.random());</span><br><span class="line">        &#125;&#125;</span><br><span class="line">        title=&quot;Move&quot;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们所做的修改仅仅是将<code>Math.random()</code>包裹在了<code>withSpring</code>方法中。加上这个方法后动画会更平滑：</p><p><img src="https://docs.swmansion.com/react-native-reanimated/docs/shared-values/sv-spring.gif" alt="spring animation"></p><p>关于<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/withTiming/">withTiming</a>、<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/withSpring/">withSpring</a>等方法的更多信息可以参考官方文档的介绍。</p><h4 id="动画进度"><a href="#动画进度" class="headerlink" title="动画进度"></a>动画进度</h4><p>我们可以通过<code>.value</code>来获取基于 Shared Value 的动画的当前状态。当 Shared Value 的<br>过渡动画开始之后，<code>.value</code>的值将会与动画的进度同步。也就是说，当动画开始时的初始值为<code>0</code>而且使用了<code>withTiming(50)</code>方法，完成这个过渡默认是300毫秒，我们可以在动画进行时通过<code>.value</code>来获取到从<code>0</code>到<code>50</code>之间动画的进度。</p><h4 id="中断动画"><a href="#中断动画" class="headerlink" title="中断动画"></a>中断动画</h4><p>由于 Shared Value 保持其动画过渡状态，我们可以使所有的动画都完全中断。这意味着即使 Shared Value 当前正在运行动画，我们也可以对 Shared Value 进行更新，而不必担心这会导致意外和突然的动画故障。在这种情况下，重新赋值会导致之前的动画中断。如果新分配的值是一个数字（或其他任何常量值），则该新值将立即分配给 Shared Value，之前运行的动画将被取消。如果新分配的值也是动画，那么之前运行的动画将顺利过渡到新的动画中。速度等动画参数也会转变，这在基于 spring 的动画中尤为重要。这种行为模式在下面的动图中就可以看出，我们只是更频繁地点击按钮，这样新动画就会在前一个动画仍在运行时启动（与前一个示例相比没有代码更改）。</p><p><img src="https://docs.swmansion.com/react-native-reanimated/docs/shared-values/sv-interruption.gif" alt="quick click"></p><h4 id="取消动画"><a href="#取消动画" class="headerlink" title="取消动画"></a>取消动画</h4><p>我们可以通过使用<code>cancelAnimation</code>方法实现不开始新动画的情况直接取消当前动画：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; cancelAnimation &#125; from &#x27;react-native-reanimated&#x27;</span><br><span class="line"></span><br><span class="line">cancelAnimation(someSharedValue);</span><br></pre></td></tr></table></figure><p>动画可以在 UI 线程被取消，也可以在 React Native 的 JS 线程上被取消。</p><h3 id="Shared-Values-与-Animated-Value-对比"><a href="#Shared-Values-与-Animated-Value-对比" class="headerlink" title="Shared Values 与 Animated.Value 对比"></a>Shared Values 与 Animated.Value 对比</h3><style>table th:first-of-type {    width: 10%;}table th:nth-of-type(2) {    width: 450%;}table th:nth-of-type(3) {    width: 45%;}</style><table><thead><tr><th>特性</th><th>Animated Value</th><th>Shared Value</th></tr></thead><tbody><tr><td>Payload</td><td><div style="width=100pt"/>仅支持数值或字符串类型</td><td>任何原始或嵌套数据结构（如对象、数组、字符串、数字、布尔值）</td></tr><tr><td>连接到视图的属性</td><td>直接把<code>Animated.Value</code>当作属性传递</td><td>Shared Value 不能直接与视图的属性进行锚定。我们应该使用<code>useAnimatedStyle</code>或者<code>useAnimatedProps</code>并在这些方法里面获取到 Shared Value 的值并将计算后的 styles 返回回去</td></tr><tr><td>更新值</td><td>使用<code>value.setValue</code>方法（如果使用了 native driver 值的更新就是异步的）</td><td>通过更新<code>.value</code>属性，如果在 UI 线程进行更新就是同步的，其他线程更新就是异步的</td></tr><tr><td>读取值</td><td>通过<code>value.addListener</code>来注册监听器来动态获取更新的值</td><td>直接通过<code>.value</code>属性就能获取存储在 Shared Value 里的值（UI 线程和 React Native 的 JS 线程都可以）</td></tr><tr><td>运行动画</td><td>使用<code>Animated.spring</code>、<code>Animated.timing</code>或其他方法，将 Animated Value 作为参数，通过 <code>.start()</code>方法启动动画。</td><td>把目标值用动画方法（例如：<code>withTiming</code>）包装起来并更新它的值即可</td></tr><tr><td>停止动画</td><td>通过<code>Animated.timing</code>的返回值获取动画对象的引用，并让它调用<code>stopAnimation()</code>方法</td><td>把 Shared Value 作为参数传递给<code>cancelAnimation</code>即可</td></tr><tr><td>插值</td><td>使用 Animated Value 的<code>interplate()</code>方法</td><td>使用带数字和配置参数的方法<code>interpolated</code>，并从这个方法返回插值。如果你需要让一个 Shared Value 自动跟踪另一个 Shared Value 的插值也可以单独使用<code>useDerivedValue</code></td></tr></tbody></table><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>接下来讲一下如何使用各种辅助方法进一步自定义动画。</p><h3 id="useAnimatedStyle"><a href="#useAnimatedStyle" class="headerlink" title="useAnimatedStyle"></a>useAnimatedStyle</h3><p>除了在给 Shared Value 赋值的时候使用类似<code>withSpring</code>的过渡方法制作动画以外，还可以直接在<code>useAnimatedStyle</code>方法里面使用这些过渡动画方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const animatedStyles = useAnimatedStyle(() =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    transform: [</span><br><span class="line">      &#123;</span><br><span class="line">        translateX: withSpring(offset.value * 255),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码中，我们将<code>offset</code>的值转换后再包裹在<code>withSpring</code>方法中。效果与之前给<code>offset</code>赋值之前就使用<code>withSpring</code>这个方法相同。这种写法的好处是将动画逻辑的代码都写在一起，在其他地方只需要给 Shared Value 赋值即可。经过上面的修改后，按钮部分的代码就可以改成下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button onPress=&#123;() =&gt; (offset.value = Math.random())&#125; title=&quot;Move&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p>Reanimated 目前内置了三个动画辅助方法：<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/withTiming"><code>withTiming</code></a>、<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/withSpring/"><code>withSpring</code></a>和<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/withDecay/"><code>withDecay</code></a>。下面介绍一下前两种方法的常用配置选项。</p><p>这些动画辅助方法都有类似的结构。方法的第一个参数是目标值，第二个参数是配置选项，第三个参数是回调函数。回调函数会在动画完成或动画被中断或取消时运行，函数里有一个布尔值的参数，代表动画是否顺利完成而没有被取消：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">  onPress=&#123;() =&gt; &#123;</span><br><span class="line">    offset.value = withSpring(Math.random(), &#123;&#125;, (finished) =&gt; &#123;</span><br><span class="line">      if (finished) &#123;</span><br><span class="line">        console.log(&quot;ANIMATION ENDED&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(&quot;ANIMATION GOT CANCELLED&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  title=&quot;Move&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h4 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h4><p>配置选项这个参数根据运行的动画不同也存在不同。对于 timing 动画而言，我们可以设置持续时间和 easing 方法（缓动方法）。你可能希望动画先快速加速然后减速，或者缓慢开始，然后在结束时再次加速和减速。我们可以通过 Reanimated 包中的<code>Easing.bezier</code>方法使用贝塞尔曲线来描述这种 easing 。但大多数情况，使用<code>Easing.in</code>、<code>Easing.out</code>或者<code>Easing.inOut</code>分别调整起点、终点或两端的时序曲线就足够了。Timing 动画默认持续时间为300毫秒，默认为平滑进出的曲线(<code>Easing.inOut(Easing.quad)</code>)：</p><p><img src="https://docs.swmansion.com/react-native-reanimated/docs/animations/easeInOutQuad.png" alt="timing"></p><p>下面就是如何自定义 timing 动画的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Easing, withTiming &#125; from &#x27;react-native-reanimated&#x27;;</span><br><span class="line"></span><br><span class="line">offset.value = withTiming(0, &#123;</span><br><span class="line">  duration: 500,</span><br><span class="line">  easing: Easing.out(Easing.exp),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你也可以查看<a href="https://easings.net/">easings.net</a>这个网站来查看不同 timing 动画的 easing 效果。Reanimated 所有的 easing 方法都是在<a href="https://github.com/software-mansion/react-native-reanimated/blob/master/src/reanimated2/Easing.js">Easing.js</a>文件里定义的，如果在使用的有问题可以参考这个文件。</p><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><p>与 Timing 动画不同的是，Spring 动画不将持续时间作为参数。Spring 动画的持续时间由 spring 物理特性、初始速度和行进距离决定。下面我们通过例子来了解如何自定义 spring 动画并将它与默认的 spring 动画设定进行对比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import Animated, &#123;</span><br><span class="line">  withSpring,</span><br><span class="line">  useAnimatedStyle,</span><br><span class="line">  useSharedValue,</span><br><span class="line">&#125; from &#x27;react-native-reanimated&#x27;;</span><br><span class="line"></span><br><span class="line">function Box() &#123;</span><br><span class="line">  const offset = useSharedValue(0);</span><br><span class="line"></span><br><span class="line">  const defaultSpringStyles = useAnimatedStyle(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      transform: [&#123; translateX: withSpring(offset.value * 255) &#125;],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const customSpringStyles = useAnimatedStyle(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      transform: [</span><br><span class="line">        &#123;</span><br><span class="line">          translateX: withSpring(offset.value * 255, &#123;</span><br><span class="line">            damping: 20,</span><br><span class="line">            stiffness: 90,</span><br><span class="line">          &#125;),</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Animated.View style=&#123;[styles.box, defaultSpringStyles]&#125; /&gt;</span><br><span class="line">      &lt;Animated.View style=&#123;[styles.box, customSpringStyles]&#125; /&gt;</span><br><span class="line">      &lt;Button onPress=&#123;() =&gt; (offset.value = Math.random())&#125; title=&quot;Move&quot; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://docs.swmansion.com/react-native-reanimated/docs/animations/twosprings.gif" alt="spring"></p><p>与前面的例子不同，这里使用了<code>useAnimatedStyle</code>函数。这样就可以使用一个 Shared Value 来驱动两个不同的动画效果。</p><h3 id="动画修饰器"><a href="#动画修饰器" class="headerlink" title="动画修饰器"></a>动画修饰器</h3><p>除了自定义配置参数以外，另外一种自定义动画的方法就是使用动画修饰器。目前，Reanimated 有三个修饰器：<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/withDelay/"><code>withDecay</code></a>、<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/withSequence/"><code>withSequence</code></a>和<a href="https://docs.swmansion.com/react-native-reanimated/docs/api/withRepeat/"><code>withRepeat</code></a>。顾名思义，<code>withDelay</code>修饰器让动画在指定的延时之后开始，<code>withSequence</code>修饰器允许传入多个动画作为参数，并让它们依次运行，<code>withRepeat</code>修饰符可以让动画重复执行。</p><p>修饰器通过将一个或多个动画作为参数传入，并返回一个修改后的动画对象。这样就可以让这些动画方法嵌套，或者让这些动画修饰器组成一个修饰链。</p><p>现在让我们来练习一下动画修饰器的使用。下面的例子我们来实现单击按钮触发矩形按钮的摆动效果。首先我们先定义需要渲染的视图和需要用到的 Shared Value。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Animated, &#123; useSharedValue, useAnimatedStyle &#125; from &#x27;react-native-reanimated&#x27;;</span><br><span class="line"></span><br><span class="line">function WobbleExample(props) &#123;</span><br><span class="line">  const rotation = useSharedValue(0);</span><br><span class="line"></span><br><span class="line">  const animatedStyle = useAnimatedStyle(() =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      transform: [&#123; rotateZ: `$&#123;rotation.value&#125;deg` &#125;],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Animated.View style=&#123;[styles.box, animatedStyle]&#125; /&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        title=&quot;wobble&quot;</span><br><span class="line">        onPress=&#123;() =&gt; &#123;</span><br><span class="line">          // will be filled in later</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中我们定义的 Shared Value 将会用来代表视图的旋转。然后，在<code>useAnimatedStyle</code>我们通过添加 “deg” 后缀将变量的单位更改为度。下面在按钮的<code>onPress</code>方法中添加修饰器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rotation.value = withRepeat(withTiming(10), 6, true)</span><br></pre></td></tr></table></figure><p>上面的代码表示视图将从初始角度<code>0</code>到目标角度<code>10</code>之间重复旋转6次，第三个参数设置代表动画运行到终点时是否需要反向回到起点。将第三个参数设置为<code>true</code>将使旋转进行完整三个循环，最终回到原点。当我们点击按钮时，效果如下：</p><p><img src="https://docs.swmansion.com/react-native-reanimated/docs/animations/swing.gif" alt="rotation"></p><p>上面的代码让旋转只在<code>0</code>度和<code>10</code>度之间进行。为了让视图也向左摆，我们可以从角度<code>-10</code>旋转到<code>10</code>度。但如果我们直接把初始值更改为<code>-10</code>，那个矩形一开始就会是斜的。解决这个问题的方法就是使用<code>withSequence</code>，从<code>0</code>度开始，将第一个动画最终值设置为<code>-10</code>度，然后视图从<code>-10</code>度到<code>10</code>度摆动6次，最后再从<code>-10</code>度回到初始位置<code>0</code>度。下面是修改后的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rotation.value = withSequence(</span><br><span class="line">  withTiming(-10, &#123; duration: 50 &#125;),</span><br><span class="line">  withRepeat(withTiming(ANGLE, &#123; duration: 100 &#125;), 6, true),</span><br><span class="line">  withTiming(0, &#123; duration: 50 &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的代码对三个动画设置了不同的持续时长，以保证矩形以相同的速度旋转，下面就是最后的实现效果：</p><p><img src="https://docs.swmansion.com/react-native-reanimated/docs/animations/wobble.gif" alt="sequence animation"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，关于 React Native Reanimated 的使用就已经学习完了，如果想要进一步学习可以查看<a href="https://docs.swmansion.com/react-native-reanimated/docs/about">官方文档</a>。后面文章会继续讲解 React Native Gesture Handler 与 React Native Reanimated 配合使用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://anye3210.github.io/2020/12/14/%E3%80%90React-Native%E8%BF%9B%E9%98%B6%E3%80%91react-native-gesture-handler%E7%9A%84%E4%BD%BF%E7%94%A8/&quot;&gt;上一篇文章&lt;/a&gt;讲解了React Native性能优化的总体思路，并进一步讲解了React Native Gesture Handler的使用。本文讲解另外一个库&lt;a href=&quot;https://docs.swmansion.com/react-native-reanimated/docs/about&quot;&gt;React Native Reanimated&lt;/a&gt;，这个库旨在解决React Native在动画方面的性能问题，让我们能够创建运行在UI线程上的顺滑动画和流畅交互。&lt;/p&gt;
&lt;h2 id=&quot;Reanimated实现动机&quot;&gt;&lt;a href=&quot;#Reanimated实现动机&quot; class=&quot;headerlink&quot; title=&quot;Reanimated实现动机&quot;&gt;&lt;/a&gt;Reanimated实现动机&lt;/h2&gt;&lt;p&gt;上一篇文章讲了React Native中业务逻辑和计算都是在JavaScript线程中，渲染是在UI线程中，两个线程是通信又是异步的，因此渲染并不是实时的，至少会有1桢的延迟，在动画方面也是同样的。&lt;/p&gt;
&lt;p&gt;Reanimated将JavaScript线程上的动画和事件处理逻辑转移到了UI线程。它通过定义Reanimated worklet(可以被移动到一个单独的JavaScript 虚拟机并在UI线程上同步运行的一小段JavaScript代码）来实现。这种机制让我们的触摸事件可以立即被响应并在同一桢上更新UI，不必再担心JavaScript加载和同步这些问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;本文讲解的是当前最新的版本2.0.0-alpha.9，它与版本1有较大的差异。&lt;/p&gt;</summary>
    
    
    
    
    <category term="性能优化" scheme="http://anye3210.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="React Native" scheme="http://anye3210.github.io/tags/React-Native/"/>
    
    <category term="React Native Reanimated" scheme="http://anye3210.github.io/tags/React-Native-Reanimated/"/>
    
    <category term="Reanimated" scheme="http://anye3210.github.io/tags/Reanimated/"/>
    
    <category term="进阶" scheme="http://anye3210.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>【React Native进阶】React Native Gesture Handler的使用</title>
    <link href="http://anye3210.github.io/2020/12/14/%E3%80%90React-Native%E8%BF%9B%E9%98%B6%E3%80%91react-native-gesture-handler%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://anye3210.github.io/2020/12/14/%E3%80%90React-Native%E8%BF%9B%E9%98%B6%E3%80%91react-native-gesture-handler%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-12-14T14:09:41.000Z</published>
    <updated>2021-08-22T07:20:33.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>说到React Navtive的性能优化，首先要了解React Native的运行机制。React Native程序主要运行在三个并行的线程上：</p><ul><li><strong>JavaScript Thread</strong>：我们写的JavaScript代码逻辑都是在这个线程上执行；</li><li><strong>UI Thread</strong>：即原生线程，当我们需要调用原生的渲染或者能力时会运行到这个线程上；</li><li><strong>Shadow Thread</strong>：这个线程创建和管理着Shadow Tree，它类似于虚拟DOM。它通过Yoga引擎着Flexbox布局转化为原生的布局方式。</li></ul><p>这三个线程独立运行的情况下，性能良好，但如果涉及到事件驱动与UI线程有交互的情况，React Native的这种设计效果不佳。</p><p>当与触摸屏交互时，用户希望屏幕上的效果是即时的。如果更新发生在单独的线程中，通常情况下，在JavaScript线程中所做的更改无法反映在同一帧中。在React Native中，默认情况下，由于UI和JavaScript线程之间的通信是异步的，并且UI线程从不等待JavaScript线程完成处理事件，因此所有更新都会延迟至少一个帧。</p><p>而且由于UI线程与其他线程通信存在序列化和反序列化这个比较消耗性能的步骤，当UI线程与其他线程交互比较频繁或者其他线程负荷较大时，通常事件无法立即处理，从而造成更严重的延迟。</p><p>我们的RN代码逻辑都是用JavaScript写的，JavaScript线程也是负荷最大的线程。因此在React Native的性能优化上主要要考虑两个方面： </p><ul><li>减少与UI线程的通信；</li><li>减少JavaScript线程的负荷；</li></ul><p>而<a href="https://docs.swmansion.com/react-native-gesture-handler/docs/"><code>React Native Gesture Handler</code></a>正是从这两个方面优化React Native在手势操作方面的性能。它旨在替换React Native自带的<a href="https://reactnative.dev/docs/gesture-responder-system">手势处理系统</a>。如果你使用过系统自带的手势处理系统，会发现在JavaScript线程会有大量的计算，这些计算也会频繁与UI线程通信，对性能影响较大。具体代码可以自行比较，这里不再赘述。</p><span id="more"></span><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p><strong>React Native Gesture Handler</strong>提供了以下功能：</p><ul><li>提供了包括缩放、旋转、屏蔽滑动等手势的处理系统；</li><li>能够定义多个手势之间的关系。例如：当你在<code>ScrollView</code>里面加入一个滑动手势（pan handler）时，可以让滑动手势响应结束后再响应<code>ScrollView</code>；</li><li>提供了让手势运行在原生线程（UI线程）上并遵从原生平台默认行为机制；</li><li>由于使用了原生的动画驱动，即便在JavaScript线程已经超负荷的情况，也能够提供顺滑的手势交互。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>整个安装分为三个部分：JS部分、Android部分和iOS部分。其中JS和iOS部分都是统一的，Android在使用了第三方导航库和没使用的情况安装配置方式会有不同。</p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><p>使用<code>yarn</code>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-native-gesture-handler</span><br></pre></td></tr></table></figure><p>或者你也可以选择使用<code>npm</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-native-gesture-handler</span><br></pre></td></tr></table></figure><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>如果在项目中使用了导航库（例如：<code>react-native-navigation</code>），直接跳过这部分看后面<a href="#%E9%85%8D%E5%90%88%E5%AF%BC%E8%88%AA%E5%BA%93%E4%BD%BF%E7%94%A8">配合导航库使用</a>的小节。</p><p>更新<code>MainActivity.java</code>文件（或者你在其他地方创建的<code>ReactActivityDelegate</code>实例的内部），重写创建<code>ReactRootView</code>的方法，让这个库的根视图包裹安卓的主活动。注意在文件顶部需要导入<code>ReactActivityDelegate</code>、<code>ReactRootView</code>和<code>RNGestureHandlerEnabledRootView</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.swmansion.gesturehandler.react.example;</span><br><span class="line"></span><br><span class="line">import com.facebook.react.ReactActivity;</span><br><span class="line">+ import com.facebook.react.ReactActivityDelegate;</span><br><span class="line">+ import com.facebook.react.ReactRootView;</span><br><span class="line">+ import com.swmansion.gesturehandler.react.RNGestureHandlerEnabledRootView;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends ReactActivity &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected String getMainComponentName() &#123;</span><br><span class="line">    return &quot;Example&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">+  @Override</span><br><span class="line">+  protected ReactActivityDelegate createReactActivityDelegate() &#123;</span><br><span class="line">+    return new ReactActivityDelegate(this, getMainComponentName()) &#123;</span><br><span class="line">+      @Override</span><br><span class="line">+      protected ReactRootView createRootView() &#123;</span><br><span class="line">+       return new RNGestureHandlerEnabledRootView(MainActivity.this);</span><br><span class="line">+      &#125;</span><br><span class="line">+    &#125;;</span><br><span class="line">+  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><p>如果在项目中使用了<strong>Cocoapods</strong>（React Native 0.60及之后的版本创建时会自动使用），需要在启动前安装pods：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ios &amp;&amp; pod install</span><br></pre></td></tr></table></figure><p>如果React Native版本为0.61或更高，则需要在index.js文件顶部导入库文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;react-native-gesture-handler&#x27;;</span><br></pre></td></tr></table></figure><h2 id="配合导航库使用"><a href="#配合导航库使用" class="headerlink" title="配合导航库使用"></a>配合导航库使用</h2><p>如果你在项目中使用了像<a href="https://github.com/wix/react-native-navigation">react-native-navigation</a> 这样的导航库，由于本地导航库和Gesture Handler库都需要它们自己的<code>ReactRootView</code>子类，在安卓不能使用上述配置，需要如下单独配置。</p><p>与上面的修改Java原生代码不同，你需要在JavaScript代码中将每个页面的组件用<code>gestureHandlerRootHOC</code>包裹起来。可以像下面这样配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import &#123; gestureHandlerRootHOC &#125; from &#x27;react-native-gesture-handler&#x27;;</span><br><span class="line">import &#123; Navigation &#125; from &#x27;react-native-navigation&#x27;;</span><br><span class="line"></span><br><span class="line">import FirstTabScreen from &#x27;./FirstTabScreen&#x27;;</span><br><span class="line">import SecondTabScreen from &#x27;./SecondTabScreen&#x27;;</span><br><span class="line">import PushedScreen from &#x27;./PushedScreen&#x27;;</span><br><span class="line"></span><br><span class="line">// register all screens of the app (including internal ones)</span><br><span class="line">export function registerScreens() &#123;</span><br><span class="line">  Navigation.registerComponent(&#x27;example.FirstTabScreen&#x27;, () =&gt;</span><br><span class="line">    gestureHandlerRootHOC(FirstTabScreen)</span><br><span class="line">  );</span><br><span class="line">  Navigation.registerComponent(&#x27;example.SecondTabScreen&#x27;, () =&gt;</span><br><span class="line">    gestureHandlerRootHOC(SecondTabScreen)</span><br><span class="line">  );</span><br><span class="line">  Navigation.registerComponent(&#x27;example.PushedScreen&#x27;, () =&gt;</span><br><span class="line">    gestureHandlerRootHOC(PushedScreen)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分的配置也可以参考官方的<a href="https://github.com/henrikra/nativeNavigationGestureHandler">示例项目</a>。</p><p>记住你需要把每一个页面的组件（也就是导航库里管理的每个页面）都包裹在<code>gestureHandlerRootHOC</code>下，只包裹主页面是不行的。</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="Gesture-Handlers"><a href="#Gesture-Handlers" class="headerlink" title="Gesture Handlers"></a>Gesture Handlers</h2><p>Gesture Handler是这个手势库的核心，它用来描述原生触控系统里的元素，这些元素能够被JavaScript代码使用React的组件进行实例化和控制。</p><p>每一个Handler类型都代表了一种手势（例如：滑动、缩放），也包含了每种手势特有的事件（例如：translation, scale）。</p><p>这些Handler可以在UI线程同步地解析触摸事件流，即便在JavaScript线程阻塞的情况下也能保证手势交互不被打断。</p><p>Gesture Handler的组件并不会在原生的视图层级里面创建一个视图，它仅仅是在自己库里面注册然后连接到原生的视图里。所以当我们在使用这些Handler组件的时候，一定要记得 在内部添加一个对应着原生视图的子组件。</p><p>这个库提供了以下几种手势：</p><ul><li><a href="https://docs.swmansion.com/react-native-gesture-handler/docs/handler-pan">PanGestureHandler</a></li><li><a href="https://docs.swmansion.com/react-native-gesture-handler/docs/handler-tap">TapGestureHandler</a></li><li><a href="https://docs.swmansion.com/react-native-gesture-handler/docs/handler-longpress">LongPressGestureHandler</a></li><li><a href="https://docs.swmansion.com/react-native-gesture-handler/docs/handler-rotation">RotationGestureHandler</a></li><li><a href="https://docs.swmansion.com/react-native-gesture-handler/docs/handler-fling">FlingGestureHandler</a></li><li><a href="https://docs.swmansion.com/react-native-gesture-handler/docs/handler-pinch">PinchGestureHandler</a></li><li><a href="https://docs.swmansion.com/react-native-gesture-handler/docs/handler-force">ForceTouchGestureHandler</a></li></ul><h3 id="手势分类"><a href="#手势分类" class="headerlink" title="手势分类"></a>手势分类</h3><p>这个手势库将手势分为两种：连续的和非连续的。</p><p>连续的手势被激活后会持续一段较长的时间，它会产生一个手势事件流。例如像滑动手势（PanGestureHandler），它被激活后就会开始持续为translation和其他属性提供更新。</p><p>而非连续性的手势一旦被激活就会立即结束。长按手势（<code>LongPressGestureHandler</code>）就是一个非连续的手势，它只在手指按住持续一段时间后会被激活，并不会追踪手指的移动。</p><p>记住只有连续的手势才能使用<code>onGestureEvent</code>，非连续性的手势Handler没有这个属性。</p><h3 id="onGestureEvent"><a href="#onGestureEvent" class="headerlink" title="onGestureEvent"></a>onGestureEvent</h3><p><code>onGestureEvent</code>参数接收<code>Animated.event</code>方法，这个方法是React Native系统自带的动画处理库的事件处理方法，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">const circleRadius = 30;</span><br><span class="line">class Circle extends Component &#123;</span><br><span class="line">  _touchX = new Animated.Value(windowWidth / 2 - circleRadius);</span><br><span class="line">  _onPanGestureEvent = Animated.event([&#123; nativeEvent: &#123; x: this._touchX &#125; &#125;], &#123;</span><br><span class="line">    useNativeDriver: true,</span><br><span class="line">  &#125;);</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;PanGestureHandler onGestureEvent=&#123;this._onPanGestureEvent&#125;&gt;</span><br><span class="line">        &lt;Animated.View</span><br><span class="line">          style=&#123;&#123;</span><br><span class="line">            height: 150,</span><br><span class="line">            justifyContent: &#x27;center&#x27;,</span><br><span class="line">          &#125;&#125;&gt;</span><br><span class="line">          &lt;Animated.View</span><br><span class="line">            style=&#123;[</span><br><span class="line">              &#123;</span><br><span class="line">                backgroundColor: &#x27;#42a5f5&#x27;,</span><br><span class="line">                borderRadius: circleRadius,</span><br><span class="line">                height: circleRadius * 2,</span><br><span class="line">                width: circleRadius * 2,</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                transform: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    translateX: Animated.add(</span><br><span class="line">                      this._touchX,</span><br><span class="line">                      new Animated.Value(-circleRadius)</span><br><span class="line">                    ),</span><br><span class="line">                  &#125;,</span><br><span class="line">                ],</span><br><span class="line">              &#125;,</span><br><span class="line">            ]&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/Animated.View&gt;</span><br><span class="line">      &lt;/PanGestureHandler&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Animated.event</code>会持续将<code>nativeEvent</code>里的<code>x</code>属性的值同步到对应的<code>_touchX</code>，而<code>_touchX</code>的改变会同步到<code>Animated.View</code>的<code>translateX</code>的改变，从而导致<code>Animated.View</code>的位移。上面就是一个简单的跟随手势移动的小球的例子。</p><p>这里其实也可以配合<code>React Native Reanimated</code>库使用，直接传入<code>useAnimatedGestureHandler</code>即可，在使用上也更简单，具体的使用方法以后的文章会讲到。</p><h3 id="Handler的嵌套"><a href="#Handler的嵌套" class="headerlink" title="Handler的嵌套"></a>Handler的嵌套</h3><p>Handler只是锚定了它的子组件，并没有在原生视图层级里创建新的视图，因此这些手势Handler并不支持直接嵌套，需要在两个手势Handler之间放入<code>&lt;Animated.View&gt;</code>组件。</p><p>下面这种是不支持的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const PanAndRotate = () =&gt; (</span><br><span class="line">  &lt;PanGestureHandler onGestureEvent=&#123;Animated.event(&#123; ... &#125;, &#123; useNativeDriver: true &#125;)&#125;&gt;</span><br><span class="line">    &lt;RotationGestureHandler onGestureEvent=&#123;Animated.event(&#123; ... &#125;, &#123; useNativeDriver: true &#125;)&#125;&gt;</span><br><span class="line">      &lt;Animated.View style=&#123;animatedStyles&#125;/&gt;</span><br><span class="line">    &lt;/RotationGestureHandler&gt;</span><br><span class="line">  &lt;/PanGestureHandler&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>需要在两个Handler之间放入<code>&lt;Animated.View&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const PanAndRotate = () =&gt; (</span><br><span class="line">  &lt;PanGestureHandler onGestureEvent=&#123;Animated.event(&#123; ... &#125;, &#123; useNativeDriver: true &#125;)&#125;&gt;</span><br><span class="line">    &lt;Animated.View&gt;</span><br><span class="line">      &lt;RotationGestureHandler onGestureEvent=&#123;Animated.event(&#123; ... &#125;, &#123; useNativeDriver: true &#125;)&#125;&gt;</span><br><span class="line">        &lt;Animated.View style=&#123;animatedStyles&#125;/&gt;</span><br><span class="line">      &lt;/RotationGestureHandler&gt;</span><br><span class="line">    &lt;/Animated.View&gt;</span><br><span class="line">  &lt;/PanGestureHandler&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>另外一个特别需要注意的是当你在<code>Animated.event</code>中使用了<code>useNativeDriver</code>，它里面嵌套的子节点必须是<code>Animated.API</code>类型的。比例像<code>View</code>就必须被替换成<code>Animated.View</code>。</p><h2 id="Handler-State"><a href="#Handler-State" class="headerlink" title="Handler State"></a>Handler State</h2><p>手势Handler可以被看作是一个状态机，每个Handler在有新的手势事件触发或者手势系统状态变更时都会更新当前的状态。</p><p>Handler的状态分为以下几种：</p><ul><li>UNDETERMINED</li><li>FAILED</li><li>BEGAN</li><li>CANCELLED</li><li>ACTIVE</li><li>END</li></ul><p>顾名思义，这里就不作过多解释了。</p><h3 id="获取状态"><a href="#获取状态" class="headerlink" title="获取状态"></a>获取状态</h3><p>我们可以通过<code>onHandlerStateChange</code>来监听Handler的状态。状态可以通过<code>nativeEvent</code>的<code>state</code>属性获取到，然后与这个手势库中的<code>State</code>对象里的常量进行对比：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; State, LongPressGestureHandler &#125; from &#x27;react-native-gesture-handler&#x27;;</span><br><span class="line"></span><br><span class="line">class Demo extends Component &#123;</span><br><span class="line">  _handleStateChange = (&#123; nativeEvent &#125;) =&gt; &#123;</span><br><span class="line">    if (nativeEvent.state === State.ACTIVE) &#123;</span><br><span class="line">      Alert.alert(&#x27;Longpress&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;LongPressGestureHandler onHandlerStateChange=&#123;this._handleStateChange&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.buttonText&#125;&gt;Longpress me&lt;/Text&gt;</span><br><span class="line">      &lt;/LongPressGestureHandler&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态转换顺序"><a href="#状态转换顺序" class="headerlink" title="状态转换顺序"></a>状态转换顺序</h3><p>最典型的状态转换顺序就是手势Handler捕获到触摸事件，然后识别出具体的手势，手势结束后重置到最初状态。这种状态转换顺序如下所示（长箭头表示状态改变前这里可能有更多的触摸事件）：</p><p><code>UNDETERMINED</code> -&gt; <code>BEGAN</code> ——&gt; <code>ACTIVE</code> ——&gt; <code>END</code> -&gt; <code>UNDETERMINED</code></p><p>下面这种是Handler捕获到了触摸事件但是识别手势的时候失败的情况：</p><p><code>UNDETERMINED</code> -&gt; <code>BEGAN</code> ——&gt; <code>FAILED</code> -&gt; <code>UNDETERMINED</code></p><p>下面这种是手势中断的情况：</p><p><code>UNDETERMINED</code> -&gt; <code>BEGAN</code> ——&gt; <code>ACTIVE</code> ——&gt; <code>CANCELLED</code> -&gt; <code>UNDETERMINED</code></p><h2 id="手势之间的交互"><a href="#手势之间的交互" class="headerlink" title="手势之间的交互"></a>手势之间的交互</h2><p>这个手势库支持不同的手势Handler之间通信来构建更加复杂的手势交互。</p><p>有下面两种方法可以实现这种交互控制。每一种方法手势Handler都需要提供一个引用给其他Handler。手势Handler的引用是通过<code>React.createRef()</code>来创建的引用对象。</p><h3 id="同时识别"><a href="#同时识别" class="headerlink" title="同时识别"></a>同时识别</h3><p>默认情况下同一个时间只有一种手势Handler可以是激活状态。当手势Handler识别到了一个手势，它会取消其他所有处于began状态的手势Handler并且在其激活状态下停止接收其他任何触摸事件。</p><p>这种行为可以通过<code>simultaneousHandlers</code>这个属性来改变，并且这个属性每种类型的Handler都有。这个属性持有一个数组，数组里有其他手势Handler的引用。手势Handler可以通过这种方式同时处于激活状态。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当我们实现图片预览组件的时候就需要这种同时识别，在图片预览中我们可以缩放、旋转而且可以在它缩放时移动它。在这个场景中我们需要使用<code>PinchGestureHandler</code>, <code>RotationGestureHandler</code>和<code>PanGestureHandler</code>并让它们能够被同时识别。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>可以查看<a href="https://docs.swmansion.com/react-native-gesture-handler/docs/example/">官方示例App</a>中的<a href="https://github.com/software-mansion/react-native-gesture-handler/blob/master/examples/Example/scaleAndRotate/index.js">“Scale, rotate &amp; tilt” example</a>部分，以下是其中的片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class PinchableBox extends React.Component &#123;</span><br><span class="line">  // ...take a look on full implementation in an Example app</span><br><span class="line">  render() &#123;</span><br><span class="line">    const imagePinch = React.createRef();</span><br><span class="line">    const imageRotation = React.createRef();</span><br><span class="line">    return (</span><br><span class="line">      &lt;RotationGestureHandler</span><br><span class="line">        ref=&#123;imageRotation&#125;</span><br><span class="line">        simultaneousHandlers=&#123;imagePinch&#125;</span><br><span class="line">        onGestureEvent=&#123;this._onRotateGestureEvent&#125;</span><br><span class="line">        onHandlerStateChange=&#123;this._onRotateHandlerStateChange&#125;&gt;</span><br><span class="line">        &lt;Animated.View&gt;</span><br><span class="line">          &lt;PinchGestureHandler</span><br><span class="line">            ref=&#123;imagePinch&#125;</span><br><span class="line">            simultaneousHandlers=&#123;imageRotation&#125;</span><br><span class="line">            onGestureEvent=&#123;this._onPinchGestureEvent&#125;</span><br><span class="line">            onHandlerStateChange=&#123;this._onPinchHandlerStateChange&#125;&gt;</span><br><span class="line">            &lt;Animated.View style=&#123;styles.container&#125; collapsable=&#123;false&#125;&gt;</span><br><span class="line">              &lt;Animated.Image</span><br><span class="line">                style=&#123;[</span><br><span class="line">                  styles.pinchableImage,</span><br><span class="line">                  &#123;</span><br><span class="line">                    /* events-related transformations */</span><br><span class="line">                  &#125;,</span><br><span class="line">                ]&#125;</span><br><span class="line">              /&gt;</span><br><span class="line">            &lt;/Animated.View&gt;</span><br><span class="line">          &lt;/PinchGestureHandler&gt;</span><br><span class="line">        &lt;/Animated.View&gt;</span><br><span class="line">      &lt;/RotationGestureHandler&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待其他手势完成"><a href="#等待其他手势完成" class="headerlink" title="等待其他手势完成"></a>等待其他手势完成</h3><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>这种手势交互方式最好的例子就是当我们在一个视图上同时注册了单次点击和双击事件的情况。这种情况下就需要单击事件等待双击事件识别完成后才识别，否则就会出现只识别单击事件而双击事件无法触发的情况。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>参考<a href="https://docs.swmansion.com/react-native-gesture-handler/docs/example/">官方示例App</a>中的<a href="https://github.com/software-mansion/react-native-gesture-handler/blob/master/examples/Example/multitap/index.js">“Multitap” example</a>部分，以下是部分片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const doubleTap = React.createRef();</span><br><span class="line">const PressBox = () =&gt; (</span><br><span class="line">  &lt;TapGestureHandler</span><br><span class="line">    onHandlerStateChange=&#123;(&#123; nativeEvent &#125;) =&gt;</span><br><span class="line">      nativeEvent.state === State.ACTIVE &amp;&amp; Alert.alert(&#x27;Single tap!&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    waitFor=&#123;doubleTap&#125;&gt;</span><br><span class="line">    &lt;TapGestureHandler</span><br><span class="line">      ref=&#123;doubleTap&#125;</span><br><span class="line">      onHandlerStateChange=&#123;(&#123; nativeEvent &#125;) =&gt;</span><br><span class="line">        nativeEvent.state === State.ACTIVE &amp;&amp; Alert.alert(&quot;You&#x27;re so fast&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      numberOfTaps=&#123;2&#125;&gt;</span><br><span class="line">      &lt;View style=&#123;styles.box&#125; /&gt;</span><br><span class="line">    &lt;/TapGestureHandler&gt;</span><br><span class="line">  &lt;/TapGestureHandler&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，React Native Gesture Handler的基本使用就介绍完了。关于React Native优化，本文介绍的手势库只是解决了手势方面的性能问题，一般来说，手势都是配合了相应的动画使用的，比如手势拖拽功能，后面的文章会继续讲解动画的性能优化库<strong>React Native Reanimated</strong>以及这两个库如何配合使用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;说到React Navtive的性能优化，首先要了解React Native的运行机制。React Native程序主要运行在三个并行的线程上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JavaScript Thread&lt;/strong&gt;：我们写的JavaScript代码逻辑都是在这个线程上执行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UI Thread&lt;/strong&gt;：即原生线程，当我们需要调用原生的渲染或者能力时会运行到这个线程上；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shadow Thread&lt;/strong&gt;：这个线程创建和管理着Shadow Tree，它类似于虚拟DOM。它通过Yoga引擎着Flexbox布局转化为原生的布局方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三个线程独立运行的情况下，性能良好，但如果涉及到事件驱动与UI线程有交互的情况，React Native的这种设计效果不佳。&lt;/p&gt;
&lt;p&gt;当与触摸屏交互时，用户希望屏幕上的效果是即时的。如果更新发生在单独的线程中，通常情况下，在JavaScript线程中所做的更改无法反映在同一帧中。在React Native中，默认情况下，由于UI和JavaScript线程之间的通信是异步的，并且UI线程从不等待JavaScript线程完成处理事件，因此所有更新都会延迟至少一个帧。&lt;/p&gt;
&lt;p&gt;而且由于UI线程与其他线程通信存在序列化和反序列化这个比较消耗性能的步骤，当UI线程与其他线程交互比较频繁或者其他线程负荷较大时，通常事件无法立即处理，从而造成更严重的延迟。&lt;/p&gt;
&lt;p&gt;我们的RN代码逻辑都是用JavaScript写的，JavaScript线程也是负荷最大的线程。因此在React Native的性能优化上主要要考虑两个方面： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少与UI线程的通信；&lt;/li&gt;
&lt;li&gt;减少JavaScript线程的负荷；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而&lt;a href=&quot;https://docs.swmansion.com/react-native-gesture-handler/docs/&quot;&gt;&lt;code&gt;React Native Gesture Handler&lt;/code&gt;&lt;/a&gt;正是从这两个方面优化React Native在手势操作方面的性能。它旨在替换React Native自带的&lt;a href=&quot;https://reactnative.dev/docs/gesture-responder-system&quot;&gt;手势处理系统&lt;/a&gt;。如果你使用过系统自带的手势处理系统，会发现在JavaScript线程会有大量的计算，这些计算也会频繁与UI线程通信，对性能影响较大。具体代码可以自行比较，这里不再赘述。&lt;/p&gt;</summary>
    
    
    
    
    <category term="性能优化" scheme="http://anye3210.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="React Native" scheme="http://anye3210.github.io/tags/React-Native/"/>
    
    <category term="React Native Gesture Handler" scheme="http://anye3210.github.io/tags/React-Native-Gesture-Handler/"/>
    
    <category term="Gesture Handler" scheme="http://anye3210.github.io/tags/Gesture-Handler/"/>
    
  </entry>
  
  <entry>
    <title>【React Native教程】Stack Navigation与Tab Navigation嵌套最佳实践</title>
    <link href="http://anye3210.github.io/2020/12/07/%E3%80%90React-Native%E6%95%99%E7%A8%8B%E3%80%91StackNavigation%E4%B8%8ETabNavigation%E5%B5%8C%E5%A5%97%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://anye3210.github.io/2020/12/07/%E3%80%90React-Native%E6%95%99%E7%A8%8B%E3%80%91StackNavigation%E4%B8%8ETabNavigation%E5%B5%8C%E5%A5%97%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-12-07T12:55:20.000Z</published>
    <updated>2021-08-22T07:21:59.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91React-Navigation%E7%9A%84%E4%BD%BF%E7%94%A8/">上一篇文章</a>详细讲解了<code>react-navigation</code>的使用，这篇文章主要说一下<code>Stack Navigation</code>与<code>Tab Navigation</code>嵌套的问题。</p><p>在iOS原生开发中，一般是在<code>TabController</code>里嵌套<code>NavigationController</code>，也就是说底部导航控制器里放多个堆栈导航控制器，每个堆栈导航控制器控制有独立的堆栈和状态。</p><p>但如果在使用<code>react-navigation</code>进行这种嵌套方式，由于根控制器是底部的<code>TabNavigation</code>，每次跳转到子控制器时，底部的导航栏不会隐藏。官方文档说可以用属性更改的方法隐藏底部导航栏，但不推荐，会影响性能。因此本文主要讲解如何使用堆栈导航器中嵌套底部导航控制器来解决这个问题。</p><span id="more"></span><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>首先将<code>Main</code>控制器放入<code>Stack Navigation</code>中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">NavigationContainer</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Stack.Navigator</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Stack.Screen</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">key</span>=<span class="string">&quot;Main&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">name</span>=<span class="string">&quot;Main&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">component</span>=<span class="string">&#123;Main&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">options</span>=<span class="string">&#123;(&#123;route&#125;)</span> =&gt;</span> (&#123;</span></span><br><span class="line"><span class="xml">                        headerTitle: route.name</span></span><br><span class="line"><span class="xml">                    &#125;)&#125;</span></span><br><span class="line"><span class="xml">                /&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Stack.Navigator</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">NavigationContainer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后实现<code>Main</code>控制器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Main = <span class="function">(<span class="params">&#123;navigation, route&#125;</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Tab.Navigator</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">screenOptions</span>=<span class="string">&#123;(&#123;</span> <span class="attr">route</span> &#125;) =&gt;</span> (&#123;</span></span><br><span class="line"><span class="xml">                tabBarIcon: (&#123; focused, color, size &#125;) =&gt; &#123;``</span></span><br><span class="line"><span class="xml">                    return (</span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Image</span> <span class="attr">style</span> = <span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">25</span>, <span class="attr">height:</span> <span class="attr">25</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">                               <span class="attr">source</span> = <span class="string">&#123;this.iconImage(route,</span> <span class="attr">focused</span>)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">                        /&gt;</span>);</span></span><br><span class="line"><span class="xml">                &#125;,</span></span><br><span class="line"><span class="xml">            &#125;)&#125;</span></span><br><span class="line"><span class="xml">            tabBarOptions=&#123;&#123;</span></span><br><span class="line"><span class="xml">                activeTintColor: &#x27;#32B7FF&#x27;,</span></span><br><span class="line"><span class="xml">                inactiveTintColor: &#x27;gray&#x27;,</span></span><br><span class="line"><span class="xml">            &#125;&#125;</span></span><br><span class="line"><span class="xml">        &gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Tab.Screen</span> <span class="attr">name</span>=<span class="string">&quot;Home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;HomeScreen&#125;</span> <span class="attr">options</span>=<span class="string">&#123;&#123;title:</span> &#x27;<span class="attr">Home</span>&#x27;&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Tab.Screen</span> <span class="attr">name</span>=<span class="string">&quot;Settings&quot;</span> <span class="attr">component</span>=<span class="string">&#123;SettingsScreen&#125;</span> <span class="attr">options</span>=<span class="string">&#123;&#123;title:</span> &#x27;<span class="attr">Settings</span>&#x27;&#125;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Tab.Navigator</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iconImage</span>(<span class="params">route, focused</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> image;</span><br><span class="line">    <span class="keyword">if</span> (route.name === <span class="string">&#x27;Home&#x27;</span>) &#123;</span><br><span class="line">        image = focused</span><br><span class="line">            ? <span class="built_in">require</span>(<span class="string">&#x27;../../images/homePage_sel.png&#x27;</span>)</span><br><span class="line">            : <span class="built_in">require</span>(<span class="string">&#x27;../../images/homePage_nor.png&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        image = focused</span><br><span class="line">            ? <span class="built_in">require</span>(<span class="string">&#x27;../../images/setting_sel.png&#x27;</span>)</span><br><span class="line">            : <span class="built_in">require</span>(<span class="string">&#x27;../../images/setting_nor.png&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面<code>Home</code>和<code>Setting</code>页面的实现这里就不再赘述，实现之后运行会发一<code>Home</code>和<code>Setting</code>顶部导航栏的标题和样式都是相同的，也就是<code>Main</code>控制器的。这是由于<code>Tab Navigation</code>作为<code>Stack Navigation</code>的根控制器，顶部导航栏的标题都是按照根控制器的设置来显示的。要实现<code>Tab Navigaiton</code>的子控制器都有自己的独立顶部导航栏，需要使用<code>React</code>的<code>Hook</code>方法，在<code>return</code>前面加上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">React.useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigation.setOptions(&#123;</span><br><span class="line">      <span class="attr">headerTitle</span>: <span class="built_in">this</span>.getHeaderTitle(route),</span><br><span class="line">      <span class="attr">headerRight</span>: <span class="built_in">this</span>.getHeaderRight(route),</span><br><span class="line">      <span class="attr">headerLeft</span>: <span class="built_in">this</span>.getHeaderLeft(route),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [navigation, route]);</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="title">getHeaderTitle</span>(<span class="params">route</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> routeName = getFocusedRouteNameFromRoute(route) ?? <span class="string">&#x27;Home&#x27;</span>;</span><br><span class="line">  <span class="keyword">switch</span> (routeName) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Home&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;首页&#x27;</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Settings&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;系统设置&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用了<code>React</code>的<code>useLayoutEffect</code>方法，这个方法会从<code>DOM</code>里读取布局并同步把新布局添加了布局更新计划中，等一下次重新绘制就会更新上去。在方法中通过<code>route</code>名称动态地改变了导航栏的标题和左右侧的按钮，当底部导航栏按钮被点击进行切换时，顶底的导航栏显示也会同步更新。</p><p>至此，<code>Stack Navigation</code>和<code>Tab Navigation</code>嵌套时保证跳转时隐藏底部导航栏的最佳实践就完成了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91React-Navigation%E7%9A%84%E4%BD%BF%E7%94%A8/&quot;&gt;上一篇文章&lt;/a&gt;详细讲解了&lt;code&gt;react-navigation&lt;/code&gt;的使用，这篇文章主要说一下&lt;code&gt;Stack Navigation&lt;/code&gt;与&lt;code&gt;Tab Navigation&lt;/code&gt;嵌套的问题。&lt;/p&gt;
&lt;p&gt;在iOS原生开发中，一般是在&lt;code&gt;TabController&lt;/code&gt;里嵌套&lt;code&gt;NavigationController&lt;/code&gt;，也就是说底部导航控制器里放多个堆栈导航控制器，每个堆栈导航控制器控制有独立的堆栈和状态。&lt;/p&gt;
&lt;p&gt;但如果在使用&lt;code&gt;react-navigation&lt;/code&gt;进行这种嵌套方式，由于根控制器是底部的&lt;code&gt;TabNavigation&lt;/code&gt;，每次跳转到子控制器时，底部的导航栏不会隐藏。官方文档说可以用属性更改的方法隐藏底部导航栏，但不推荐，会影响性能。因此本文主要讲解如何使用堆栈导航器中嵌套底部导航控制器来解决这个问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="React Native" scheme="http://anye3210.github.io/tags/React-Native/"/>
    
    <category term="React" scheme="http://anye3210.github.io/tags/React/"/>
    
    <category term="Stack Navigation" scheme="http://anye3210.github.io/tags/Stack-Navigation/"/>
    
    <category term="Tab Navigation" scheme="http://anye3210.github.io/tags/Tab-Navigation/"/>
    
    <category term="嵌套" scheme="http://anye3210.github.io/tags/%E5%B5%8C%E5%A5%97/"/>
    
  </entry>
  
  <entry>
    <title>【React Native】Redux自定义中间件</title>
    <link href="http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91Redux%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91Redux%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2020-08-03T14:32:29.000Z</published>
    <updated>2021-08-22T07:56:25.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://blog.csdn.net/anye32100/article/details/107763956">上一篇文章</a>中介绍了<strong>Redux</strong>在<strong>React Native</strong>中的基本使用，这篇文章介绍一下如何在<code>Redux</code>中自定义中间件。</p><h2 id="中间件功能"><a href="#中间件功能" class="headerlink" title="中间件功能"></a>中间件功能</h2><p>中间件的作用主要是拦截指定的<strong>Action</strong>，进行自定义操作后继续执行该<strong>Action</strong>或指派执行其他<strong>Action</strong>。这里拦截的<strong>Action</strong>主要是指同步的<strong>Action</strong>，异步<strong>Action</strong>在<strong>Thunk</strong>中间件已经提供了相关功能。</p><span id="more"></span><h2 id="自定义流程"><a href="#自定义流程" class="headerlink" title="自定义流程"></a>自定义流程</h2><h3 id="创建中间件"><a href="#创建中间件" class="headerlink" title="创建中间件"></a>创建中间件</h3><p>以上一篇文件的<code>Demo</code>为例，这里添加一个参数检查的中间件。新建<code>CheckParameterMidleware.js</code>，添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export function checkParameterMiddleware(&#123; dispatch &#125;) &#123;</span><br><span class="line">    return function(next)&#123;</span><br><span class="line">        return function(action)&#123;</span><br><span class="line">            console.debug(action);</span><br><span class="line">            if (action.type === &#x27;counter/incrementAction&#x27; || action.type === &#x27;counter/decrementActio&#x27;) &#123;</span><br><span class="line">                console.debug(action);</span><br><span class="line">                if (!checkIsNumber(action.payload)) &#123;</span><br><span class="line">                    return next(errorInput(&quot;请输入数字！&quot;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return next(action);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function checkIsNumber(value) &#123;</span><br><span class="line">    return typeof value === &#x27;number&#x27; &amp;&amp; !isNaN(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个中间件本质是一个嵌套的方法，外层方法会传入<code>next</code>和<code>action</code>， 我们可以用<code>action</code>的<code>type</code>区分不同的动作。如果是用<strong>Slice</strong>方式创建的<code>Action``Type</code>格式是这样的：<code>auth名称/action名称</code>。</p><p>在上面的方法中拦截了<code>incrementAction</code>和<code>decrementAction</code>两个方法，检查用户输入的是不是数字，如果不是数字则执行<code>errorInput</code>这个<code>Action</code>。</p><h3 id="使用中间件"><a href="#使用中间件" class="headerlink" title="使用中间件"></a>使用中间件</h3><p>要使创建的中间件生效，只需要在创建<code>Store</code>时传入相应的中间件即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const middleware = [</span><br><span class="line">    ...getDefaultMiddleware(),</span><br><span class="line">    checkParameterMiddleware</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export const store = configureStore(&#123;</span><br><span class="line">    reducer: &#123;</span><br><span class="line">        count: countReducer,</span><br><span class="line">    &#125;,</span><br><span class="line">    middleware,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下来就可以尝试输入非数字检测中间件是否生效。</p><p>完整代码可以在<a href="https://github.com/zephyrw/redux_example">这里</a>查看。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://blog.csdn.net/anye32100/article/details/107763956&quot;&gt;上一篇文章&lt;/a&gt;中介绍了&lt;strong&gt;Redux&lt;/strong&gt;在&lt;strong&gt;React Native&lt;/strong&gt;中的基本使用，这篇文章介绍一下如何在&lt;code&gt;Redux&lt;/code&gt;中自定义中间件。&lt;/p&gt;
&lt;h2 id=&quot;中间件功能&quot;&gt;&lt;a href=&quot;#中间件功能&quot; class=&quot;headerlink&quot; title=&quot;中间件功能&quot;&gt;&lt;/a&gt;中间件功能&lt;/h2&gt;&lt;p&gt;中间件的作用主要是拦截指定的&lt;strong&gt;Action&lt;/strong&gt;，进行自定义操作后继续执行该&lt;strong&gt;Action&lt;/strong&gt;或指派执行其他&lt;strong&gt;Action&lt;/strong&gt;。这里拦截的&lt;strong&gt;Action&lt;/strong&gt;主要是指同步的&lt;strong&gt;Action&lt;/strong&gt;，异步&lt;strong&gt;Action&lt;/strong&gt;在&lt;strong&gt;Thunk&lt;/strong&gt;中间件已经提供了相关功能。&lt;/p&gt;</summary>
    
    
    
    
    <category term="React Native" scheme="http://anye3210.github.io/tags/React-Native/"/>
    
    <category term="React" scheme="http://anye3210.github.io/tags/React/"/>
    
    <category term="Redux" scheme="http://anye3210.github.io/tags/Redux/"/>
    
    <category term="Middleware" scheme="http://anye3210.github.io/tags/Middleware/"/>
    
    <category term="中间件" scheme="http://anye3210.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>【React Native教程】Redux入门教程</title>
    <link href="http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E6%95%99%E7%A8%8B%E3%80%91Redux%E5%85%A5%E9%97%A8/"/>
    <id>http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E6%95%99%E7%A8%8B%E3%80%91Redux%E5%85%A5%E9%97%A8/</id>
    <published>2020-08-03T13:51:35.000Z</published>
    <updated>2021-08-22T07:56:05.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redux定义"><a href="#Redux定义" class="headerlink" title="Redux定义"></a>Redux定义</h2><p><strong>Redux</strong>在<a href="https://redux.js.org/">官网</a>上是这么定义的：<strong>A Predictable State Container for JS Apps</strong>，直译过来就是一个使用在JS应用上的可预测的状态容器。</p><h2 id="Redux解决的问题"><a href="#Redux解决的问题" class="headerlink" title="Redux解决的问题"></a>Redux解决的问题</h2><p><code>React Native</code>本身是基于前端的<code>React</code>框架，它是通过<code>State</code>来管理页面显示和参数更新。如果在交互比较复杂的页面、需要多页面状态传递或者同步更新状态的情况，状态管理就会比较麻烦。使用<code>Redux</code>就可以解决这些问题。</p><h2 id="Redux的核心逻辑和概念"><a href="#Redux的核心逻辑和概念" class="headerlink" title="Redux的核心逻辑和概念"></a>Redux的核心逻辑和概念</h2><p><strong>Redux</strong>的核心逻辑是集中定义和管理状态和动作执行，各个页面使用<code>connect</code>方法绑定相应的方法和状态，并通过发送动作指令更新页面显示。达到状态和操作与页面隔离的效果。</p><span id="more"></span><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><strong>State</strong>即状态，是<strong>React</strong>框架最基础的概念之一，通过更改状态实时更新页面显示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">prop1: value1,</span><br><span class="line">prop2: value2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><strong>Action</strong>是指指令或者动作。在<strong>Redux</strong>中，页面不直接管理状态，每个页面都是通过发送<strong>Action</strong>间接地更新状态。<strong>Action</strong>中有两个参数，一个是<code>Type</code>，字符串类型，代表<strong>Action</strong>的类型和唯一标识，一个是<code>payload</code>，代表传递的参数，可以是任意类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">type: &#x27;EXAMPLE_ACTION&#x27;,</span><br><span class="line">payload: &#x27;args&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>在<strong>Redux</strong>中状态和动作都是集中管理，管理者被称为<strong>Reducer</strong>，<strong>Reducer</strong>接收<code>State</code>和<code>Action</code>参数，根据传过来的<code>Action</code>类型和参数进行处理并更新<code>State</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function rootReducer(state = initialState, action) &#123;</span><br><span class="line">  if (action.type === &#x27;FIRST_ACTION&#x27;) &#123;</span><br><span class="line">    return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">      props: newValue</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h3><p>在以往的<strong>Redux</strong>使用中，我们需要自己创建<code>Action</code>和<code>Reducer</code>，并用<code>Switch</code>或者<code>if else</code>语句区分不同的<code>Action</code>，步骤非常繁琐。现在<strong>Redux</strong>官方推荐使用更方便更现代化的工具**@reduxjs/toolkit<strong>，这个工具集成了<code>createAction</code>、<code>createReducer</code>等方法，非常方便。不过这两个方法一般也不用，在</strong>tookit<strong>提供了一个新的类</strong>Slice<strong>，创建</strong>Slice时也会同时创建<code>State</code>、<code>Reducer</code>和<code>Action</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const mySlice = createSlice(&#123;</span><br><span class="line">name: &quot;sliceName&quot;,</span><br><span class="line">initialState: &#123;</span><br><span class="line">    prop1: &quot;&quot;,</span><br><span class="line">    prop2: false,</span><br><span class="line">&#125;,</span><br><span class="line">reducers: &#123;</span><br><span class="line">    action1: (state, action) =&gt; &#123;</span><br><span class="line">        console.debug(&#x27;action1 done&#x27;+action.type);</span><br><span class="line">    &#125;,</span><br><span class="line">    action2: (state) =&gt; &#123;</span><br><span class="line">        state.prop1 = &quot;123&quot;;</span><br><span class="line">        state.prop2 = true;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在需要使用<code>Reducer</code>和<code>Action</code>时，直接抽取即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; action1, action2 &#125; = authSlice.actions;</span><br><span class="line">const myReducer = mySlice.reducer;</span><br></pre></td></tr></table></figure><h3 id="Thunk"><a href="#Thunk" class="headerlink" title="Thunk"></a>Thunk</h3><p>上面介绍的是普通<strong>Action</strong>，但如果是执行的动作需要异步执行后更新状态的就不适用了，因此<strong>Redux</strong>引入了中间件<strong>Thunk</strong>，在引入**@reduxjs/toolkit**后创建异步<code>Action</code>方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">export const doLogin = createAsyncThunk(</span><br><span class="line">    &#x27;user/login&#x27;,</span><br><span class="line">    async (&#123;username, password, code&#125;) =&gt; &#123;</span><br><span class="line">        return await API.fetchData(&#123;</span><br><span class="line">            path: &#x27;doLogin&#x27;,</span><br><span class="line">            params: &#123;</span><br><span class="line">                code: code,</span><br><span class="line">                password: AESTool.encrypt(password),</span><br><span class="line">                userName: username,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        condition: (&#123;username, password, code&#125;) =&gt; &#123;</span><br><span class="line">            if (checkStringEmpty(username)) &#123;</span><br><span class="line">                HUD.show(&quot;请输入用户名！&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else if (checkStringEmpty(password)) &#123;</span><br><span class="line">                HUD.show(&quot;请输入密码！&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else if (checkStringEmpty(code)) &#123;</span><br><span class="line">                HUD.show(&quot;请输入验证码！&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;,</span><br><span class="line">        dispatchConditionRejection: true</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在上面的代码中，在<code>condition</code>可以控制这个异步<code>Action</code>是否可以继续执行，如果返回<code>false</code>，<code>Action</code>会终止执行而且没有回调。如果希望返回<code>false</code>后有<code>rejected</code>回调，可以设置<code>dispatchConditionRejection</code>为<code>true</code>。</p><p>异步<code>Action</code>执行完成后，回调是在<strong>Slice</strong>的<code>extraReducers</code>中，异步<code>Action</code>有三个状态：<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>，分别代表正在执行、成功执行和执行失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">extraReducers: &#123;</span><br><span class="line">    [ doLogin.pending ]: () =&gt; &#123;</span><br><span class="line">        Loading.show();</span><br><span class="line">    &#125;,</span><br><span class="line">    [ doLogin.fulfilled ]: (state, action) =&gt; &#123;</span><br><span class="line">        Loading.hidden();</span><br><span class="line">        console.debug(action.payload)</span><br><span class="line">    &#125;,</span><br><span class="line">    [ doLogin.rejected ]: (state, action) =&gt; &#123;</span><br><span class="line">        Loading.hidden();</span><br><span class="line">        console.warn(action.error);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p><strong>Store</strong>是<strong>Redux</strong>的核心类，它的作用是管理所有的<strong>Reducer</strong>和中间件，并作为参数传递到项目的根视图组件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const middleware = [</span><br><span class="line">    ...getDefaultMiddleware(),</span><br><span class="line">    CustomMiddleWare,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export const store = configureStore(&#123;</span><br><span class="line">    reducer: &#123;</span><br><span class="line">        auth: authReducer,</span><br><span class="line">        common: commonReducer</span><br><span class="line">    &#125;,</span><br><span class="line">    middleware,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;StatusBar barStyle=&#123;&#x27;light-content&#x27;&#125;/&gt;</span><br><span class="line">    &lt;App/&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure><h2 id="Redux在React-Native中的使用"><a href="#Redux在React-Native中的使用" class="headerlink" title="Redux在React Native中的使用"></a>Redux在React Native中的使用</h2><p>下面以一个简单的计数器为例讲解一下如果在<strong>React Native</strong>中使用<strong>Redux</strong>。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>首先需要安装**@reduxjs/toolkit<strong>，可以使用</strong>NPM<strong>或者</strong>Yarn**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># NPM</span><br><span class="line">npm install @reduxjs/toolkit</span><br><span class="line"></span><br><span class="line"># Yarn</span><br><span class="line">yarn add @reduxjs/toolkit</span><br></pre></td></tr></table></figure><p>然后安装<strong>Redux</strong>核心库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># NPM</span><br><span class="line">npm install redux</span><br><span class="line"></span><br><span class="line"># Yarn</span><br><span class="line">yarn add redux</span><br></pre></td></tr></table></figure><h3 id="创建Slice"><a href="#创建Slice" class="headerlink" title="创建Slice"></a>创建Slice</h3><p>创建<strong>Slice</strong>时会同步创建<code>State</code>、<code>Reducer</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createSlice&#125; from &#x27;@reduxjs/toolkit&#x27;;</span><br><span class="line"></span><br><span class="line">const countSlice = createSlice(&#123;</span><br><span class="line">    name: &quot;count&quot;,</span><br><span class="line">    initialState: &#123;</span><br><span class="line">        value: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    reducers: &#123;</span><br><span class="line">        incrementAction: (state, action) =&gt; &#123;</span><br><span class="line">            state.value += action.payload;</span><br><span class="line">        &#125;,</span><br><span class="line">        decrementAction: (state, action) =&gt; &#123;</span><br><span class="line">            state.value -= action.payload;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export const &#123;incrementAction, decrementAction &#125; = countSlice.actions;</span><br><span class="line"></span><br><span class="line">export const countReducer = countSlice.reducer;</span><br></pre></td></tr></table></figure><p>在这里创建了名为<code>count</code>的<strong>Slice</strong>，计算器初始值为0，并在<strong>Reducer</strong>中定义了两个<code>Action</code>：<code>incrementAction</code>和<code>decrementAction</code>，根据传过来的参数确定每次加减的数值。后面两行<code>export</code>代码确保外部能够访问这里创建的<code>Action</code>和<code>reducer</code>。</p><h3 id="创建Store"><a href="#创建Store" class="headerlink" title="创建Store"></a>创建Store</h3><p>接下来就是创建<code>Store</code>，创建时会传入刚刚创建的<code>reducer</code>。</p><p><strong>注意：</strong>在页面获取状态值的时候中间一定要先获取<code>reducer</code>，然后再获取<code>reducer</code>里的状态值，例如获取<code>countReducer</code>里的<code>value</code>：<code>state.count.value</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123;configureStore, createSlice, getDefaultMiddleware&#125; from &quot;@reduxjs/toolkit&quot;;</span><br><span class="line">import &#123;countReducer&#125; from &#x27;./slices/CountSlice&#x27;</span><br><span class="line"></span><br><span class="line">const middleware = [</span><br><span class="line">    ...getDefaultMiddleware(),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">export const store = configureStore(&#123;</span><br><span class="line">    reducer: &#123;</span><br><span class="line">        count: countReducer, </span><br><span class="line">    &#125;,</span><br><span class="line">    middleware,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，<strong>Redux</strong>部分就准备好了，接下来就是页面的交互部分了。</p><h3 id="页面嵌入Redux"><a href="#页面嵌入Redux" class="headerlink" title="页面嵌入Redux"></a>页面嵌入Redux</h3><p>在<code>index.js</code>文件中将<code>Provider</code>更改为<code>App</code>的根控件，并传入<code>store</code>作为参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AppRegistry.registerComponent(appName, () =&gt; ProviderContainer);</span><br><span class="line"></span><br><span class="line">const ProviderContainer = () =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;App/&gt;</span><br><span class="line">        &lt;/Provider&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>App.js</code>的主要代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      num: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;StatusBar barStyle=&quot;dark-content&quot; /&gt;</span><br><span class="line">          &lt;SafeAreaView&gt;</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">              &lt;TextInput style=&#123;styles.textInput&#125; onChangeText=&#123;(text)=&gt;&#123;</span><br><span class="line">                this.setState(&#123;</span><br><span class="line">                  num: parseInt(text)</span><br><span class="line">                &#125;)</span><br><span class="line">              &#125;&#125;&gt;&#123;isNaN(this.state.num) ? 1 : this.state.num&#125;&lt;/TextInput&gt;</span><br><span class="line">              &lt;View style=&#123;styles.buttonContainer&#125;&gt;</span><br><span class="line">                &lt;TouchableOpacity style=&#123;styles.button&#125; activeOpacity = &#123;.9&#125; onPress=&#123;() =&gt; &#123;</span><br><span class="line">                  this.props.decrement(this.state.num)</span><br><span class="line">                &#125;&#125;&gt;</span><br><span class="line">                  &lt;Text style=&#123;styles.buttonText&#125;&gt;-&lt;/Text&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.text&#125;&gt;&#123;this.props.value&#125;&lt;/Text&gt;</span><br><span class="line">                &lt;TouchableOpacity style=&#123;styles.button&#125; activeOpacity = &#123;.9&#125; onPress=&#123;() =&gt; &#123;</span><br><span class="line">                  this.props.increment(this.state.num)</span><br><span class="line">                &#125;&#125;&gt;</span><br><span class="line">                  &lt;Text style=&#123;styles.buttonText&#125;&gt;+&lt;/Text&gt;</span><br><span class="line">                &lt;/TouchableOpacity&gt;</span><br><span class="line">              &lt;/View&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">          &lt;/SafeAreaView&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    value: state.count.value,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapDispatchToProps(dispatch) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    increment: (num) =&gt; dispatch(incrementAction(num)),</span><br><span class="line">    decrement: (num) =&gt; dispatch(decrementAction(num)),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(App);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的<code>TextInput</code>用于输入每次增加或者减小的数值，下面有一个加号按钮和一个减号按钮，中间是显示当前数值的文本。</p><p><code>mapStateToProps</code>和<code>mapDispatchToProps</code>，的作用是映射<strong>Slice</strong>中定义的<code>State</code>和<code>Action</code>到当前页面，在使用时直接<code>this.props.value</code>调用即可。最后通过<strong>Redux</strong>的<code>connect</code>方法将这些映射和当前页的组件连接起来。</p><p>本文的<strong>Demo</strong>可以在<a href="https://github.com/zephyrw/redux_example">这里</a>查看。</p><p>以上就是<code>Redux</code>的入门教程，想深入了解<code>Redux</code>的使用可以参考<a href="https://redux.js.org/introduction/getting-started">Redux官方文档</a>，想进一步了解<code>Redux Toolkit</code>可以参考<a href="https://redux-toolkit.js.org/introduction/quick-start">Redux Tookit官方文档</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Redux定义&quot;&gt;&lt;a href=&quot;#Redux定义&quot; class=&quot;headerlink&quot; title=&quot;Redux定义&quot;&gt;&lt;/a&gt;Redux定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Redux&lt;/strong&gt;在&lt;a href=&quot;https://redux.js.org/&quot;&gt;官网&lt;/a&gt;上是这么定义的：&lt;strong&gt;A Predictable State Container for JS Apps&lt;/strong&gt;，直译过来就是一个使用在JS应用上的可预测的状态容器。&lt;/p&gt;
&lt;h2 id=&quot;Redux解决的问题&quot;&gt;&lt;a href=&quot;#Redux解决的问题&quot; class=&quot;headerlink&quot; title=&quot;Redux解决的问题&quot;&gt;&lt;/a&gt;Redux解决的问题&lt;/h2&gt;&lt;p&gt;&lt;code&gt;React Native&lt;/code&gt;本身是基于前端的&lt;code&gt;React&lt;/code&gt;框架，它是通过&lt;code&gt;State&lt;/code&gt;来管理页面显示和参数更新。如果在交互比较复杂的页面、需要多页面状态传递或者同步更新状态的情况，状态管理就会比较麻烦。使用&lt;code&gt;Redux&lt;/code&gt;就可以解决这些问题。&lt;/p&gt;
&lt;h2 id=&quot;Redux的核心逻辑和概念&quot;&gt;&lt;a href=&quot;#Redux的核心逻辑和概念&quot; class=&quot;headerlink&quot; title=&quot;Redux的核心逻辑和概念&quot;&gt;&lt;/a&gt;Redux的核心逻辑和概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Redux&lt;/strong&gt;的核心逻辑是集中定义和管理状态和动作执行，各个页面使用&lt;code&gt;connect&lt;/code&gt;方法绑定相应的方法和状态，并通过发送动作指令更新页面显示。达到状态和操作与页面隔离的效果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="React Native" scheme="http://anye3210.github.io/tags/React-Native/"/>
    
    <category term="React" scheme="http://anye3210.github.io/tags/React/"/>
    
    <category term="Redux" scheme="http://anye3210.github.io/tags/Redux/"/>
    
    <category term="Thunk" scheme="http://anye3210.github.io/tags/Thunk/"/>
    
  </entry>
  
  <entry>
    <title>【React Native】React Navigation 5.x的使用</title>
    <link href="http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91React-Navigation%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91React-Navigation%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-08-03T13:29:05.000Z</published>
    <updated>2021-08-22T07:28:29.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在App中，底部<code>TabBar</code>导航和顶部的导航栏导航是最常见的页面导航方式，而<strong>React Native</strong>官方推荐的第三方库是<code>@react-navigation</code>，正好今年<code>React Navigation</code>发布了5.0版本，与前面的版本差别还挺大，不过使用上更方便了。本文主要讲解<code>React Navigation</code>5.0及以上版本的使用。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装核心包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># NPM</span><br><span class="line">npm install @react-navigation/native</span><br><span class="line"># Yarn</span><br><span class="line">yarn add @react-navigation/native</span><br></pre></td></tr></table></figure><span id="more"></span><p>安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># NPM</span><br><span class="line">npm install react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view</span><br><span class="line">#Yarn</span><br><span class="line">yarn add react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>React Native</strong> 0.60及以上版本是自动链接库的，不需要手动运行<code>react-native link</code>，但如果你用<strong>React Native</strong>开发的是iOS，还需要手动安装<code>pods</code>来完成库的链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx pod-install ios</span><br></pre></td></tr></table></figure><p>把下面这行代码放在入口文件的顶部，比如<code>index.js</code>或者<code>App.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;react-native-gesture-handler&#x27;;</span><br></pre></td></tr></table></figure><p>最后需要用<code>NavigationContainer</code>将整个App包裹起来，这个代码一般也是放在入口文件，类似下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;react-native-gesture-handler&#x27;;</span><br><span class="line">import * as React from &#x27;react&#x27;;</span><br><span class="line">import &#123; NavigationContainer &#125; from &#x27;@react-navigation/native&#x27;;</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;NavigationContainer&gt;&#123;/* Rest of your app code */&#125;&lt;/NavigationContainer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果你同时也使用了<strong>Redux</strong>框架，需要把<code>Provider</code>放在最外层，将<code>NavigationContainer</code>包裹在次外层，类似下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default class App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;NavigationContainer&gt;</span><br><span class="line">        &#123;/* Screen configuration */&#125;</span><br><span class="line">      &lt;/NavigationContainer&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>React Navigation</strong>有多种导航方式：<code>Stack Navigation</code>、<code>Tab Navigation</code>和<code>Drawer Navigation</code>。这里主要讲<code>Stack Navigation</code>和<code>Tab Navigation</code>。</p><h3 id="顶部导航栏导航"><a href="#顶部导航栏导航" class="headerlink" title="顶部导航栏导航"></a>顶部导航栏导航</h3><p>首先需要安装相应的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#NPM</span><br><span class="line">npm install @react-navigation/stack</span><br><span class="line">#Yarn</span><br><span class="line">yarn add @react-navigation/stack</span><br></pre></td></tr></table></figure><p><code>Stack Navigation</code>使用上相对来说比较简单，只需要把需要导航的页面组件封装成<code>Stack.Screen</code>，然后包裹在<code>Stack.Navigator</code>就可以了，最上面的<code>Stack.Screen</code>就是默认页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &#x27;react&#x27;;</span><br><span class="line">import &#123; NavigationContainer &#125; from &#x27;@react-navigation/native&#x27;;</span><br><span class="line">import &#123; createStackNavigator &#125; from &#x27;@react-navigation/stack&#x27;;</span><br><span class="line"></span><br><span class="line">const Stack = createStackNavigator();</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;NavigationContainer&gt;</span><br><span class="line">      &lt;Stack.Navigator&gt;</span><br><span class="line">        &lt;Stack.Screen key=&quot;Home&quot; name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt;</span><br><span class="line">      &lt;/Stack.Navigator&gt;</span><br><span class="line">      &lt;Stack.Screen key=&quot;detail&quot; name=&quot;Detail&quot; component=&#123;DetailScreen&#125; /&gt;</span><br><span class="line">      &lt;/Stack.Navigator&gt;</span><br><span class="line">    &lt;/NavigationContainer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以在<code>Stack.Screen</code>中设置导航栏的属性，设置导航栏属性<code>options</code>有两种方式，一种是带<code>route</code>参数的，一种是直接设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/* 带route参数的options */</span><br><span class="line">&lt;Stack.Screen</span><br><span class="line">    key=&#123;name&#125;</span><br><span class="line">    name=&#123;name&#125;</span><br><span class="line">    component=&#123;component&#125;</span><br><span class="line">    options=&#123;(&#123;route&#125;) =&gt; (&#123;</span><br><span class="line">        headerTitle: route.name,</span><br><span class="line">        headerStyle: &#123;</span><br><span class="line">            backgroundColor: &#x27;#01aaff&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        headerTintColor: &#x27;#fff&#x27;,</span><br><span class="line">        headerTitleStyle: &#123;</span><br><span class="line">            fontWeight: &#x27;bold&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        headerRight: () =&gt; (</span><br><span class="line">            &lt;Button</span><br><span class="line">              onPress=&#123;() =&gt; alert(&#x27;This is a button!&#x27;)&#125;</span><br><span class="line">              title=&quot;Info&quot;</span><br><span class="line">              color=&quot;#fff&quot;</span><br><span class="line">            /&gt;</span><br><span class="line">          ),</span><br><span class="line">        headerShown: true</span><br><span class="line">    &#125;)&#125;</span><br><span class="line">/&gt;</span><br><span class="line">/* 直接设置options */</span><br><span class="line">&lt;Stack.Screen</span><br><span class="line">    key=&#123;name&#125;</span><br><span class="line">    name=&#123;name&#125;</span><br><span class="line">    component=&#123;component&#125;</span><br><span class="line">    options=&#123;&#123;</span><br><span class="line">        headerTitle: &#x27;name&#x27;,</span><br><span class="line">        headerStyle: &#123;</span><br><span class="line">            backgroundColor: &#x27;#01aaff&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        headerTintColor: &#x27;#fff&#x27;,</span><br><span class="line">        headerTitleStyle: &#123;</span><br><span class="line">            fontWeight: &#x27;bold&#x27;,</span><br><span class="line">        &#125;,</span><br><span class="line">        headerRight: () =&gt; (</span><br><span class="line">            &lt;Button</span><br><span class="line">              onPress=&#123;() =&gt; alert(&#x27;This is a button!&#x27;)&#125;</span><br><span class="line">              title=&quot;Info&quot;</span><br><span class="line">              color=&quot;#fff&quot;</span><br><span class="line">            /&gt;</span><br><span class="line">          ),</span><br><span class="line">        headerShown: true</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <strong>React</strong>框架使用的是虚拟<code>DOM</code>，使用<code>diff</code>算法刷新页面显示，在<code>Stack.Screen</code>中，需要添加<code>key</code>属性，否则会报警告。</p><p>在需要跳转到其他页面时只需要以下代码就可以了，后面跟的是参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function HomeScreen(&#123; navigation &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;View style=&#123;&#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27; &#125;&#125;&gt;</span><br><span class="line">      &lt;Text&gt;Home Screen&lt;/Text&gt;</span><br><span class="line">      &lt;Button</span><br><span class="line">        title=&quot;Go to Details&quot;</span><br><span class="line">        onPress=&#123;() =&gt; &#123;</span><br><span class="line">          /* 1. Navigate to the Details route with params */</span><br><span class="line">          navigation.navigate(&#x27;Details&#x27;, &#123;</span><br><span class="line">            itemId: 86,</span><br><span class="line">            otherParam: &#x27;anything you want here&#x27;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/View&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是用<code>class</code>方式创建的页面，代码会像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default class HomeScreen extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;&#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27; &#125;&#125;&gt;</span><br><span class="line">                &lt;Text&gt;Home Screen&lt;/Text&gt;</span><br><span class="line">                &lt;Button</span><br><span class="line">                    title=&quot;Go to Details&quot;</span><br><span class="line">                    onPress=&#123;() =&gt; &#123;</span><br><span class="line">                        this.props.navigation.navigate(&#x27;Details&#x27;, &#123;</span><br><span class="line">                            itemId: 86,</span><br><span class="line">                            otherParam: &#x27;anything you want here&#x27;,</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 导航跳转可以使用<code>navigation.navigate</code>或者<code>navigation.push</code>。如果使用<code>navigate</code>，会查找当前堆栈中是否有名字一样的路由，如果没有才创建新的路由并跳转，而<code>push</code>则会直接创建一个新的路由并跳转，也就是说可以重复多次跳转同一个页面。</p><p>堆栈导航的返回方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回到上一页面</span><br><span class="line">navigation.goBack()</span><br><span class="line">// 返回到堆栈里第一个页面</span><br><span class="line">navigation.popToPop()</span><br></pre></td></tr></table></figure><h3 id="底部导航栏导航"><a href="#底部导航栏导航" class="headerlink" title="底部导航栏导航"></a>底部导航栏导航</h3><p>除了顶部导航栏，最常用的就是底部导航栏了，首先也需要安装相应的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># NPM</span><br><span class="line">npm install @react-navigation/bottom-tabs</span><br><span class="line"># Yarn</span><br><span class="line">yarn add @react-navigation/bottom-tabs</span><br></pre></td></tr></table></figure><p>底部导航栏的使用方法类似，需要将这些页面组件包装成<code>Tab.Screen</code>，导航则由框架内部完成，不需要手动控制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &#x27;react&#x27;;</span><br><span class="line">import &#123; NavigationContainer &#125; from &#x27;@react-navigation/native&#x27;;</span><br><span class="line">import &#123; createBottomTabNavigator &#125; from &#x27;@react-navigation/bottom-tabs&#x27;;</span><br><span class="line"></span><br><span class="line">const Tab = createBottomTabNavigator();</span><br><span class="line"></span><br><span class="line">export default function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;NavigationContainer&gt;</span><br><span class="line">      &lt;Tab.Navigator&gt;</span><br><span class="line">        &lt;Tab.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt;</span><br><span class="line">        &lt;Tab.Screen name=&quot;Settings&quot; component=&#123;SettingsScreen&#125; /&gt;</span><br><span class="line">      &lt;/Tab.Navigator&gt;</span><br><span class="line">    &lt;/NavigationContainer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底部导航栏属性可以按如下方式设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;Tab.Navigator</span><br><span class="line">        screenOptions=&#123;(&#123; route &#125;) =&gt; (&#123;</span><br><span class="line">          tabBarIcon: (&#123; focused, color, size &#125;) =&gt; &#123;</span><br><span class="line">            let iconName;</span><br><span class="line"></span><br><span class="line">            if (route.name === &#x27;Home&#x27;) &#123;</span><br><span class="line">              iconName = focused</span><br><span class="line">                ? &#x27;ios-information-circle&#x27;</span><br><span class="line">                : &#x27;ios-information-circle-outline&#x27;;</span><br><span class="line">            &#125; else if (route.name === &#x27;Settings&#x27;) &#123;</span><br><span class="line">              iconName = focused ? &#x27;ios-list-box&#x27; : &#x27;ios-list&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            return &lt;Ionicons name=&#123;iconName&#125; size=&#123;size&#125; color=&#123;color&#125; /&gt;;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">        tabBarOptions=&#123;&#123;</span><br><span class="line">          activeTintColor: &#x27;tomato&#x27;,</span><br><span class="line">          inactiveTintColor: &#x27;gray&#x27;,</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;Tab.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt;</span><br><span class="line">        &lt;Tab.Screen name=&quot;Settings&quot; component=&#123;SettingsScreen&#125; /&gt;</span><br><span class="line">      &lt;/Tab.Navigator&gt;</span><br></pre></td></tr></table></figure><h3 id="顶部堆栈导航栏与底部导航栏嵌套"><a href="#顶部堆栈导航栏与底部导航栏嵌套" class="headerlink" title="顶部堆栈导航栏与底部导航栏嵌套"></a>顶部堆栈导航栏与底部导航栏嵌套</h3><p><code>Stack Navigation</code>和<code>Tab Navigation</code>可以相互多层嵌套，比如登录页跳转到带底部导航栏的主页面，需要把登录相关面和<code>Tab.navigator</code>一同放到同一个堆栈中，但官方不推荐这种方式，嵌套层次太多会导致维护起来特别麻烦。官方推荐使用一个变量控制当前显示的页面，把不相关的模块隔离在不同的堆栈中，类似下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const commonScreens = &#123;</span><br><span class="line">  Help: HelpScreen,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const authScreens = &#123;</span><br><span class="line">  SignIn: SignInScreen,</span><br><span class="line">  SignUp: SignUpScreen,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const userScreens = &#123;</span><br><span class="line">  Home: HomeScreen,</span><br><span class="line">  Profile: ProfileScreen,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;Stack.Navigator&gt;</span><br><span class="line">  &#123;Object.entries(&#123;</span><br><span class="line">    ...commonScreens,</span><br><span class="line">    ...(isLoggedIn ? userScreens : authScreens),</span><br><span class="line">  &#125;).map(([name, component]) =&gt; (</span><br><span class="line">    &lt;Stack.Screen name=&#123;name&#125; component=&#123;component&#125; /&gt;</span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;/Stack.Navigator&gt;;</span><br></pre></td></tr></table></figure><p>像<code>isLoggedIn</code>这样的全局变量动态刷新页面使用<strong>Redux</strong>架构实现起来会简单一些，具体实现可以参考<a href="">这篇教程</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在App中，底部&lt;code&gt;TabBar&lt;/code&gt;导航和顶部的导航栏导航是最常见的页面导航方式，而&lt;strong&gt;React Native&lt;/strong&gt;官方推荐的第三方库是&lt;code&gt;@react-navigation&lt;/code&gt;，正好今年&lt;code&gt;React Navigation&lt;/code&gt;发布了5.0版本，与前面的版本差别还挺大，不过使用上更方便了。本文主要讲解&lt;code&gt;React Navigation&lt;/code&gt;5.0及以上版本的使用。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;安装核心包&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# NPM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install @react-navigation/native&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Yarn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yarn add @react-navigation/native&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="React Native" scheme="http://anye3210.github.io/tags/React-Native/"/>
    
    <category term="React" scheme="http://anye3210.github.io/tags/React/"/>
    
    <category term="Navigation" scheme="http://anye3210.github.io/tags/Navigation/"/>
    
  </entry>
  
  <entry>
    <title>【React Native】AES+Base64加密</title>
    <link href="http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91AES%E5%8A%A0%E5%AF%86/"/>
    <id>http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91AES%E5%8A%A0%E5%AF%86/</id>
    <published>2020-08-03T12:31:27.000Z</published>
    <updated>2021-08-22T07:29:53.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在移动端App开发中，<strong>AES</strong>加密非常常用，本文主要讲解如何在<code>React Native</code>中封装自己的<strong>AES</strong>加密工具类及会遇到的坑。这里的<strong>AES</strong>加密是基于前端常用的加密库**<code>crypto-js</code>**。</p><h2 id="安装crypto-js"><a href="#安装crypto-js" class="headerlink" title="安装crypto-js"></a>安装crypto-js</h2><p>使用<strong>NPM</strong>或者<strong>Yarn</strong>安装<code>crypto-js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># NPM</span><br><span class="line">npm install crypto-js</span><br><span class="line"># Yarn</span><br><span class="line">yarn add crypto-js</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>使用<code>crypto-js</code><strong>4.0.0</strong>及以上的版本会报找不到Crypto.js的错，这可能是新版本的Bug，需要在<code>package.json</code>中找到<code>crypto-js</code>并把版本号指定为<code>^3.3.0</code>(与3.3.0版本兼容，相当于3.X.X, 即&gt;=3.3.0 &lt; 4.0.0,不改变大版本号)，然后重新执行<code>npm install</code>：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;crypto-js&quot;: &quot;^3.3.0&quot;,   //</span><br></pre></td></tr></table></figure><h2 id="创建加密工具类"><a href="#创建加密工具类" class="headerlink" title="创建加密工具类"></a>创建加密工具类</h2><p>新建<code>AESTool.js</code>文件，添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import CryptoJS from &#x27;crypto-js&#x27;</span><br><span class="line"></span><br><span class="line">const key = CryptoJS.enc.Utf8.parse(&#x27;abcdef0123456789&#x27;);</span><br><span class="line">const iv = CryptoJS.enc.Utf8.parse(&quot;0123456789abcdef&quot;);</span><br><span class="line"></span><br><span class="line">export const AESTool = &#123;</span><br><span class="line"></span><br><span class="line">    encrypt: (message) =&gt; &#123;</span><br><span class="line">        let sendData = CryptoJS.enc.Utf8.parse(message);</span><br><span class="line">        let encrypted =CryptoJS.AES.encrypt(sendData,key,&#123;</span><br><span class="line">            iv: iv,</span><br><span class="line">            mode:CryptoJS.mode.CBC,</span><br><span class="line">            padding:CryptoJS.pad.Pkcs7</span><br><span class="line">        &#125;);</span><br><span class="line">        return encrypted.toString(); //Base64字符串</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    decrypt: (message) =&gt; &#123;</span><br><span class="line">        let decrypt = CryptoJS.AES.decrypt(message, key, &#123;</span><br><span class="line">            iv: iv,</span><br><span class="line">            mode: CryptoJS.mode.CBC,</span><br><span class="line">            padding: CryptoJS.pad.Pkcs7</span><br><span class="line">        &#125;);</span><br><span class="line">        return decrypt.toString(CryptoJS.enc.Utf8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用的是<code>CBC</code>加密模式，使用了<code>Pkcs7</code>补码方式。需要注意的是加密方法里传的明文、偏移量、密钥等参数都需要使用<code>CryptoJS.enc.Utf8.parse()</code>方法解析之后使用。</p><p><strong>注意：</strong>这里<code>CryptoJS</code>加密后的字符串就是<code>Base64</code>编码的，不需要重复进行Base64编码。解密的时候也直接传<code>Base64</code>字符串即可。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在移动端App开发中，&lt;strong&gt;AES&lt;/strong&gt;加密非常常用，本文主要讲解如何在&lt;code&gt;React Native&lt;/code&gt;中封装自己的&lt;strong&gt;AES&lt;/strong&gt;加密工具类及会遇到的坑。这里的&lt;strong&gt;AES&lt;/strong&gt;加密是基于前端常用的加密库**&lt;code&gt;crypto-js&lt;/code&gt;**。&lt;/p&gt;
&lt;h2 id=&quot;安装crypto-js&quot;&gt;&lt;a href=&quot;#安装crypto-js&quot; class=&quot;headerlink&quot; title=&quot;安装crypto-js&quot;&gt;&lt;/a&gt;安装crypto-js&lt;/h2&gt;&lt;p&gt;使用&lt;strong&gt;NPM&lt;/strong&gt;或者&lt;strong&gt;Yarn&lt;/strong&gt;安装&lt;code&gt;crypto-js&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# NPM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install crypto-js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Yarn&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yarn add crypto-js&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;使用&lt;code&gt;crypto-js&lt;/code&gt;&lt;strong&gt;4.0.0&lt;/strong&gt;及以上的版本会报找不到Crypto.js的错，这可能是新版本的Bug，需要在&lt;code&gt;package.json&lt;/code&gt;中找到&lt;code&gt;crypto-js&lt;/code&gt;并把版本号指定为&lt;code&gt;^3.3.0&lt;/code&gt;(与3.3.0版本兼容，相当于3.X.X, 即&amp;gt;=3.3.0 &amp;lt; 4.0.0,不改变大版本号)，然后重新执行&lt;code&gt;npm install&lt;/code&gt;：&lt;/p&gt;</summary>
    
    
    
    
    <category term="React Native" scheme="http://anye3210.github.io/tags/React-Native/"/>
    
    <category term="AES" scheme="http://anye3210.github.io/tags/AES/"/>
    
    <category term="React" scheme="http://anye3210.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins+fir/蒲公英持续集成iOS项目(优化版)</title>
    <link href="http://anye3210.github.io/2020/01/19/%E4%BD%BF%E7%94%A8Jenkins+%E8%92%B2%E5%85%AC%E8%8B%B1:fir%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9B%86%E6%88%90iOS%E9%A1%B9%E7%9B%AE-%E4%BC%98%E5%8C%96%E7%89%88/"/>
    <id>http://anye3210.github.io/2020/01/19/%E4%BD%BF%E7%94%A8Jenkins+%E8%92%B2%E5%85%AC%E8%8B%B1:fir%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9B%86%E6%88%90iOS%E9%A1%B9%E7%9B%AE-%E4%BC%98%E5%8C%96%E7%89%88/</id>
    <published>2020-01-19T15:47:32.000Z</published>
    <updated>2021-08-22T07:31:16.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在持续集成领域，<strong>Jenkins</strong>绝对是一个神兵利器，它的插件库非常丰富，我们可以使用它代替执行很多工作中常见的繁琐重复的工作，减少我们在开发之外的不必要的时间花费，从而提高我们的开发效率。在iOS开发中，最常见的就是自动化打包。</p><p>我在最初开始接触使用<strong>Jenkins</strong>的过程中，参考了大量的<strong>Jenkins</strong>的安装使用教程，发现各有优势，但其中也有很多坑和不合理的地方。通过自己大量的使用、研究和优化，总结了这篇优化版的自动化打包教程。</p><p>在安装和使用<strong>Jenkins</strong>的过程中，很多步骤都会有几种方式实现，本文只详细讲解个人认为比较好的方式。</p><span id="more"></span><h1 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h1><p><strong>Jenkins</strong>的安装分为两类，一种是安装包安装，一种是使用<strong>Homebrew</strong>安装，推荐使用<strong>Homebrew</strong>进行安装。</p><p>安装前请确保系统已经安装了<strong>Homebrew</strong>，否则请前往<a href="https://brew.sh/index_zh-cn">Homebrew官网</a>按照提示自行安装。</p><p>打开终端安装<strong>Jenkins</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><p>下面安装完成后日常使用经常会用到的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew services start jenkins // 启动Jenkins</span><br><span class="line">brew services restart jenkins // 重启Jenkins</span><br><span class="line">brew services stop jenkins // 停用Jenkins</span><br></pre></td></tr></table></figure><p>上述命令执行后<strong>Jenkins</strong>都是在后台运行，如果不想使用后台运行<strong>Jenkins</strong>服务，可以直接在终端输入<code>jenkins</code>以日志的方式运行。</p><p><strong>Jenkins</strong>默认会使用8080端口，可以使用以下命令自己更换（不建议）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default write /Library/Preferences/org.jenkins-ci httpPort xxxx // xxxx为更换后的端口号</span><br></pre></td></tr></table></figure><h1 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h1><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>用浏览器打开<code>http://localhost:8080</code>，首次进入需要输入密码以解锁<strong>Jenkins</strong></p><p><img src="https://i.loli.net/2020/01/19/c3R7Lk65zaowYnb.png" alt="unlock_jenkins.png"></p><p>使用<code>cat</code>命令按页面上的提示的路径在终端输入以下命令在终端打印密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /Users/用户名/.jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><p>输入密码登录成功后点击<strong>Install suggested plugins</strong>按钮安装插件，等待安装完成。</p><p><img src="https://i.loli.net/2020/01/19/6EReO4X7CYNoIGq.png" alt="install_plugins.png"></p><p>部分插件可能会安装失败，可以选择现点<strong>Retry</strong>重新安装，也可以选择继续，后面再来安装这些安装失败的插件。</p><p><img src="https://i.loli.net/2020/01/19/JMS5GK3hTC1XiI6.png" alt="retry_plugins.png"></p><p>点继续之后会进入到创建用户页面，建议在这里创建用户。如果不创建每次进入都要输入初始密码，比较麻烦。</p><p><img src="https://i.loli.net/2020/01/19/CRvLnT2zk46lJIw.png" alt="create_user.png"></p><p>点击保存会显示以下界面，点击<strong>Start using jenkins</strong>按钮进入到管理页面。</p><p><img src="https://i.loli.net/2020/01/19/C3hOWlXbHMsc6Ke.jpg" alt="jenkins_is_ready.jpg"></p><h2 id="配置iOS自动化打包"><a href="#配置iOS自动化打包" class="headerlink" title="配置iOS自动化打包"></a>配置iOS自动化打包</h2><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>自动化打包需要安装以下插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Keychains and Provisioning Profiles Management</span><br><span class="line">CocoaPods Jenkins Integration</span><br><span class="line">Build Timeout</span><br><span class="line">SSH Agent Plugin</span><br><span class="line">WorkSpace Cleanup Plugin</span><br></pre></td></tr></table></figure><p>选择<code>Manage Jenkins-&gt;Manage Plugins-&gt;已安装</code>，在右上角过滤里面搜索，查看插件是否已安装，如果没有需要在可选插件里搜索并安装</p><p><img src="https://i.loli.net/2020/01/19/SOVHZnwxYXtgi9U.png" alt="manage_plugins.png"><br><img src="https://i.loli.net/2020/01/19/R3MpSkzYDis98hd.png" alt="installed_plugins.png"></p><p>如果想打包完成后自动发送邮件，需要安装<code>Email Extension Plugin</code>插件。</p><p>如果想将<strong>Jenkins</strong>的显示语言更改为中文，需要安装<code>Localization: Chinese (Simplified)</code>插件，重启之后生效。</p><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>iOS自动化打包需要使用到<code>cocoapods</code>、<code>XCPretty</code>、<code>xcbuild</code>等工具，如果想直接在脚本中使用不带路径的相关命令，就需要先添加全局变量。</p><p>打开<code>Manage Jenkins-&gt;Configure System</code></p><p><img src="https://i.loli.net/2020/01/19/CZzJu3MsWGOLB1f.png" alt="configure_system.png"></p><p>页面滚动到全局属性一栏，添加以下几个键值对，前面三个为全局语言编码，最后一个为全局路径，它的值可以通过在终端输入<code>$PATH</code>获取到</p><p><img src="https://i.loli.net/2020/01/19/jhKJmwDBl1ZRsbg.png" alt="environment_variables.png"></p><h3 id="证书和描述文件配置"><a href="#证书和描述文件配置" class="headerlink" title="证书和描述文件配置"></a>证书和描述文件配置</h3><p>接下来我们需要上传钥匙串和描述文件，在上传之前需要一些准备工作。</p><p>打开电脑的<code>钥匙串访问</code>应用，进入后鼠标悬停在<code>登录</code>按钮上方会自动显示登录钥匙串的路径</p><p><img src="https://i.loli.net/2020/01/19/aOYTdszE74CSBQH.jpg" alt="login_keychain.jpg"></p><p>打开终端，输入以下命令将钥匙串从上图所示的路径中复制出来存放到桌面并将文件后缀里的<code>-db</code>去掉（<strong>Jenkins</strong>上传钥匙串时文件必须以.keychain结尾）。这样，钥匙串就准备好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /Users/用户名/Library/Keychains/login.keychain-db ~/Desktop/login.keychain </span><br></pre></td></tr></table></figure><p>描述文件如果有就用现成的，如果没有，就上开发者网站生成和下载一个，具体流程如果不了解可以自行上网搜索，这里就赘述了。（注意：描述文件上传前先将iOS工程的证书管理设置为手动模式，将描述文件导入进入看一下是否能用，避免后面发现不能用来回折腾）</p><p>接下来就是正式上传。</p><p>打开<code>Manage Jenkins-&gt;Keychains and Provisioning Profiles Management</code></p><p><img src="https://i.loli.net/2020/01/19/PsW78fEQVeZ3ltb.png" alt="keychains_and_provising_profiles_management.png"></p><p>点击<code>选择文件</code>，选择刚准备好的<code>login.keychain</code>，然后点<code>Upload</code></p><p><img src="https://i.loli.net/2020/01/19/xz7eUHBNSyTID5P.png" alt="upload_keychain.png"></p><p>钥匙串上传完成成显示如下</p><p><img src="https://i.loli.net/2020/01/19/wbVNOnaFou9pLP1.png" alt="login_keychain_uploaded.png"></p><p>点击下方的<code>Add Code Signing Identity</code>将项目相关的证书名称添加进去，这个名称点击该证书在钥匙串应用上方就会有显示，复制粘贴即可</p><p><img src="https://i.loli.net/2020/01/19/eBogLtkhVlJFTON.png" alt="cert_name.png"></p><p>添加完成后效果如下</p><p><img src="https://i.loli.net/2020/01/19/hwBlK5TG9mQ3gzE.png" alt="finish_add_cert_name.png"></p><p>接下来用同样的方法上传证书的描述文件，并在<code>Provisioning Profiles Directory Path</code>一栏填写描述文件地址<code>/Users/用户名/Library/MobileDevice/Provisioning Profiles</code>，完成后如下图所示</p><p><img src="https://i.loli.net/2020/01/19/L83Un2lVQtDWbNr.png" alt="finish_upload_provising_profiles.png"></p><p>点击保存，证书和描述文件就完成了。</p><h3 id="新建和配置自动化打包任务"><a href="#新建和配置自动化打包任务" class="headerlink" title="新建和配置自动化打包任务"></a>新建和配置自动化打包任务</h3><p>在<strong>Jenkins</strong>首页点击<code>新建Item</code></p><p><img src="https://i.loli.net/2020/01/19/N4X63MxcmdWYwPr.png" alt=" new_item.png"></p><p>为任务起一个名称，选择下面的<code>Freestyle project</code>，然后点确定</p><p><img src="https://i.loli.net/2020/01/19/YWdTLEur68j92J3.png" alt="freestyle_project.png"></p><p>这时候会自动跳转到项目配置界面，在这个界面需要配置三个地方：</p><ul><li>源码管理</li><li>构建环境里的<code>Mobile Provisioning Profiles</code></li><li>构建里的运行脚本</li></ul><p>首先是源码管理部分，这里有两种方式进行管理，一种是Git，一种是Subversion，这里主要讲解Git方式。</p><p>在<code>Repository URL</code>栏填入项目源码的仓库地址，在下方<code>Credentials</code>栏的凭据选择默认是空的，选择添加，添加完凭据就可以选择了。指定分支栏填入相应分支，默认为<code>master</code>分支。</p><p><img src="https://i.loli.net/2020/01/19/JMvsed64IQpO8tV.png" alt="repositories.png"></p><p>构建环境部分配置比较简单，勾选<code>Mobile Provisioning Profiles</code>选项并选择之前上传的描述文件即可。</p><p><img src="https://i.loli.net/2020/01/19/tP8gpMDXV2nfFrH.png" alt="mobile_provisioning_profiles.png"></p><p>接下来就是最重要的构建脚本了。</p><p>在添加脚本以前，需要先把打包需要的<code>ExportOptions.plist</code>准备好，这个文件需要自己手动打包一次，在导出<code>IPA</code>文件后在与<code>.ipa</code>同在的文件夹中可以找到。可以把它放在源码中，也可以放在电脑的某个位置，这个路径在下面的打包脚本中需要用到。（<strong>注意：如果后期修改了打包方式、证书或者描述文件，一定要同步修改该plist文件对应的值，否则打包会报错</strong>）</p><p>准备好<code>.plist</code>文件之后就可以添加脚本了。</p><p>在<code>构建</code>中的<code>增加构建步骤</code>里选择<code>Execute shell</code>添加构建脚本。</p><p><img src="https://i.loli.net/2020/01/19/2bjC9xcAmvGp7gP.png" alt="execute_shell.png"></p><p>在脚本输入框添加以下内容，这个脚本是打包脚本，这个版本已经优化并适配最新版本的<code>XCode 11</code>，使用时需要将里面的xxx替换为你自己项目的名称或用户名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">cd $WORKSPACE</span><br><span class="line"></span><br><span class="line"># 计时</span><br><span class="line">SECONDS=0</span><br><span class="line"># 是否编译工作空间 (例:若是用Cocopods管理的.xcworkspace项目,赋值true;用Xcode默认创建的.xcodeproj,赋值false)</span><br><span class="line">is_workspace=&quot;true&quot;</span><br><span class="line"></span><br><span class="line"># 指定项目的scheme名称</span><br><span class="line"># (注意: 因为shell定义变量时,=号两边不能留空格,若scheme_name与info_plist_name有空格,脚本运行会失败)</span><br><span class="line">scheme_name=&quot;xxx&quot;</span><br><span class="line"></span><br><span class="line"># 工程中Target对应的配置plist文件名称, Xcode默认的配置文件为Info.plist</span><br><span class="line">info_plist_name=&quot;Info&quot;</span><br><span class="line"></span><br><span class="line"># 指定要打包编译的方式 : Release,Debug...</span><br><span class="line">build_configuration=&quot;Release&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ===============================自动打包部分(如果Info.plist文件位置有变动需要修改&quot;info_plist_path&quot;)============================= #</span><br><span class="line"></span><br><span class="line"># 导出ipa所需要的plist文件路径，这个路径为之前存放ExportOptions.plist的路径，如果放在源码工程文件的根目录，直接填文件名即可。</span><br><span class="line">ExportOptionsPlistPath=&quot;/Users/xxx/ExportOptions.plist&quot;</span><br><span class="line"></span><br><span class="line"># 获取项目名称</span><br><span class="line">project_name=`find . -name *.xcodeproj | awk -F &quot;[/.]&quot; &#x27;&#123;print $(NF-1)&#125;&#x27;`</span><br><span class="line"></span><br><span class="line"># 获取Info.plist路径，拿到版本号, 编译版本号, BundleID</span><br><span class="line">info_plist_path=&quot;$project_name/$info_plist_name.plist&quot;</span><br><span class="line">bundle_version=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $info_plist_path`</span><br><span class="line">bundle_build_version=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $info_plist_path`</span><br><span class="line">bundle_identifier=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleIdentifier&quot; $info_plist_path`</span><br><span class="line"></span><br><span class="line">#时间戳</span><br><span class="line">formattedDate=$(date &quot;+%Y-%m-%d#%H:%M:%S&quot;)</span><br><span class="line"></span><br><span class="line"># 指定输出ipa名称 : scheme_name + bundle_version</span><br><span class="line">ipa_name=&quot;$scheme_name$formattedDate&quot;</span><br><span class="line"></span><br><span class="line"># 删除旧.xcarchive文件</span><br><span class="line">rm -rf ~/Documents/IPA/$scheme_name-IPA/$scheme_name.xcarchive</span><br><span class="line"></span><br><span class="line"># 指定输出ipa路径</span><br><span class="line">export_path=~/Documents/IPA/$scheme_name/$ipa_name</span><br><span class="line"></span><br><span class="line"># 指定输出归档文件地址</span><br><span class="line">export_archive_path=&quot;$export_path/$ipa_name.xcarchive&quot;</span><br><span class="line"></span><br><span class="line"># 指定输出ipa地址</span><br><span class="line">export_ipa_path=&quot;$export_path&quot;</span><br><span class="line"></span><br><span class="line"># 四种打包方式: AdHoc、AppStore、Enterprise和Development</span><br><span class="line">method=&quot;AdHoc&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;\033[*************************  开始构建项目  *************************]\033&quot;</span><br><span class="line"># 指定输出文件目录不存在则创建</span><br><span class="line">if [ -d &quot;$export_path&quot; ] ; then</span><br><span class="line">echo $export_path</span><br><span class="line">else</span><br><span class="line">mkdir -pv $export_path</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 判断编译的项目类型是workspace还是project</span><br><span class="line">if $is_workspace ; then</span><br><span class="line"></span><br><span class="line"># 安装第三方库</span><br><span class="line">pod install --verbose --no-repo-update</span><br><span class="line"></span><br><span class="line"># 编译前清理工程</span><br><span class="line">xcodebuild clean -workspace $&#123;project_name&#125;.xcworkspace \</span><br><span class="line">                 -scheme $&#123;scheme_name&#125; \</span><br><span class="line">                 -configuration $&#123;build_configuration&#125;</span><br><span class="line"></span><br><span class="line">xcodebuild archive -workspace $&#123;project_name&#125;.xcworkspace \</span><br><span class="line">                   -scheme $&#123;scheme_name&#125; \</span><br><span class="line">                   -configuration $&#123;build_configuration&#125; \</span><br><span class="line">                   -archivePath $&#123;export_archive_path&#125; \</span><br><span class="line">                   | xcpretty</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"># 编译前清理工程</span><br><span class="line">xcodebuild clean -project $&#123;project_name&#125;.xcodeproj \</span><br><span class="line">                 -scheme $&#123;scheme_name&#125; \</span><br><span class="line">                 -configuration $&#123;build_configuration&#125;</span><br><span class="line"></span><br><span class="line">xcodebuild archive -project $&#123;project_name&#125;.xcodeproj \</span><br><span class="line">                   -scheme $&#123;scheme_name&#125; \</span><br><span class="line">                   -configuration $&#123;build_configuration&#125; \</span><br><span class="line">                   -archivePath $&#123;export_archive_path&#125; \</span><br><span class="line">                   | xcpretty</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#  检查是否构建成功</span><br><span class="line">#  xcarchive 实际是一个文件夹不是一个文件所以使用 -d 判断</span><br><span class="line">if [ -d &quot;$export_archive_path&quot; ] ; then</span><br><span class="line">echo &quot;\033[项目构建成功] \033&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;\033[项目构建失败] \033&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;\033[*************************  开始导出ipa文件  *************************]\033&quot;</span><br><span class="line">xcodebuild  -exportArchive \</span><br><span class="line">            -archivePath $&#123;export_archive_path&#125; \</span><br><span class="line">            -exportPath $&#123;export_ipa_path&#125; \</span><br><span class="line">            -exportOptionsPlist $&#123;ExportOptionsPlistPath&#125; \</span><br><span class="line">            -allowProvisioningUpdates \</span><br><span class="line">            -allowProvisioningDeviceRegistration \</span><br><span class="line">            CODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxx (xxx)&quot;</span><br><span class="line"></span><br><span class="line"># 修改ipa文件名称</span><br><span class="line">mv $export_ipa_path/$scheme_name.ipa $export_ipa_path/$ipa_name.ipa</span><br><span class="line"></span><br><span class="line"># 检查文件是否存在</span><br><span class="line">if [ -f &quot;$export_ipa_path/$ipa_name.ipa&quot; ] ; then</span><br><span class="line">echo &quot;\033[导出 $&#123;ipa_name&#125;.ipa 包成功]\033&quot;</span><br><span class="line">open $export_path</span><br><span class="line">else</span><br><span class="line">echo &quot;\033[导出 $&#123;ipa_name&#125;.ipa 包失败]\033&quot;</span><br><span class="line"></span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"># 输出打包总用时</span><br><span class="line">echo &quot;\033[打包总用时: $&#123;SECONDS&#125;s]\033&quot;</span><br></pre></td></tr></table></figure><p>接下来是上传脚本，将上传脚本添加到上面打包脚本末尾就可以在打包完成后自动上传。</p><p>上传到蒲公英的脚本如下，请自行替换蒲公英<code>API Key</code>和<code>User Key</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># ============================上传到蒲公英部分(请自行替换蒲公英API Key和User Key)================================ #</span><br><span class="line"></span><br><span class="line">echo &quot;\033[*************************  上传到蒲公英  *************************]\033&quot;</span><br><span class="line"># open $export_path</span><br><span class="line"></span><br><span class="line"># 蒲公英上的User Key</span><br><span class="line">uKey=&quot;xxx&quot;</span><br><span class="line"> </span><br><span class="line"># 蒲公英上的API Key</span><br><span class="line">apiKey=&quot;xxx&quot;</span><br><span class="line"> </span><br><span class="line"># 要上传的ipa文件路径</span><br><span class="line">IPA_PATH=&quot;$export_ipa_path/$ipa_name.ipa&quot;</span><br><span class="line"> </span><br><span class="line"># 执行上传至蒲公英的命令</span><br><span class="line">echo &quot;[************************* uploading *************************]&quot;</span><br><span class="line"></span><br><span class="line">curl -F &quot;file=@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey=$&#123;uKey&#125;&quot; -F &quot;_api_key=$&#123;apiKey&#125;&quot; http://www.pgyer.com/apiv1/app/upload</span><br></pre></td></tr></table></figure><p>上传到<code>fir</code>的脚本如下，请自行替换<code>fir</code>的<code>API Token</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># ============================上传到fir.im部分(请自行替换fir的API Token)================================ #</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"># 执行上传至fir.im的命令</span><br><span class="line">echo &quot;[************************* uploading *************************]&quot;</span><br><span class="line"></span><br><span class="line"># fir.im上的API Token</span><br><span class="line">API_TOKEN=&quot;xxx&quot;</span><br><span class="line"></span><br><span class="line"># 要上传的ipa文件路径</span><br><span class="line">IPA_PATH=&quot;$export_ipa_path/$ipa_name.ipa&quot;</span><br><span class="line"></span><br><span class="line">#上传到fir</span><br><span class="line">fir publish $IPA_PATH -T $API_TOKEN</span><br></pre></td></tr></table></figure><p>点击保存并退出，在项目面板中点击<code>Build Now</code>就会执行自动打包，点击下面的Build编号，进入构建面板后点击<code>控制台输入</code>可以看到实时的日志，如果打包失败也可以看到失败原因。打包成功会显示如下：</p><p><img src="https://i.loli.net/2020/01/19/Z7PLSdcMUnARFwv.png" alt="package_success.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在持续集成领域，&lt;strong&gt;Jenkins&lt;/strong&gt;绝对是一个神兵利器，它的插件库非常丰富，我们可以使用它代替执行很多工作中常见的繁琐重复的工作，减少我们在开发之外的不必要的时间花费，从而提高我们的开发效率。在iOS开发中，最常见的就是自动化打包。&lt;/p&gt;
&lt;p&gt;我在最初开始接触使用&lt;strong&gt;Jenkins&lt;/strong&gt;的过程中，参考了大量的&lt;strong&gt;Jenkins&lt;/strong&gt;的安装使用教程，发现各有优势，但其中也有很多坑和不合理的地方。通过自己大量的使用、研究和优化，总结了这篇优化版的自动化打包教程。&lt;/p&gt;
&lt;p&gt;在安装和使用&lt;strong&gt;Jenkins&lt;/strong&gt;的过程中，很多步骤都会有几种方式实现，本文只详细讲解个人认为比较好的方式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Jenkins" scheme="http://anye3210.github.io/tags/Jenkins/"/>
    
    <category term="fir" scheme="http://anye3210.github.io/tags/fir/"/>
    
    <category term="蒲公英" scheme="http://anye3210.github.io/tags/%E8%92%B2%E5%85%AC%E8%8B%B1/"/>
    
    <category term="profile" scheme="http://anye3210.github.io/tags/profile/"/>
    
    <category term="ad-hoc" scheme="http://anye3210.github.io/tags/ad-hoc/"/>
    
    <category term="iOS" scheme="http://anye3210.github.io/tags/iOS/"/>
    
    <category term="持续集成" scheme="http://anye3210.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
    <category term="自动化打包" scheme="http://anye3210.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>使用SonarQube静态检查OC代码质量</title>
    <link href="http://anye3210.github.io/2020/01/13/%E4%BD%BF%E7%94%A8SonarQube%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5OC%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    <id>http://anye3210.github.io/2020/01/13/%E4%BD%BF%E7%94%A8SonarQube%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5OC%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/</id>
    <published>2020-01-13T15:01:17.000Z</published>
    <updated>2021-08-22T07:32:59.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>SonarQube</strong>是一个开源的代码质量管理系统，它支持包括ObjectiveC、Java、C/C++、C#、PHP在内的超过25种编程语言。它能够提供包括重复代码、编码标准、单元测试、代码覆盖率、代码复杂度、潜在Bug、注释的报告。它还可以与持续集成工具配合使用实现完全自动化的分析。</p><p>之前在网上搜索学习<strong>SonarQube</strong>在Mac上的集成和使用教程，发现教程都比较老，使用的都是较老版本的<strong>SonarQube</strong>，在集成最新的8.1版本时踩了不少坑。本文就是对在Mac系统上安装和使用新版SonarQube的总结。后续会继续更新使用<strong>SonarQube</strong>静态分析Swift代码及结合<strong>Jenkins</strong>进行自动化分析。</p><p><strong>注意：SonarQube</strong>需要<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html">Java 11</a>及以上的运行环境，在终端输入<code>java --version</code>即可查看系统的Java版本，如果不满足，请先自行下载和安装。</p><span id="more"></span><h1 id="SonarQube平台架构"><a href="#SonarQube平台架构" class="headerlink" title="SonarQube平台架构"></a>SonarQube平台架构</h1><p>SonarQube平台主要由四大要件构成：</p><ul><li><strong>数据库</strong>：存放配置数据和检测数据（7.9及以后的版本不再支持MySQL，本文使用的是PostgreSQL）</li><li><strong>Web服务</strong>：在本地网页上查看配置数据和代码质量检测结果</li><li><strong>分析器</strong>：对项目代码进行分析（OCLint）</li><li><strong>插件</strong>：支持各种语言的插件</li></ul><h1 id="安装配置PostgreSQL数据库"><a href="#安装配置PostgreSQL数据库" class="headerlink" title="安装配置PostgreSQL数据库"></a>安装配置PostgreSQL数据库</h1><p><strong>SonarQube</strong>运行和储存数据需要数据库，而网上大多数教程使用的<strong>MySQL</strong>数据库已经不被7.9以后版本的<strong>SonarQube</strong>支持了，所以我选择了同样开源的关系数据库<strong>PostgreSQL</strong>。这个数据库和<strong>MySQL</strong>语法略有不同，但使用上基本大同小异。</p><p>我们先来安装和配置<strong>PostgreSQL</strong>数据库。</p><h2 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h2><p>安装<strong>PostgreSQL</strong>数据库有两种方式，一种是<strong>Homebrew</strong>，一种是直接上官网下载安装程序安装，后一种有可视化界面使用上比较简单。</p><h3 id="使用Homebrew安装"><a href="#使用Homebrew安装" class="headerlink" title="使用Homebrew安装"></a>使用Homebrew安装</h3><p>安装<strong>Homebrew</strong>（电脑上已经安装了的可以跳过这步）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>安装数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install postgresql </span><br></pre></td></tr></table></figure><h3 id="软件方式安装"><a href="#软件方式安装" class="headerlink" title="软件方式安装"></a>软件方式安装</h3><p>进入<a href="https://postgresapp.com/">官网</a>按照提示进行下载和安装，安装完之后直接双击运行即可。</p><p>使用软件方式安装会自动创建两个用户，一个是postgres，一个是与电脑当前登录用户同名的用户，并且分别为两个用户创建了默认的数据库。后面我们添加用户和数据库时可以登录postgres这个用户进行创建。（注：<strong>PostgreSQL</strong>数据库可以使用<a href="https://www.pgadmin.org/">pgAdmin</a>在本地网页图形化界面上进行管理，具体安装和使用请自行搜索）</p><p>软件方式安装需要配置一下环境路径，这样我们就可以在命令行直接使用<code>psql</code>命令。</p><p>在 ~/.bash_profile中添加以下内容（具体路径可以查看从图形界面进入<strong>psql</strong>命令行时显示的路径）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/Applications/Postgres.app/Contents/Versions/12/bin</span><br></pre></td></tr></table></figure><p>保存之后退出，在终端输入<code>source ~/.bash_profile</code>使设置生效。然后就可以直接在终端中键入<code>psql</code>，显示如下则表示设置成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psql (12.1)</span><br><span class="line">Type &quot;help&quot; for help.</span><br></pre></td></tr></table></figure><p>默认情况下本地用户登录都是受信任的，不需要输入密码，如果想要使用密码登录，可以修改<code>/Users/本地用户名/Library/Application Support/Postgres/var-12/pg_hba.conf</code>文件，将以下内容里的trust替换为md5即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line"></span><br><span class="line"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class="line">local   all             all                                     trust</span><br><span class="line"># IPv4 local connections:</span><br><span class="line">host    all             all             127.0.0.1/32            trust</span><br><span class="line"># IPv6 local connections:</span><br><span class="line">host    all             all             ::1/128                 trust</span><br><span class="line"># Allow replication connections from localhost, by a user with the</span><br><span class="line"># replication privilege.</span><br><span class="line">local   replication     all                                     trust</span><br><span class="line">host    replication     all             127.0.0.1/32            trust</span><br><span class="line">host    replication     all             ::1/128                 trust</span><br></pre></td></tr></table></figure><p>替换后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># TYPE  DATABASE        USER            ADDRESS                 METHOD</span><br><span class="line"></span><br><span class="line"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class="line">local   all             all                                     md5</span><br><span class="line"># IPv4 local connections:</span><br><span class="line">host    all             all             127.0.0.1/32            md5</span><br><span class="line"># IPv6 local connections:</span><br><span class="line">host    all             all             ::1/128                 md5</span><br><span class="line"># Allow replication connections from localhost, by a user with the</span><br><span class="line"># replication privilege.</span><br><span class="line">local   replication     all                                     md5</span><br><span class="line">host    replication     all             127.0.0.1/32            md5</span><br><span class="line">host    replication     all             ::1/128                 md5</span><br></pre></td></tr></table></figure><p>重启<strong>PostgreSQL</strong>之后使用<code>psql -U 用户名</code>登录就需要输入密码了。</p><p><strong>注：PostgreSQL</strong>常用指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">psql -U [user] -d [database] -h [host] -p [post] //登录</span><br><span class="line">\password：设置当前登录用户的密码</span><br><span class="line">\h：查看SQL命令的解释，比如\h select。</span><br><span class="line">\?：查看psql命令列表。</span><br><span class="line">\l：列出所有数据库。</span><br><span class="line">\c [database_name]：连接其他数据库。</span><br><span class="line">\d：列出当前数据库的所有表格。</span><br><span class="line">\d [table_name]：列出某一张表格的结构。</span><br><span class="line">\du：列出所有用户。</span><br><span class="line">\e：打开文本编辑器。</span><br><span class="line">\conninfo：列出当前数据库和连接的信息。</span><br><span class="line">\password [user]: 修改用户密码</span><br><span class="line">\q：退出</span><br></pre></td></tr></table></figure><h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>首先使用<strong>postgres</strong>用户登录数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql postgres</span><br></pre></td></tr></table></figure><p>然后创建用户<strong>sonar</strong>并设置密码，这里的密码你可以填写自己的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER sonar WITH PASSWORD &#x27;sonar&#x27;;</span><br></pre></td></tr></table></figure><p>创建属于用户<strong>sonar</strong>的数据库<strong>sonar</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE sonar OWNER sonar;</span><br></pre></td></tr></table></figure><p>给<strong>sonar</strong>用户加上添加数据库的权限 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER ROLE sonar CREATEDB;</span><br></pre></td></tr></table></figure><p>这样，数据库配置就完成了，接下来正式安装<strong>SonarQube</strong>。</p><h1 id="安装和配置SonarQube"><a href="#安装和配置SonarQube" class="headerlink" title="安装和配置SonarQube"></a>安装和配置SonarQube</h1><p>安装<strong>SonarQube</strong>主要分为三步：</p><ul><li>安装配置<strong>SonarQube</strong>本地服务器</li><li>安装配置<strong>sonar-scanner</strong></li><li>安装配置<strong>xcpretty</strong>、<strong>OCLint</strong>、<strong>slather</strong>等工具和插件</li></ul><h2 id="安装配置本地服务器"><a href="#安装配置本地服务器" class="headerlink" title="安装配置本地服务器"></a>安装配置本地服务器</h2><p><strong>SonarQube</strong>的服务可以运行在本地服务器或者远程服务器上，本文主要讲解本地服务器的配置方式。</p><p>首先上<a href="https://www.sonarqube.org/downloads/">SonarQube官网</a>上下载SonarQube源文件并解压。</p><p>然后配置conf/sonar.properties文件</p><p>设置数据库版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sonar.jdbc.url=jdbc:postgresql://localhost/sonar</span><br></pre></td></tr></table></figure><p>设置数据库账号密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br></pre></td></tr></table></figure><p>进入bin/macosx-universal-64文件夹，给sonar.sh设置权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 sonar.sh</span><br></pre></td></tr></table></figure><p>使用./sonar.sh console来启动服务器，在浏览器输入<code>http://localhost:9000</code>来测试服务器是否启动成功。页面正常显示就表示启动成功。</p><p>如果启动失败，可以根据<strong>SonarQube</strong>项目目录的logs文件夹中的日志查找原因。大部分启动不成功的情况都是数据库原因，这个在web.log文件中有记录。</p><p>注：<strong>SonarQube</strong>常用命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./sonar.sh console #Debug信息</span><br><span class="line">./sonar.sh start #启动服务</span><br><span class="line">./sonar.sh stop #停止服务</span><br><span class="line">./sonar.sh restart #重启服务</span><br></pre></td></tr></table></figure><h2 id="安装和配置sonar-scanner"><a href="#安装和配置sonar-scanner" class="headerlink" title="安装和配置sonar-scanner"></a>安装和配置sonar-scanner</h2><p>直接使用<code>HomeBrew</code>安装<code>sonar-scanner</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install sonar-scanner</span><br></pre></td></tr></table></figure><p>安装完成后输入<code>sonar-scanner -v</code>或者<code>sonar-scanner --version</code>可以看到如下配置文件地址和版本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO: Scanner configuration file: /usr/local/Cellar/sonar-scanner/4.2.0.1873/libexec/conf/sonar-scanner.properties</span><br><span class="line">INFO: Project root configuration file: NONE</span><br><span class="line">INFO: SonarQube Scanner 4.2.0.1873</span><br><span class="line">INFO: Java 11.0.5 Oracle Corporation (64-bit)</span><br><span class="line">INFO: Mac OS X 10.15.2 x86_64</span><br></pre></td></tr></table></figure><p>根据上面显示的配置文件地址打开配置文件，即<code>/usr/local/Cellar/sonar-runner/2.5/libexec/conf/sonar-runner.properties</code>，修改或添加以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sonar.host.url=http://localhost:9000</span><br><span class="line">sonar.jdbc.username=sonar</span><br><span class="line">sonar.jdbc.password=sonar</span><br><span class="line">sonar.jdbc.url=jdbc:postgresql://localhost/sonar</span><br></pre></td></tr></table></figure><p>修改完后保存，<strong>sonar-scanner</strong>这部分就完成了。</p><h2 id="安装其他工具和插件"><a href="#安装其他工具和插件" class="headerlink" title="安装其他工具和插件"></a>安装其他工具和插件</h2><p>首先安装环境工具。</p><p>安装<strong>xcpretty</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Backelite/xcpretty.git</span><br><span class="line">cd xcpretty</span><br><span class="line">git checkout fix/duration_of_failed_tests_workaround </span><br><span class="line">gem build xcpretty.gemspec </span><br><span class="line">sudo gem install --both xcpretty-0.2.2.gem</span><br></pre></td></tr></table></figure><p>安装<strong>oclint</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install oclint</span><br></pre></td></tr></table></figure><p>安装<strong>slather</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install slather</span><br></pre></td></tr></table></figure><p>安装<strong>lizard</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install lizard</span><br></pre></td></tr></table></figure><p>然后是安装静态分析插件，由于官方插件<strong>SonarCFamily</strong>比较贵，使用开源的就好。</p><p>在<a href="https://github.com/SonarQubeCommunity/sonar-l10n-zh">这里</a>可以看到插件版本和与之对应的<strong>SonarQube</strong>版本，到Release里面下载相应版本的jar文件即可（也可以下载源文件自行编译，这个比较费时间，不推荐）。将下载好的jar文件放到<strong>SonarQube</strong>安装目录下的<code>extensions/plugins</code>文件夹中，插件安装就完成了。</p><h1 id="使用SonarQube静态扫描代码"><a href="#使用SonarQube静态扫描代码" class="headerlink" title="使用SonarQube静态扫描代码"></a>使用SonarQube静态扫描代码</h1><p>终端路径切换到待扫描项目的根目录下，输入<code>touch run-sonar.sh</code>命令生成<strong>run-sonar.sh</strong>，然后输入<code>vi run-sonar.sh</code>编辑文件，在里面添加以下内容（注意把里面的<code>xxx</code>更改为你的项目名称的Scheme名称）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild -workspace xxx.xcworkspace -scheme xxx clean build | tee xcodebuild.log | xcpretty --report json-compilation-database</span><br><span class="line"></span><br><span class="line">mv build/reports/compilation_db.json compile_commands.json</span><br><span class="line"></span><br><span class="line">oclint-json-compilation-database -exclude Pods -- -report-type pmd -o oclint.xml -max-priority-1 99999 -max-priority-2 99999 -max-priority-3 99999 -rc LONG_LINE=140 -rc LONG_METHOD=80 -rc NCSS_METHOD=50 -rc SHORT_VARIABLE_NAME=1 -rc CYCLOMATIC_COMPLEXITY=13 -rc MINIMUM_CASES_IN_SWITCH=2 -rc NPATH_COMPLEXITY=1500</span><br><span class="line"></span><br><span class="line">rm -rf sonar-reports</span><br><span class="line">    </span><br><span class="line">mkdir sonar-reports</span><br><span class="line"></span><br><span class="line">cat oclint.xml  | sed &quot;s#Switch Statements Should Have Default Rule#switch statements should have default#g&quot; | sed &quot;s#missing hash method#must override hash with isEqual#g&quot; | sed &quot;s#prefer early exits and continue#use early exits and continue#g&quot; | sed &quot;s#use boxed expression#replace with boxed expression#g&quot; | sed &quot;s#use container literal#replace with container literal#g&quot; | sed &quot;s#use number literal#replace with number literal#g&quot; | sed &quot;s#use object subscripting#replace with object subscripting#g&quot; | sed &quot;s#missing default in switch statements#switch statements should have default#g&quot; | sed &quot;s#unnecessary default statement in covered switch statement#switch statements don&#x27;t need default when fully covered#g&quot; | sed &quot;s#covered switch statements dont need default#switch statements don&#x27;t need default when fully covered#g&quot; &gt; sonar-reports/oclint.xml</span><br><span class="line">    </span><br><span class="line">/bin/sh sonar-scanner -X</span><br></pre></td></tr></table></figure><p>以同样的方式新建<strong>sonar-project.properties</strong>文件，使用vi命令添加以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required configuration <span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################</span></span></span><br><span class="line"></span><br><span class="line">sonar.projectKey=你的项目Key</span><br><span class="line">sonar.projectName=项目名</span><br><span class="line">sonar.projectVersion=版本号</span><br><span class="line">sonar.language=objc</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Project description</span></span><br><span class="line">sonar.projectDescription=Text sonarquebe</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Path to <span class="built_in">source</span> directories</span> </span><br><span class="line">sonar.sources=项目源码文件夹名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> Path to <span class="built_in">test</span> directories (comment <span class="keyword">if</span> no <span class="built_in">test</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sonar.tests=testSrcDir</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Xcode project configuration (.xcodeproj or .xcworkspace)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -&gt; If you have a project: configure only sonar.objectivec.project</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -&gt; If you have a workspace: configure sonar.objectivec.workspace and sonar.objectivec.project</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and use the later to specify <span class="built_in">which</span> project(s) to include <span class="keyword">in</span> the analysis (comma separated list)</span></span><br><span class="line">sonar.objectivec.project=项目名.xcodeproj </span><br><span class="line"><span class="meta">#</span><span class="bash"> sonar.objectivec.workspace=myApplication.xcworkspace</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Scheme to build your application</span></span><br><span class="line">sonar.objectivec.appScheme=需要编译的Scheme名</span><br><span class="line"><span class="meta">#</span><span class="bash"> Scheme to build and run your tests (comment following line of you don<span class="string">&#x27;t have any tests)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> sonar.objectivec.testScheme=myApplicationTests</span></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">#########################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Optional configuration #</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string">#########################</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Encoding of the source code</span></span></span><br><span class="line">sonar.sourceEncoding=UTF-8</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> JUnit report generated by run-sonar.sh is stored in sonar-reports/TEST-report.xml</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Change it only if you generate the file on your own</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> The XML files have to be prefixed by TEST- otherwise they are not processed</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> sonar.junit.reportsPath=sonar-reports/</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Cobertura report generated by run-sonar.sh is stored in sonar-reports/coverage.xml</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Change it only if you generate the file on your own</span></span></span><br><span class="line">sonar.objectivec.coverage.reportPattern=sonar-reports/coverage*.xml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> OCLint report generated by run-sonar.sh is stored in sonar-reports/oclint.xml</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Change it only if you generate the file on your own</span></span></span><br><span class="line">sonar.objectivec.oclint.report=oclint.xml</span><br><span class="line">sonar.objectivec.oclint.reportPath=sonar-reports/oclint.xml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Paths to exclude from coverage report (tests, 3rd party libraries etc.)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> sonar.objectivec.excludedPathsFromCoverage=pattern1,pattern2</span></span></span><br><span class="line">sonar.objectivec.excludedPathsFromCoverage=.*Tests.*</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> Project SCM settings</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> sonar.scm.enabled=true</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> sonar.scm.url=scm:git:https://...</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输入<code>wq</code>命令保存并退出。</p><p>为避免编译的时候出现<code>oclint: error: one compiler command contains multiple jobs:</code>的报错，需要使用XCode打开工程文件并且在Build Settings中将<code>COMPILER_INDEX_STORE_ENABLE</code>设置为NO。</p><p>进入到<strong>SonarQube</strong>项目文件夹，进入到bin/macosx-universal-64，使用命令<code>./sonar.sh restart</code>来重启服务器。</p><p>上面的步骤全部完成后，就可以在工程目录下使用<code>./run-sonar.sh</code>或<code>sh run-sonar.sh</code>命令来执行脚本。</p><p>命令执行行完毕并且没有报错，就可以在浏览器中输入<a href="http://localhost:9000/">http://localhost:9000</a>查看检测结果。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;SonarQube&lt;/strong&gt;是一个开源的代码质量管理系统，它支持包括ObjectiveC、Java、C/C++、C#、PHP在内的超过25种编程语言。它能够提供包括重复代码、编码标准、单元测试、代码覆盖率、代码复杂度、潜在Bug、注释的报告。它还可以与持续集成工具配合使用实现完全自动化的分析。&lt;/p&gt;
&lt;p&gt;之前在网上搜索学习&lt;strong&gt;SonarQube&lt;/strong&gt;在Mac上的集成和使用教程，发现教程都比较老，使用的都是较老版本的&lt;strong&gt;SonarQube&lt;/strong&gt;，在集成最新的8.1版本时踩了不少坑。本文就是对在Mac系统上安装和使用新版SonarQube的总结。后续会继续更新使用&lt;strong&gt;SonarQube&lt;/strong&gt;静态分析Swift代码及结合&lt;strong&gt;Jenkins&lt;/strong&gt;进行自动化分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：SonarQube&lt;/strong&gt;需要&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html&quot;&gt;Java 11&lt;/a&gt;及以上的运行环境，在终端输入&lt;code&gt;java --version&lt;/code&gt;即可查看系统的Java版本，如果不满足，请先自行下载和安装。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SonarQube" scheme="http://anye3210.github.io/tags/SonarQube/"/>
    
    <category term="代码质量" scheme="http://anye3210.github.io/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"/>
    
    <category term="静态检查" scheme="http://anye3210.github.io/tags/%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/"/>
    
    <category term="ObjectiveC" scheme="http://anye3210.github.io/tags/ObjectiveC/"/>
    
  </entry>
  
  <entry>
    <title>【iOS】Eureka的基本使用和自定义Cell</title>
    <link href="http://anye3210.github.io/2019/06/04/Eureka%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89Cell/"/>
    <id>http://anye3210.github.io/2019/06/04/Eureka%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89Cell/</id>
    <published>2019-06-04T12:23:24.000Z</published>
    <updated>2021-08-22T07:50:24.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Eureka</code>是一个纯<code>Swift</code>库，它能帮你快速优雅地创建一个<code>TableView</code>。这个库本身也提供了大量内置的不同功能的<code>Cell</code>，使用上也很简单。如果内置的<code>Cell</code>样式或功能不能满足需要，你也可以自定义<code>Cell</code>。</p><p>使用Eureka设置<code>TableView</code>的代码大概是下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">form +++ Section()</span><br><span class="line">         &lt;&lt;&lt; LabelRow() &#123;</span><br><span class="line">            $0.title = &quot;LabelRow&quot;</span><br><span class="line">            $0.value = &quot;Default Value&quot;</span><br><span class="line">            &#125;.cellSetup(&#123; (cell, row) in</span><br><span class="line">                cell.accessoryType = .disclosureIndicator</span><br><span class="line">            &#125;).onCellSelection(&#123; (cell, row) in</span><br><span class="line">                print(&quot;cell selection&quot;)</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>本文主要介绍<code>Eureka</code>的基本使用和自定义<code>Cell</code>的步骤。你可以在<a href="https://github.com/zephyrw/EurekaCustomCellDemo">这里</a>查看本文的Demo。</p><span id="more"></span><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><code>Eureka</code>的基本使用主要是三步</p><ul><li><strong>1.</strong> 新建<code>ViewController</code>并将<code>ViewController</code>设置为<code>FormViewController</code>的子类</li><li><strong>2.</strong> 添加<code>Section</code></li><li><strong>3.</strong> 添加<code>Row</code></li></ul><h3 id="新建ViewController"><a href="#新建ViewController" class="headerlink" title="新建ViewController"></a>新建<code>ViewController</code></h3><p> 显示<code>tableView</code>首先得有一个控制器，这里我们新建一个控制器并将它设置成<code>FormViewController</code>的子类，如下所示:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: FormViewController &#123;</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">       super.viewDidLoad()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FormViewController</code>本身是<code>UIViewController</code>的子类，而且<code>Eureka</code>框架已经在其中添加和设置好了<code>tableView</code>，所以我们开发时不用操心布局，仅仅关注交互逻辑就可以了。</p><h3 id="添加Section"><a href="#添加Section" class="headerlink" title="添加Section"></a>添加<code>Section</code></h3><p><code>FormViewController</code>里<code>tableView</code>的<code>style</code>属性值为<code>.grouped</code>，这里我们添加多少个<code>Section</code>就会自动生成多少个组，添加语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">form +++ Section()</span><br></pre></td></tr></table></figure><p>有的人看到这里或许有点奇怪，<code>+++</code>是个什么语法，好像没见过啊。其实这是<code>Eureka</code>使用了Swift自定义运算符的特性，定义<code>+++</code>这个中缀运算符，它在源文件里是这么定义的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infix operator +++ : FormPrecedence</span><br></pre></td></tr></table></figure><p>上面这个添加<code>Section</code>的语法定义是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">public func +++ (left: Form, right: Section) -&gt; Form &#123;</span><br><span class="line">    left.append(right)</span><br><span class="line">    return left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>Form</code>遵从了<code>RangeReplaceableCollection</code>这个协议，重写了<code>append</code>这个方法，具体实现有兴趣的可以去看源码。</p><h3 id="添加Row"><a href="#添加Row" class="headerlink" title="添加Row"></a>添加<code>Row</code></h3><p><code>Row</code>的创建和设置是所有步骤的核心，所有的交互逻辑都是在这里完成的。<code>Eureka</code>内置了数十种常用的<code>Row</code>，这里我们添加最常用的三种<code>Row</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">form +++ Section()</span><br><span class="line">            &lt;&lt;&lt; LabelRow() &#123;</span><br><span class="line">            $0.title = &quot;LabelRow&quot;</span><br><span class="line">            $0.value = &quot;Default Value&quot;</span><br><span class="line">            &#125;.cellSetup(&#123; (cell, row) in</span><br><span class="line">                cell.accessoryType = .disclosureIndicator</span><br><span class="line">            &#125;).onCellSelection(&#123; (cell, row) in</span><br><span class="line">                print(&quot;cell selection&quot;)</span><br><span class="line">            &#125;)</span><br><span class="line">            &lt;&lt;&lt; TextRow(tag: &quot;TextRow&quot;)</span><br><span class="line">                .cellSetup(&#123; (cell, row) in</span><br><span class="line">                    row.tag = &quot;TextRow&quot;</span><br><span class="line">                    row.title = &quot;TextRow&quot;</span><br><span class="line">                    row.placeholder = &quot;Input your message&quot;</span><br><span class="line">                &#125;)</span><br><span class="line">                .cellUpdate(&#123; (cell, row) in</span><br><span class="line">                    print(&quot;cell update&quot;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &lt;&lt;&lt; SwitchRow() &#123;</span><br><span class="line">                $0.tag = &quot;SwitchValue&quot;</span><br><span class="line">                $0.title = &quot;SwitchRow&quot;</span><br><span class="line">                $0.value = true</span><br><span class="line">                &#125;.onChange(&#123; (row) in</span><br><span class="line">                    print(&quot;value changed: \(row.value ?? false)&quot;)</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;&lt;</code>同样是<code>Eureka</code>自定义的中缀运算符，作用是将<code>Row</code>添加到对应的<code>Section</code>中。在上面的代码中，我是在<code>Row</code>的生成方法的闭包中为<code>title</code>和<code>value</code>赋值，这个操作同样也可以放在<code>cellSetup</code>方法中（这个操作只会在<code>Row</code>创建时调用），效果是一样的。需要动态刷新的值需要在<code>cellUpdate</code>方法中设置。<code>Eureka</code>同时也提供了<code>onCellSelection</code>和<code>onChange</code>这样的响应方法，在里面定义其实响应逻辑即可。</p><p>至此，<code>Eureka</code>的基本使用就全部完成了。如果<code>Eureka</code>框架自带的<code>Row</code>已经能完全满足你的需求，就不需要往下看了。但如果你不满足于内置<code>Row</code>，那么我们继续看看如何自定义<code>Cell</code>和<code>Row</code></p><h2 id="自定义Cell"><a href="#自定义Cell" class="headerlink" title="自定义Cell"></a>自定义<code>Cell</code></h2><p>这里我们来定义一个模拟软件更新的<code>Cell</code>，效果图如下：</p><p><img src="https://thumbs.gfycat.com/PrestigiousBlondIchidna-small.gif" alt="效果图"></p><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>首先，我们需要一个结构体<code>Software</code>方便为<code>Cell</code>赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum UpdateState: Int &#123;</span><br><span class="line">    case toUpdate = 0</span><br><span class="line">    case updating</span><br><span class="line">    case alreadyNewest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Software: Equatable &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var updateState: UpdateState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func == (lhs: Software, rhs: Software) -&gt; Bool &#123;</span><br><span class="line">    return lhs.name == rhs.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一点需要注意的是，定义的类或者结构体必须遵从<code>Equatable</code>协议，否则在自定义<code>Cell</code>里使用时会报错。</p><h3 id="定义Cell"><a href="#定义Cell" class="headerlink" title="定义Cell"></a>定义<code>Cell</code></h3><p>定义好了结构体，接下来就是实现<code>Cell</code>部分。</p><p>自定义<code>Eureka</code>的<code>Cell</code>和自定义普通<code>UITableView</code>的<code>Cell</code>一样，首先要选择使用纯代码创建还是<code>xib</code>创建。这里我们使用<code>xib</code>的方式。新建自定义<code>Cell</code>，如下图：</p><p><img src="https://miao.su/images/2019/06/04/cell05ac1.png" alt="添加Cell"></p><p>自定义布局，<code>Cell</code>连线，<code>UpdateCell</code>的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">final class UpdateCell: Cell&lt;Software&gt;, CellType &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var titleLabel: UILabel!</span><br><span class="line">    @IBOutlet weak var updateButton: UIButton!</span><br><span class="line">    @IBOutlet weak var aniContainerView: UIView!</span><br><span class="line">    @IBOutlet weak var noNeedUpdateLabel: UILabel!</span><br><span class="line">    </span><br><span class="line">    private var shapeLayer = CAShapeLayer()</span><br><span class="line">    </span><br><span class="line">    override func setup() &#123;</span><br><span class="line">        </span><br><span class="line">        selectionStyle = .none</span><br><span class="line">        height = &#123; return 44 &#125;</span><br><span class="line">        </span><br><span class="line">        //这里省略布局代码</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func update() &#123;</span><br><span class="line">        guard let software = row.value else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        titleLabel.text = software.name</span><br><span class="line">        updateUI(software.updateState)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在创建<code>UpdateCell</code>类的时候，有几点需要注意：</p><ul><li>指明为<code>Cell</code>赋值时使用的类</li><li>遵从<code>CellType</code>协议</li><li>指定<code>Cell</code>的高度</li></ul><p>在上面的代码的，<code>Setup</code>方法只会在<code>Cell</code>创建时调用一次，可以在这里写布局代码，而<code>Update</code>方法会在每次刷新的时候调用，可以在这里给<code>Cell</code>的<code>subViews</code>赋值。</p><h3 id="定义Row"><a href="#定义Row" class="headerlink" title="定义Row"></a>定义<code>Row</code></h3><p>接下来还需要自定义<code>Row</code>，从属于上面我们刚刚定义的<code>Cell</code>，并在里面加载<code>xib</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">final class UpdateRow: Row&lt;UpdateCell&gt;, RowType &#123;</span><br><span class="line">    </span><br><span class="line">    required init(tag: String?) &#123;</span><br><span class="line">        super.init(tag: tag)</span><br><span class="line">        cellProvider = CellProvider&lt;UpdateCell&gt;(nibName: &quot;UpdateCell&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加自定义Cell到Section中"><a href="#添加自定义Cell到Section中" class="headerlink" title="添加自定义Cell到Section中"></a>添加自定义<code>Cell</code>到<code>Section</code>中</h3><p>自定义<code>Cell</code>创建完成后，就可以像使用框架中自带的<code>Row</code>一样来使用我们的自定义<code>Row</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; UpdateRow() &#123;</span><br><span class="line">                $0.value = Software(name: &quot;My Software&quot;, updateState: .toUpdate)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实<code>Eureka</code>的使用比较简单，熟练操作后会是快速构建<code>UITableView</code>的利器。本文的Demo可以在<a href="https://github.com/zephyrw/EurekaCustomCellDemo">这里</a>查看。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Eureka&lt;/code&gt;是一个纯&lt;code&gt;Swift&lt;/code&gt;库，它能帮你快速优雅地创建一个&lt;code&gt;TableView&lt;/code&gt;。这个库本身也提供了大量内置的不同功能的&lt;code&gt;Cell&lt;/code&gt;，使用上也很简单。如果内置的&lt;code&gt;Cell&lt;/code&gt;样式或功能不能满足需要，你也可以自定义&lt;code&gt;Cell&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用Eureka设置&lt;code&gt;TableView&lt;/code&gt;的代码大概是下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;form +++ Section()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;lt;&amp;lt;&amp;lt; LabelRow() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $0.title = &amp;quot;LabelRow&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $0.value = &amp;quot;Default Value&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;.cellSetup(&amp;#123; (cell, row) in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cell.accessoryType = .disclosureIndicator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;).onCellSelection(&amp;#123; (cell, row) in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                print(&amp;quot;cell selection&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;本文主要介绍&lt;code&gt;Eureka&lt;/code&gt;的基本使用和自定义&lt;code&gt;Cell&lt;/code&gt;的步骤。你可以在&lt;a href=&quot;https://github.com/zephyrw/EurekaCustomCellDemo&quot;&gt;这里&lt;/a&gt;查看本文的Demo。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Eureka" scheme="http://anye3210.github.io/tags/Eureka/"/>
    
    <category term="Custom Cell" scheme="http://anye3210.github.io/tags/Custom-Cell/"/>
    
    <category term="TableView" scheme="http://anye3210.github.io/tags/TableView/"/>
    
    <category term="自动生成" scheme="http://anye3210.github.io/tags/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>【iOS】封装自己的自定义转场组件</title>
    <link href="http://anye3210.github.io/2019/05/30/%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E7%BB%84%E4%BB%B6/"/>
    <id>http://anye3210.github.io/2019/05/30/%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E7%BB%84%E4%BB%B6/</id>
    <published>2019-05-30T13:18:35.000Z</published>
    <updated>2021-08-22T07:35:46.116Z</updated>
    
    <content type="html"><![CDATA[<p>自定义转场这个技术相信大家都用过或者听说过，不过如果你经常使用自定义转场或者自定义转场动画做得比较复杂或许会发现AnimatedTransitioning与目标控制器的交互并没有那么友好。本文旨在提供一个新思路，减少AnimatedTransitioning与目标控制器的耦合，引入封装好的类文件后，只需少量代码，就可以实现一个基础的转场动画。</p><p>首先，我们来看一下实现一个普通的转场动画的流程。</p><span id="more"></span><h3 id="设置转场方式"><a href="#设置转场方式" class="headerlink" title="设置转场方式"></a>设置转场方式</h3><p>将转场方式设置为自定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toVC.modalPresentationStyle = .custom</span><br></pre></td></tr></table></figure><h3 id="设置转场代理"><a href="#设置转场代理" class="headerlink" title="设置转场代理"></a>设置转场代理</h3><p>这里转场代理可以设置为目标控制器，也可以是我们自定义的管理转场的类，这里设置为目标控制器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toVC.transitioningDelegate = toVC</span><br></pre></td></tr></table></figure><h3 id="实现转场代理方法"><a href="#实现转场代理方法" class="headerlink" title="实现转场代理方法"></a>实现转场代理方法</h3><p>转场的代理方法我们需要实现以下两个方法，指定我们自定义的类来管理转场动画，关于这个自定义的类，后面会详细说。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">//这里的animationTransitionContr就是自定义的用来管理转场的类</span><br><span class="line">animationTransitionContr.isPresenting = true</span><br><span class="line">       return animationTransitionContr</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123;</span><br><span class="line">   //这里的animationTransitionContr就是自定义的用来管理转场的类</span><br><span class="line">animationTransitionContr.isPresenting = false</span><br><span class="line">       return animationTransitionContr</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义转场动画管理类"><a href="#自定义转场动画管理类" class="headerlink" title="自定义转场动画管理类"></a>自定义转场动画管理类</h3><p>这个管理类定为NSObject子类就可以，关键是它必须遵从<code>UIViewControllerAnimatedTransitioning</code>协议，并实现以下几个代理方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123;</span><br><span class="line">        return 0.25</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">        let containerView = transitionContext.containerView</span><br><span class="line">        guard let fromVC = transitionContext.viewController(forKey: .from) else &#123; return &#125;</span><br><span class="line">        guard let toVC = transitionContext.viewController(forKey: .to) else &#123; return &#125;</span><br><span class="line">        if isPresenting &#123;</span><br><span class="line">            // 进入目标控制器的动画</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 退出目标控制器的动画</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此，一个常规的自定义转场动画就完成了。到这里就会发现一个问题，在实现具体动画的这一步，只有单个控制器使用这个转场类还好，如果是多个控制器分别需要实现不同的动画效果，这里的逻辑就会很复杂，代码可读性也不好。</p><p>要解决这个问题，我们可以把重构一下动画逻辑，将动画代码放在转场类里面，而将动画的具体实现放在目标控制器里。具体实现如下：</p><h3 id="为转场控制类定义代理"><a href="#为转场控制类定义代理" class="headerlink" title="为转场控制类定义代理"></a>为转场控制类定义代理</h3><p>这里的代理方法是将动画的不同时间点的控制暴露给目标控制器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protocol ZYAnimationTransitionControllerDelegate: NSObjectProtocol &#123;</span><br><span class="line">    func willPresent(fromView: UIView, toView: UIView)</span><br><span class="line">    func onPresent(fromView: UIView, toView: UIView)</span><br><span class="line">    func didPresent(fromView: UIView, toView: UIView)</span><br><span class="line">    func willDismiss(fromView: UIView, toView: UIView)</span><br><span class="line">    func onDismiss(fromView: UIView, toView: UIView)</span><br><span class="line">    func didDismiss(fromView: UIView, toView: UIView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在适当的时机调用代理方法"><a href="#在适当的时机调用代理方法" class="headerlink" title="在适当的时机调用代理方法"></a>在适当的时机调用代理方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fileprivate func present(transitionContext: UIViewControllerContextTransitioning, container: UIView, fromView: UIView, toView: UIView, completion: @escaping () -&gt; Void) &#123;</span><br><span class="line">    container.addSubview(toView)</span><br><span class="line">    guard let delegate = delegate else &#123; return &#125;</span><br><span class="line">    delegate.willPresent(fromView: fromView, toView: toView)</span><br><span class="line">    self.startAnimation(transitionContext: transitionContext, animations: &#123;</span><br><span class="line">        delegate.onPresent(fromView: fromView, toView: toView)</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        delegate.didPresent(fromView: fromView, toView: toView)</span><br><span class="line">        completion()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileprivate func dismiss(transitionContext: UIViewControllerContextTransitioning, container: UIView, fromView: UIView, toView: UIView, completion: @escaping () -&gt; Void) &#123;</span><br><span class="line">    container.addSubview(fromView)</span><br><span class="line">    guard let delegate = delegate else &#123; return &#125;</span><br><span class="line">    delegate.willDismiss(fromView: fromView, toView: toView)</span><br><span class="line">    self .startAnimation(transitionContext: transitionContext, animations: &#123;</span><br><span class="line">        delegate.onDismiss(fromView: fromView, toView: toView)</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        delegate.didDismiss(fromView: fromView, toView: toView)</span><br><span class="line">        completion()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用了一个辅助方法：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fileprivate func startAnimation(transitionContext: UIViewControllerContextTransitioning, animations: @escaping () -&gt; Void, completion: @escaping () -&gt; Void) &#123;</span><br><span class="line">    UIApplication.shared.beginIgnoringInteractionEvents()</span><br><span class="line">    UIView.animate(withDuration: self.transitionDuration(using: self as? UIViewControllerContextTransitioning), delay: 0, options: UIView.AnimationOptions(rawValue: 7 &lt;&lt; 16), animations: animations, completion: &#123; _ in</span><br><span class="line">        UIApplication.shared.endIgnoringInteractionEvents()</span><br><span class="line">        completion()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重构转场代理方法"><a href="#重构转场代理方法" class="headerlink" title="重构转场代理方法"></a>重构转场代理方法</h3><p>用以下方法替换之前的代理方法实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">        let containerView = transitionContext.containerView</span><br><span class="line">        guard let fromVC = transitionContext.viewController(forKey: .from) else &#123; return &#125;</span><br><span class="line">        guard let toVC = transitionContext.viewController(forKey: .to) else &#123; return &#125;</span><br><span class="line">        if isPresenting &#123;</span><br><span class="line">            present(transitionContext: transitionContext, container: containerView, fromView: fromVC.view, toView: toVC.view) &#123;</span><br><span class="line">                transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dismiss(transitionContext: transitionContext, container: containerView, fromView: fromVC.view, toView: toVC.view) &#123;</span><br><span class="line">                transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此，动画逻辑的重构就完成了。这时，一个完整的自定义转场的实现逻辑就是这样的：</p><ul><li>目标控制器设置转场类型为自定义</li><li>目标控制器设置转场代理为自己</li><li>目标控制器在转场代理方法中返回自定义的转场控制类</li><li>在自定义转场控制类中实现UIViewControllerAnimatedTransitioning协议方法</li><li>在自定义类中定义代理暴露动画控制权给目标控制器，并在适当时机调用代理方法</li></ul><p>相关代码的完整实现可以参考我的图片预览框架<a href="https://github.com/zephyrw/ZYPictureViewer.git">源码</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自定义转场这个技术相信大家都用过或者听说过，不过如果你经常使用自定义转场或者自定义转场动画做得比较复杂或许会发现AnimatedTransitioning与目标控制器的交互并没有那么友好。本文旨在提供一个新思路，减少AnimatedTransitioning与目标控制器的耦合，引入封装好的类文件后，只需少量代码，就可以实现一个基础的转场动画。&lt;/p&gt;
&lt;p&gt;首先，我们来看一下实现一个普通的转场动画的流程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UIViewControllerAnimatedTransitioning" scheme="http://anye3210.github.io/tags/UIViewControllerAnimatedTransitioning/"/>
    
    <category term="自定义转场" scheme="http://anye3210.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking源码上传图片部分完整解析</title>
    <link href="http://anye3210.github.io/2017/04/19/AFNetworking%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%83%A8%E5%88%86%E5%AE%8C%E6%95%B4%E8%A7%A3%E6%9E%90/"/>
    <id>http://anye3210.github.io/2017/04/19/AFNetworking%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%83%A8%E5%88%86%E5%AE%8C%E6%95%B4%E8%A7%A3%E6%9E%90/</id>
    <published>2017-04-19T14:00:00.000Z</published>
    <updated>2021-08-22T07:36:41.604Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发SDK时有上传图片的需求，这个需求用AF的话当然非常简单，多添加一句代码就可以搞定。但为避免第三方耦合并没有使用AFNetworking，这就需要自己走完上传图片的全部流程，所以仔细研究了一下AFNetworking的相关源码，梳理了整个流程，它的流程大致是这样的：</p><p>&lt;img src=”<a href="http://ogdqxib8j.bkt.clouddn.com/image/png%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0.png&quot;">http://ogdqxib8j.bkt.clouddn.com/image/png%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0.png&quot;</a> title:”AFNetworking图片上传流程”&gt;</p><p>看着有点眼花眼花缭乱是吧，没关系，接着往下看，看完这篇文章，你也可以自己封装一套图片上传网络工具类。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>基本原理</li><li>具体实现<ul><li>创建<code>NSMutableURLRequest</code>并设置请求方式为<code>POST</code></li><li>自定义<code>HTTPBodyStream</code></li><li>对<code>request</code>进行参数设置</li><li>通过<code>NSURLSession</code>的<code>uploadTaskWithStreamedRequest:</code>方法发起Post请求</li></ul></li></ul><span id="more"></span><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>首先我们来看一下AF中上传图片的方法长什么样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                             parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">              constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                               progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress))uploadProgress</span><br><span class="line">                                success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</span><br><span class="line">                                failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br></pre></td></tr></table></figure><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p>这个方法和AF其他正常的POST请求一样，都是基于<code>NSURLSession</code>，通过自定义的<code>NSMutableURLRequest</code>发起网络请求。不过在这个方法中，并没有使用常用的<code>dataTaskWithRequest</code>方法，而使用的是<code>uploadTaskWithStreamedRequest</code>。</p><h3 id="工具类AFStreamingMultipartFormData"><a href="#工具类AFStreamingMultipartFormData" class="headerlink" title="工具类AFStreamingMultipartFormData"></a>工具类<code>AFStreamingMultipartFormData</code></h3><p>在整个图片上传请求过程中，核心点在于为网络请求<code>NSURLReqeust</code>进行自定义的参数设定。为此，<code>AFNetworking</code>封装了一个工具类<code>AFStreamingMultipartFormData</code>，在这个类中完成对<code>NSURLRequst</code>除<code>HTTPMethod</code>外所有参数的设定。</p><h3 id="InputStream的子类AFMultipartBodyStream"><a href="#InputStream的子类AFMultipartBodyStream" class="headerlink" title="InputStream的子类AFMultipartBodyStream"></a><code>InputStream</code>的子类<code>AFMultipartBodyStream</code></h3><p>图片上传需要封装参数和图片数据，每一个参数的键值对都会封装成一个<code>AFHTTPBodyPart</code>模型，而<code>AFMultipartBodyStream </code>就负责对<code>AFHTTPBodyPart</code>进行管理，它本身同时也是自定义的<code>HTTPBodyStream</code>。</p><h3 id="参数的封装AFHTTPBodyPart"><a href="#参数的封装AFHTTPBodyPart" class="headerlink" title="参数的封装AFHTTPBodyPart"></a>参数的封装<code>AFHTTPBodyPart</code></h3><p><code>AFHTTPBodyPart</code>是对POST请求数据的封装，并实现将请求数据转换为<code>InputStream</code>的方法</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>上面的原理讲起来有点儿抽象，下面从图片上传的完整实现中来了解整个过程。</p><h3 id="创建NSMutableURLRequest并设置请求方式为POST"><a href="#创建NSMutableURLRequest并设置请求方式为POST" class="headerlink" title="创建NSMutableURLRequest并设置请求方式为POST"></a>创建<code>NSMutableURLRequest</code>并设置请求方式为<code>POST</code></h3><p>这一步就是常规步骤，代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc]initWithURL:[<span class="built_in">NSURL</span> URLWithString:api] cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">10.0</span>f];</span><br><span class="line">[request setHTTPMethod:<span class="string">@&quot;POST&quot;</span>];</span><br></pre></td></tr></table></figure><h3 id="自定义HTTPBodyStream"><a href="#自定义HTTPBodyStream" class="headerlink" title="自定义HTTPBodyStream"></a>自定义<code>HTTPBodyStream</code></h3><p>首先，需要创建一个工具类来管理刚刚创建的<code>request</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:request stringEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br></pre></td></tr></table></figure><p>接下来，需要将所有参数的键值对转换为<code>AFHTTPBodyPart</code>，这里要分两种情况：普通参数和图片相关参数。</p><h4 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h4><p>普通参数的转换直接遍历即可，将每一个键值对都转换为<code>AFHTTPBodyPart</code>，不过<code>AFNetworking</code>在这里将键值对又封闭了一个模型<code>AFQueryStringPair</code>，所以你看到的是这样的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> ([pair.value isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            data = pair.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([pair.value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">            data = [<span class="built_in">NSData</span> data];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data = [[pair.value description] dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            [formData appendPartWithFormData:data name:[pair.field description]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过个人觉得完全没有必要，不封装模型这样写可以达到同样的效果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">    [parameters enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            data = obj;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            data = [<span class="built_in">NSData</span> data];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            data = [[obj description] dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            [formData appendPartWithFormData:data name:[key description]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的方法中，调用了<code>-appendPartWithFormData:name:</code>方法，这个方法的作用有两个：拼装Header字典和封装<code>AFHTTPBodyPart</code>模型：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)appendPartWithFormData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          name:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(name);</span><br><span class="line"><span class="comment">// 拼装Header字典</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [mutableHeaders setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;form-data; name=\&quot;%@\&quot;&quot;</span>, name] forKey:<span class="string">@&quot;Content-Disposition&quot;</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> appendPartWithHeaders:mutableHeaders body:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)appendPartWithHeaders:(<span class="built_in">NSDictionary</span> *)headers</span><br><span class="line">                         body:(<span class="built_in">NSData</span> *)body</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(body);</span><br><span class="line"><span class="comment">// 创建模型</span></span><br><span class="line">    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];</span><br><span class="line">    bodyPart.stringEncoding = <span class="keyword">self</span>.stringEncoding;</span><br><span class="line">    bodyPart.headers = headers;</span><br><span class="line">    bodyPart.boundary = <span class="keyword">self</span>.boundary;</span><br><span class="line">    bodyPart.bodyContentLength = [body length];</span><br><span class="line">    bodyPart.body = body;</span><br><span class="line"><span class="comment">// bodyStream管理bodyPart</span></span><br><span class="line">    [<span class="keyword">self</span>.bodyStream appendHTTPBodyPart:bodyPart];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是在<code>AFMultipartBodyStream</code>中管理生成的多个<code>AFHTTPBodyPart</code>。</p><h4 id="图片相关参数"><a href="#图片相关参数" class="headerlink" title="图片相关参数"></a>图片相关参数</h4><p>如果只需要单一的上传图片的需求，直接将图片的数据、名称、类型等作为方法的参数传进来就可以，实现起来除Header的拼装有差异外几乎和上面正常参数一样。但AF为了可扩展性，添加了一个Block和代理，方便除<code>NSData</code>以外诸如<code>FileURL</code>、<code>InputStream</code>等上传方式。</p><p>这个Block长这个样子</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData)</span><br></pre></td></tr></table></figure><p>Block传入的参数是除图片参数的键值对外的全部转换完成后的<code>AFStreamingMultipartFormData</code>，遵从<code>AFMultipartFormData </code>协议。在以上正常参数转换完之后调用，Block的实现为用户自定义，用户可以选择适合的方式添加参数上传数据，这里只讲图片的<code>NSData</code>方式上传：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[formData appendPartWithFileData:imageData name:key fileName:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@.jpg&quot;</span>,key] mimeType:<span class="string">@&quot;image/jpeg&quot;</span>];</span><br></pre></td></tr></table></figure><p>然后同样是拼接Header</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)appendPartWithFileData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                      fileName:(<span class="built_in">NSString</span> *)fileName</span><br><span class="line">                      mimeType:(<span class="built_in">NSString</span> *)mimeType &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(name);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(fileName);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(mimeType);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [mutableHeaders setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;form-data; name=\&quot;%@\&quot;; filename=\&quot;%@\&quot;&quot;</span>, name, fileName] forKey:<span class="string">@&quot;Content-Disposition&quot;</span>];</span><br><span class="line">    [mutableHeaders setValue:mimeType forKey:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> appendPartWithHeaders:mutableHeaders body:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是转换成<code>AFHTTPBodyPart</code>，由<code>AFMultipartBodyStream</code>进行管理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)appendPartWithHeaders:(<span class="built_in">NSDictionary</span> *)headers</span><br><span class="line">                         body:(<span class="built_in">NSData</span> *)body &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(body);</span><br><span class="line">    </span><br><span class="line">    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];</span><br><span class="line">    bodyPart.stringEncoding = <span class="keyword">self</span>.stringEncoding;</span><br><span class="line">    bodyPart.headers = headers;</span><br><span class="line">    bodyPart.boundary = <span class="keyword">self</span>.boundary;</span><br><span class="line">    bodyPart.bodyContentLength = [body length];</span><br><span class="line">    bodyPart.body = body;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.bodyStream appendHTTPBodyPart:bodyPart];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AFMultipartBodyStream管理并转换AFHTTPBodyPart内部数据的具体实现"><a href="#AFMultipartBodyStream管理并转换AFHTTPBodyPart内部数据的具体实现" class="headerlink" title="AFMultipartBodyStream管理并转换AFHTTPBodyPart内部数据的具体实现"></a><code>AFMultipartBodyStream</code>管理并转换<code>AFHTTPBodyPart</code>内部数据的具体实现</h4><p>每生成一个<code>AFHTTPBodyPart</code>它都会存入<code>AFMultipartBodyStream</code>的<code>HTTPBodyParts</code>这个可变数组中，方便后面对数据进行处理。</p><p>而<code>AFMultipartBodyStream</code>的对数据转换要从它的父类<code>NSInputStream</code>说起，<code>NSInputStream</code>是<code>NSStream</code>的子类，方便我们以流文件的形式读取数据。在AF中，它重写了父类的<code>-read:maxLength:</code>方法，在这个方法里进行数据的处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)read:(uint8_t *)buffer</span><br><span class="line">        maxLength:(<span class="built_in">NSUInteger</span>)length &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> streamStatus] == <span class="built_in">NSStreamStatusClosed</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> totalNumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead &lt; MIN(length, <span class="keyword">self</span>.numberOfBytesInPacket)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.currentHTTPBodyPart || ![<span class="keyword">self</span>.currentHTTPBodyPart hasBytesAvailable]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(<span class="keyword">self</span>.currentHTTPBodyPart = [<span class="keyword">self</span>.HTTPBodyPartEnumerator nextObject])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSUInteger</span> maxLength = MIN(length, <span class="keyword">self</span>.numberOfBytesInPacket) - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead;</span><br><span class="line">            <span class="built_in">NSInteger</span> numberOfBytesRead = [<span class="keyword">self</span>.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength];</span><br><span class="line">            <span class="keyword">if</span> (numberOfBytesRead == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//                self.streamError = self.currentHTTPBodyPart.inputStream.streamError;</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalNumberOfBytesRead += numberOfBytesRead;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.delay &gt; <span class="number">0.0</span>f) &#123;</span><br><span class="line">                    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="keyword">self</span>.delay];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> totalNumberOfBytesRead;</span><br><span class="line">&#125;</span><br><span class="line">​``` objc</span><br><span class="line">上面这个方法核心就是把`bodyPart`挨个取出来进行读取数据操作，`bodyPart`读取数据的操作是在其内部实现的：</span><br><span class="line"></span><br><span class="line">​``` objc</span><br><span class="line">- (<span class="built_in">NSInteger</span>)read:(uint8_t *)buffer</span><br><span class="line">        maxLength:(<span class="built_in">NSUInteger</span>)length &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> totalNumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_phase == AFEncapsulationBoundaryPhase) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *encapsulationBoundaryData = [([<span class="keyword">self</span> hasInitialBoundary] ? AFMultipartFormInitialBoundary(<span class="keyword">self</span>.boundary) : AFMultipartFormEncapsulationBoundary(<span class="keyword">self</span>.boundary)) dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</span><br><span class="line">        totalNumberOfBytesRead += [<span class="keyword">self</span> readData:encapsulationBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_phase == AFHeaderPhase) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *headersData = [[<span class="keyword">self</span> stringForHeaders] dataUsingEncoding:<span class="keyword">self</span>.stringEncoding];</span><br><span class="line">        totalNumberOfBytesRead += [<span class="keyword">self</span> readData:headersData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_phase == AFBodyPhase) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> numberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        numberOfBytesRead = [<span class="keyword">self</span>.inputStream read:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];</span><br><span class="line">        <span class="keyword">if</span> (numberOfBytesRead == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            totalNumberOfBytesRead += numberOfBytesRead;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.inputStream streamStatus] &gt;= <span class="built_in">NSStreamStatusAtEnd</span>) &#123;</span><br><span class="line">                [<span class="keyword">self</span> transitionToNextPhase];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_phase == AFFinalBoundaryPhase) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *closingBoundaryData = ([<span class="keyword">self</span> hasFinalBoundary] ? [AFMultipartFormFinalBoundary(<span class="keyword">self</span>.boundary) dataUsingEncoding:<span class="keyword">self</span>.stringEncoding] : [<span class="built_in">NSData</span> data]);</span><br><span class="line">        totalNumberOfBytesRead += [<span class="keyword">self</span> readData:closingBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesRead)];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> totalNumberOfBytesRead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)readData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">           intoBuffer:(uint8_t *)buffer</span><br><span class="line">            maxLength:(<span class="built_in">NSUInteger</span>)length &#123;</span><br><span class="line">    <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>((<span class="built_in">NSUInteger</span>)_phaseReadOffset, MIN([data length] - ((<span class="built_in">NSUInteger</span>)_phaseReadOffset), length));</span><br><span class="line">    [data getBytes:buffer range:range];</span><br><span class="line">    </span><br><span class="line">    _phaseReadOffset += range.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (((<span class="built_in">NSUInteger</span>)_phaseReadOffset) &gt;= [data length]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> transitionToNextPhase];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">NSInteger</span>)range.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)transitionToNextPhase &#123;</span><br><span class="line">    <span class="keyword">if</span> (![[<span class="built_in">NSThread</span> currentThread] isMainThread]) &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> transitionToNextPhase];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (_phase) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFEncapsulationBoundaryPhase:</span><br><span class="line">            _phase = AFHeaderPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFHeaderPhase:</span><br><span class="line">            [<span class="keyword">self</span>.inputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">            [<span class="keyword">self</span>.inputStream open];</span><br><span class="line">            _phase = AFBodyPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFBodyPhase:</span><br><span class="line">            [<span class="keyword">self</span>.inputStream close];</span><br><span class="line">            _phase = AFFinalBoundaryPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFFinalBoundaryPhase:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            _phase = AFEncapsulationBoundaryPhase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _phaseReadOffset = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个方法即是<code>bodyPart</code>对数据读取的全部实现，看着比较复杂，梳理下来其实它的逻辑也比较清晰。简单来说就是把数据读取分成几个阶段，不同阶段进行相应操作，其最核心的是这两句：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.inputStream scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">[<span class="keyword">self</span>.inputStream open];</span><br></pre></td></tr></table></figure><p>这两句不仅仅是把输入流加入运行循环，开始读取数据，这里还用了一个懒加载，重写了<code>inputStream</code>的<code>getter</code>方法，在这个方法里进行了<code>inputStream</code>的初始化，即数据源的指定。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInputStream</span> *)inputStream &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_inputStream) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.body isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            _inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithData:<span class="keyword">self</span>.body];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.body isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            _inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithURL:<span class="keyword">self</span>.body];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.body isKindOfClass:[<span class="built_in">NSInputStream</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            _inputStream = <span class="keyword">self</span>.body;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _inputStream = [<span class="built_in">NSInputStream</span> inputStreamWithData:[<span class="built_in">NSData</span> data]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _inputStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的参数的数据流读取完毕，我们的自定义<code>HTTPBodyStream</code>也完成了，接下来就可以把它赋值给<code>request</code>了。</p><h3 id="对request进行参数设置"><a href="#对request进行参数设置" class="headerlink" title="对request进行参数设置"></a>对<code>request</code>进行参数设置</h3><p>参数设置这步比较简单，将之前自定义好的<code>HTTPBodyStream</code>赋值然后补充必要的参数即可：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法对request进行配置</span></span><br><span class="line">[formData requestByFinalizingMultipartFormData]</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestByFinalizingMultipartFormData &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.bodyStream isEmpty]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重设Boundary确保内容长度计算正确</span></span><br><span class="line">    [<span class="keyword">self</span>.bodyStream setInitialAndFinalBoundaries];</span><br><span class="line">    [<span class="keyword">self</span>.request setHTTPBodyStream:<span class="keyword">self</span>.bodyStream];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;multipart/form-data; boundary=%@&quot;</span>, <span class="keyword">self</span>.boundary] forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">    [<span class="keyword">self</span>.request setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%llu&quot;</span>, [<span class="keyword">self</span>.bodyStream contentLength]] forHTTPHeaderField:<span class="string">@&quot;Content-Length&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过NSURLSession的uploadTaskWithStreamedRequest-方法发起Post请求"><a href="#通过NSURLSession的uploadTaskWithStreamedRequest-方法发起Post请求" class="headerlink" title="通过NSURLSession的uploadTaskWithStreamedRequest:方法发起Post请求"></a>通过NSURLSession的uploadTaskWithStreamedRequest:方法发起Post请求</h3><p>上面<code>request</code>配置完成，就剩最后一步发起请求了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span> uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                failure(task, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success(task, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [task resume];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                 progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                        completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithStreamedRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AF自定义的上传方法中，使用了自己的代理，并让代理调用Block进行上传进度和完成的回调，具体实现在这里就不赘述了，可以看源代码进一步了解。</p><p>其实这个方法也完全可以用<code>- dataTaskWithRequest:completionHandler:</code>代替，这就避免了自己手动实现代理和回调的麻烦。</p><p>至此，整个图片上传流程就完成了。如果你自己写一个上传图片方法，其实也完全不用像AF的这么复杂，毕竟AF是要考虑到各种复杂的使用场景，内部的复杂实现可以保证调用更灵活也更方便。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在开发SDK时有上传图片的需求，这个需求用AF的话当然非常简单，多添加一句代码就可以搞定。但为避免第三方耦合并没有使用AFNetworking，这就需要自己走完上传图片的全部流程，所以仔细研究了一下AFNetworking的相关源码，梳理了整个流程，它的流程大致是这样的：&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=”&lt;a href=&quot;http://ogdqxib8j.bkt.clouddn.com/image/png%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0.png&amp;quot;&quot;&gt;http://ogdqxib8j.bkt.clouddn.com/image/png%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0.png&amp;quot;&lt;/a&gt; title:”AFNetworking图片上传流程”&amp;gt;&lt;/p&gt;
&lt;p&gt;看着有点眼花眼花缭乱是吧，没关系，接着往下看，看完这篇文章，你也可以自己封装一套图片上传网络工具类。&lt;/p&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基本原理&lt;/li&gt;
&lt;li&gt;具体实现&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;NSMutableURLRequest&lt;/code&gt;并设置请求方式为&lt;code&gt;POST&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自定义&lt;code&gt;HTTPBodyStream&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;request&lt;/code&gt;进行参数设置&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;NSURLSession&lt;/code&gt;的&lt;code&gt;uploadTaskWithStreamedRequest:&lt;/code&gt;方法发起Post请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="AFNetwork" scheme="http://anye3210.github.io/tags/AFNetwork/"/>
    
    <category term="上传图片" scheme="http://anye3210.github.io/tags/%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    
    <category term="源码解析" scheme="http://anye3210.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【iOS】超简单的思路实现2048游戏</title>
    <link href="http://anye3210.github.io/2017/04/07/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA2048%E6%B8%B8%E6%88%8F/"/>
    <id>http://anye3210.github.io/2017/04/07/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA2048%E6%B8%B8%E6%88%8F/</id>
    <published>2017-04-07T11:01:44.000Z</published>
    <updated>2021-08-22T07:37:24.268Z</updated>
    
    <content type="html"><![CDATA[<p>最近在网上下了一个<a href="https://github.com/austinzheng/iOS-2048">仿2048游戏的Demo</a>，发现里面的实现思路做得比较复杂：将数字块的移动操作封装成模型并保存起来，然后根据操作模型的值对滑块逐块地进行操作，具体的实现方式可以自己下下来感受一下。</p><p>然后我分析了一下这个游戏，重新整理了一种更简单的实现思路，大体可以分为三步：</p><ul><li><strong>界面布局</strong></li><li><strong>数字块操作</strong></li><li>按方向把所有数字块分成4组，然后进行排序</li><li>查找邻近相同数字块，计算该行（列）合并后的块数</li><li>按方向整行（列）同时移动数字块</li><li>移动块的同时随机添加数字块</li><li><strong>游戏结束重置游戏</strong></li></ul><p>实现效果如下：</p><img src="http://ogdqxib8j.bkt.clouddn.com/2048.gif" width="203" height="384"><span id="more"></span><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>##界面布局<br>界面布局是最简单的一步，主要分为三大块：分数栏，游戏背景板和数字块背景，以下是代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupUI</span>()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> boardWH <span class="operator">=</span> <span class="type">SCREEN_WIDTH</span> <span class="operator">-</span> boardLeftMargin <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> gameBoard <span class="operator">=</span> <span class="type">ZYGameBoard</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: boardWH, height: boardWH))</span><br><span class="line">    gameBoard.center <span class="operator">=</span> view.center</span><br><span class="line">    view.addSubview(gameBoard)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cellWH <span class="operator">=</span> (gameBoard.frame.width <span class="operator">-</span> margin <span class="operator">*</span> <span class="type">CGFloat</span>(cellRowCount <span class="operator">+</span> <span class="number">1</span>)) <span class="operator">/</span> <span class="type">CGFloat</span>(cellRowCount)</span><br><span class="line">    <span class="keyword">let</span> scoreW <span class="operator">=</span> cellWH <span class="operator">*</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">let</span> scoreH <span class="operator">=</span> cellWH <span class="operator">*</span> <span class="number">0.9</span></span><br><span class="line">    scoreView <span class="operator">=</span> <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: scoreW, height: scoreH))</span><br><span class="line">    scoreView<span class="operator">?</span>.center <span class="operator">=</span> <span class="type">CGPoint</span>(x: <span class="type">SCREEN_WIDTH</span> <span class="operator">/</span> <span class="number">2</span>, y: gameBoard.frame.minY <span class="operator">-</span> margin <span class="operator">*</span> <span class="number">2</span> <span class="operator">-</span> scoreH <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">    scoreView<span class="operator">?</span>.font <span class="operator">=</span> <span class="type">UIFont</span>.boldSystemFont(ofSize: <span class="number">20</span>)</span><br><span class="line">    scoreView<span class="operator">?</span>.textAlignment <span class="operator">=</span> .center</span><br><span class="line">    scoreView<span class="operator">?</span>.textColor <span class="operator">=</span> <span class="type">UIColor</span>.white</span><br><span class="line">    scoreView<span class="operator">?</span>.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.gray</span><br><span class="line">    scoreView<span class="operator">?</span>.text <span class="operator">=</span> <span class="string">&quot;SCORE:0&quot;</span></span><br><span class="line">    scoreView<span class="operator">?</span>.layer.cornerRadius <span class="operator">=</span> <span class="number">8</span></span><br><span class="line">    scoreView<span class="operator">?</span>.clipsToBounds <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    view.addSubview(scoreView<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>ZYGameBoard</code>是一个自定义<code>View</code>，在自定义<code>View</code>是里面添加了数字块的背景还有所有的数字块移动逻辑，以下是<code>ZYGameBoard</code>的界面布局：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.black</span><br><span class="line"><span class="keyword">self</span>.layer.cornerRadius <span class="operator">=</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">self</span>.clipsToBounds <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>cellRowCount <span class="operator">*</span> cellRowCount &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> row <span class="operator">=</span> index <span class="operator">/</span> cellRowCount</span><br><span class="line">    <span class="keyword">let</span> column <span class="operator">=</span> index <span class="operator">%</span> cellRowCount</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cellBgView <span class="operator">=</span> <span class="type">UIView</span>(frame: tileCellFrame(row: row, column: column))</span><br><span class="line">    cellBgView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.darkGray</span><br><span class="line">    cellBgView.layer.cornerRadius <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">    cellBgView.clipsToBounds <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.addSubview(cellBgView)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，还需要定义数据块的自定义View:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZYTileCell</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> isCombined <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> tilePath : <span class="type">ZYTilePath</span></span><br><span class="line"><span class="keyword">let</span> cellID : <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">init</span>(<span class="params">indexPath</span>: <span class="type">ZYTilePath</span>, <span class="params">cellID</span> : <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.tilePath <span class="operator">=</span> indexPath</span><br><span class="line">    <span class="keyword">self</span>.cellID <span class="operator">=</span> cellID</span><br><span class="line">    <span class="keyword">let</span> cellWH <span class="operator">=</span> (<span class="type">SCREEN_WIDTH</span> <span class="operator">-</span> boardLeftMargin <span class="operator">*</span> <span class="number">2</span> <span class="operator">-</span> margin <span class="operator">*</span> <span class="type">CGFloat</span>(cellRowCount <span class="operator">+</span> <span class="number">1</span>)) <span class="operator">/</span> <span class="type">CGFloat</span>(cellRowCount)</span><br><span class="line">    <span class="keyword">let</span> cellX <span class="operator">=</span> <span class="type">CGFloat</span>(indexPath.column) <span class="operator">*</span> (cellWH <span class="operator">+</span> margin) <span class="operator">+</span> margin</span><br><span class="line">    <span class="keyword">let</span> cellY <span class="operator">=</span> <span class="type">CGFloat</span>(indexPath.row) <span class="operator">*</span> (cellWH <span class="operator">+</span> margin) <span class="operator">+</span> margin</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: cellX, y: cellY, width: cellWH, height: cellWH))</span><br><span class="line">    <span class="keyword">self</span>.font <span class="operator">=</span> <span class="type">UIFont</span>.boldSystemFont(ofSize: <span class="number">25</span>)</span><br><span class="line">    <span class="keyword">self</span>.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.clear</span><br><span class="line">    <span class="keyword">self</span>.textColor <span class="operator">=</span> <span class="type">UIColor</span>.rgbColor(red: <span class="number">119</span>, green: <span class="number">110</span>, blue: <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">self</span>.layer.cornerRadius <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">    <span class="keyword">self</span>.clipsToBounds <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.textAlignment <span class="operator">=</span> .center</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中省略了不同数字块颜色的定义，具体的可以看本文的源代码，见文末。<br>至此，界面布局部分就完成了。</p><h2 id="数字块操作"><a href="#数字块操作" class="headerlink" title="数字块操作"></a>数字块操作</h2><p>这部分为整个游戏的核心部分，在这部分之前，需要对4个方向添加不同的swipe手势，每个手势添加不同的响应方法，这里略过了，以下具体讲响应方法的具体实现：</p><h3 id="按方向把所有数字块分成4组，然后进行排序"><a href="#按方向把所有数字块分成4组，然后进行排序" class="headerlink" title="按方向把所有数字块分成4组，然后进行排序"></a>按方向把所有数字块分成4组，然后进行排序</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cellLines <span class="operator">=</span> [[<span class="type">ZYTileCell</span>]]()</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">4</span> &#123;</span><br><span class="line">    cellLines.append([<span class="type">ZYTileCell</span>]())</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> tileCell <span class="keyword">in</span> tileCells &#123;</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>cellLines.count &#123;</span><br><span class="line">        <span class="keyword">if</span> ((direction <span class="operator">==</span> .up <span class="operator">||</span> direction <span class="operator">==</span> .down) <span class="operator">&amp;&amp;</span> tileCell.tilePath.column <span class="operator">==</span> index) <span class="operator">||</span> ((direction <span class="operator">==</span> .left <span class="operator">||</span> direction <span class="operator">==</span> .right) <span class="operator">&amp;&amp;</span> tileCell.tilePath.row <span class="operator">==</span> index) &#123;</span><br><span class="line">            cellLines[index].append(tileCell)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sortWay : (<span class="type">ZYTileCell</span>, <span class="type">ZYTileCell</span>) -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="keyword">switch</span> direction &#123;</span><br><span class="line"><span class="keyword">case</span> .up:</span><br><span class="line">    sortWay <span class="operator">=</span> &#123; (cell1, cell2) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> cell1.tilePath.row <span class="operator">&lt;</span> cell2.tilePath.row</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> .down:</span><br><span class="line">    sortWay <span class="operator">=</span> &#123; (cell1, cell2) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> cell1.tilePath.row <span class="operator">&gt;</span> cell2.tilePath.row</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> .left:</span><br><span class="line">    sortWay <span class="operator">=</span> &#123; (cell1, cell2) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> cell1.tilePath.column <span class="operator">&lt;</span> cell2.tilePath.column</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">case</span> .right:</span><br><span class="line">    sortWay <span class="operator">=</span> &#123; (cell1, cell2) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> cell1.tilePath.column <span class="operator">&gt;</span> cell2.tilePath.column</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> combinedCellLines <span class="operator">=</span> [[<span class="type">ZYTileCell</span>]]()</span><br><span class="line">isAnyLineSameNumExist <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>cellLines.count &#123;</span><br><span class="line">    <span class="keyword">let</span> sortedLine <span class="operator">=</span> cellLines[index].sorted(by: sortWay)</span><br><span class="line">    cellLines[index] <span class="operator">=</span> sortedLine</span><br><span class="line">    combinedCellLines.append(findSameNumAndCombine(needMove: needMove, sortedCells: sortedLine))</span><br><span class="line">    <span class="keyword">if</span> isSameNumExist &#123;</span><br><span class="line">        isAnyLineSameNumExist <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找邻近相同数字块，计算该行（列）合并后的块数"><a href="#查找邻近相同数字块，计算该行（列）合并后的块数" class="headerlink" title="查找邻近相同数字块，计算该行（列）合并后的块数"></a>查找邻近相同数字块，计算该行（列）合并后的块数</h3><p>接下来把排序后的数组相邻的块进行比较，相同的进行合并，把需要删除的数字块从数组移除并执行移除动画：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">findSameNumAndCombine</span>(<span class="params">needMove</span>: <span class="type">Bool</span>, <span class="params">sortedCells</span>: [<span class="type">ZYTileCell</span>])</span> -&gt; [<span class="type">ZYTileCell</span>] &#123;</span><br><span class="line">    <span class="keyword">if</span> sortedCells.count <span class="operator">&lt;</span> <span class="number">2</span> &#123; <span class="keyword">return</span> sortedCells&#125;</span><br><span class="line">    isSameNumExist <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> newTileCells <span class="operator">=</span> [<span class="type">ZYTileCell</span>]()</span><br><span class="line">    <span class="keyword">for</span> tileCell <span class="keyword">in</span> sortedCells &#123;</span><br><span class="line">        newTileCells.append(tileCell)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> combinedIndex <span class="operator">=</span> <span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> (cellIndex, cell) <span class="keyword">in</span> sortedCells.enumerated() &#123;</span><br><span class="line">        cell.isCombined <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> cellIndex <span class="operator">+</span> <span class="number">1</span> <span class="operator">&lt;</span> sortedCells.count <span class="operator">&amp;&amp;</span> cellIndex <span class="operator">!=</span> combinedIndex <span class="operator">+</span> <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> sortedCells[cellIndex].num <span class="operator">==</span> sortedCells[cellIndex <span class="operator">+</span> <span class="number">1</span>].num &#123;</span><br><span class="line">                <span class="keyword">if</span> needMove &#123;</span><br><span class="line">                    cell.num <span class="operator">=</span> cell.num<span class="operator">!</span> <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> isSameNumExist &#123;</span><br><span class="line">                        newTileCells.remove(at: cellIndex)</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        newTileCells.remove(at: cellIndex <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> extraCell <span class="operator">=</span> sortedCells[cellIndex <span class="operator">+</span> <span class="number">1</span>]</span><br><span class="line">                    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.1</span>, animations: &#123;</span><br><span class="line">                        extraCell.alpha <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">                    &#125;, completion: &#123; (<span class="keyword">_</span>) <span class="keyword">in</span></span><br><span class="line">                        extraCell.removeFromSuperview()</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="keyword">var</span> index <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> tileCell <span class="keyword">in</span> tileCells &#123;</span><br><span class="line">                        <span class="keyword">if</span> extraCell.cellID <span class="operator">==</span> tileCell.cellID &#123;</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        index <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> index <span class="operator">&lt;</span> tileCells.count &#123;</span><br><span class="line">                        tileCells.remove(at: index)</span><br><span class="line">                    &#125;</span><br><span class="line">                    cell.isCombined <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">if</span> scoreChanged <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                        scoreChanged<span class="operator">!</span>(cell.num<span class="operator">!</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                combinedIndex <span class="operator">=</span> cellIndex</span><br><span class="line">                isSameNumExist <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTileCells</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的方法里有一个细节就是如果所有的数字块满了，需要挨个模拟各个方向的滑动，在这个方法里判断是否有可以合并的数字块，如果有游戏继续，否则游戏结束。</p><h3 id="按方向整行（列）同时移动数字块"><a href="#按方向整行（列）同时移动数字块" class="headerlink" title="按方向整行（列）同时移动数字块"></a>按方向整行（列）同时移动数字块</h3><p>接下来就可以真正地开始移动数字块了，移动数字块的思路就是<strong>计算出整行或者整列的数字块移动后的最终位置，然后用最终位置和初始位置的差确定位置的距离和方向</strong>。</p><p>思路虽然是这样，但在写代码的时候要简单得多，直接遍历整行（整列的）排序后的数字块，下标为最终位置，自身的坐标为初始位置，用这两个值即可计算出位移，坐标轴如下：</p><img src="http://ogdqxib8j.bkt.clouddn.com/2048X_Y.jpeg" width="200"><p>实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">moveTile</span>(<span class="params">direction</span>: <span class="type">ZYDirection</span>, <span class="params">cellLines</span>: [[<span class="type">ZYTileCell</span>]], <span class="params">combinedCellLines</span>: [[<span class="type">ZYTileCell</span>]])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (lineIndex, lineCells) <span class="keyword">in</span> cellLines.enumerated() &#123;</span><br><span class="line">        <span class="keyword">var</span> needMoreStep <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (index, originCell) <span class="keyword">in</span> lineCells.enumerated() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> combinedCells <span class="operator">=</span> combinedCellLines[lineIndex]</span><br><span class="line">            <span class="keyword">var</span> toIndex <span class="operator">=</span> index</span><br><span class="line">            <span class="keyword">var</span> distance : <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> cellFrame <span class="operator">=</span> originCell.frame</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> toIndex <span class="operator">&gt;</span> combinedCells.count <span class="operator">-</span> <span class="number">1</span> &#123;</span><br><span class="line">                toIndex <span class="operator">=</span> combinedCells.count <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> delta <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> needMoreStep &#123;</span><br><span class="line">                delta <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span> direction &#123;</span><br><span class="line">            <span class="keyword">case</span> .up:</span><br><span class="line">                distance <span class="operator">=</span> <span class="type">CGFloat</span>(toIndex <span class="operator">-</span> originCell.tilePath.row <span class="operator">-</span> delta) <span class="operator">*</span> (originCell.frame.height <span class="operator">+</span> margin)</span><br><span class="line">                cellFrame.origin.y <span class="operator">+=</span> distance</span><br><span class="line">                originCell.tilePath <span class="operator">=</span> <span class="type">ZYTilePath</span>(row: toIndex, column: lineIndex)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> .down:</span><br><span class="line">                toIndex <span class="operator">=</span> <span class="number">3</span> <span class="operator">-</span> toIndex</span><br><span class="line">                distance <span class="operator">=</span> <span class="type">CGFloat</span>(toIndex <span class="operator">-</span> originCell.tilePath.row <span class="operator">+</span> delta) <span class="operator">*</span> (originCell.frame.height <span class="operator">+</span> margin)</span><br><span class="line">                cellFrame.origin.y <span class="operator">+=</span> distance</span><br><span class="line">                originCell.tilePath <span class="operator">=</span> <span class="type">ZYTilePath</span>(row: toIndex, column: lineIndex)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> .left:</span><br><span class="line">                distance <span class="operator">=</span> <span class="type">CGFloat</span>(toIndex <span class="operator">-</span> originCell.tilePath.column <span class="operator">-</span> delta) <span class="operator">*</span> (originCell.frame.height <span class="operator">+</span> margin)</span><br><span class="line">                cellFrame.origin.x <span class="operator">+=</span> distance</span><br><span class="line">                originCell.tilePath <span class="operator">=</span> <span class="type">ZYTilePath</span>(row: lineIndex, column: toIndex)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> .right:</span><br><span class="line">                toIndex <span class="operator">=</span> <span class="number">3</span> <span class="operator">-</span> toIndex</span><br><span class="line">                distance <span class="operator">=</span> <span class="type">CGFloat</span>(toIndex <span class="operator">-</span> originCell.tilePath.column <span class="operator">+</span> delta) <span class="operator">*</span> (originCell.frame.height <span class="operator">+</span> margin)</span><br><span class="line">                cellFrame.origin.x <span class="operator">+=</span> distance</span><br><span class="line">                originCell.tilePath <span class="operator">=</span> <span class="type">ZYTilePath</span>(row: lineIndex, column: toIndex)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            needMoreStep <span class="operator">=</span> originCell.isCombined</span><br><span class="line">            <span class="keyword">if</span> distance <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">                <span class="type">UIView</span>.animate(withDuration: <span class="number">0.1</span>, animations: &#123;</span><br><span class="line">                    originCell.frame <span class="operator">=</span> cellFrame</span><br><span class="line">                &#125;, completion: &#123; (<span class="keyword">_</span>) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">if</span> originCell.isCombined <span class="operator">==</span> <span class="literal">false</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                    originCell.transform <span class="operator">=</span> <span class="type">CGAffineTransform</span>(scaleX: <span class="number">0.8</span>, y: <span class="number">0.8</span>)</span><br><span class="line">                    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.1</span>, usingSpringWithDamping: <span class="number">0.5</span>, initialSpringVelocity: <span class="number">0.5</span>, options: <span class="type">UIViewAnimationOptions</span>(rawValue: <span class="number">0</span>), animations: &#123;</span><br><span class="line">                        originCell.transform <span class="operator">=</span> <span class="type">CGAffineTransform</span>.identity</span><br><span class="line">                    &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码对该行存在合并数字块的情况进行了处理：如果该行有数字块合并了（即保留前面一块，移除后面一块），后面所有块都会多移一步，避免中间出现空白。</p><p>至此，移动数字块部分也完成了，接下来就是随机添加数字块了。</p><h3 id="移动块的同时随机添加数字块"><a href="#移动块的同时随机添加数字块" class="headerlink" title="移动块的同时随机添加数字块"></a>移动块的同时随机添加数字块</h3><p>这步应该是数字块操作里面最简单的一步，<strong>从所有可能的坐标数组中删除有数字块的元素，剩下都是没有数字块的坐标，在这些坐标中随机选一个添加数字块即可</strong>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">addRandomTileCell</span>()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> tilePaths <span class="operator">=</span> [<span class="type">ZYTilePath</span>]()</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>cellRowCount <span class="operator">*</span> cellRowCount &#123;</span><br><span class="line">        <span class="keyword">let</span> row <span class="operator">=</span> index <span class="operator">/</span> cellRowCount</span><br><span class="line">        <span class="keyword">let</span> column <span class="operator">=</span> index <span class="operator">%</span> cellRowCount</span><br><span class="line">        tilePaths.append(<span class="type">ZYTilePath</span>(row: row, column: column))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> tileCells.count <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> tileCell <span class="keyword">in</span> tileCells &#123;</span><br><span class="line">            <span class="keyword">for</span> (index, tilePath) <span class="keyword">in</span> tilePaths.enumerated() &#123;</span><br><span class="line">                <span class="keyword">if</span> tileCell.tilePath.row <span class="operator">==</span> tilePath.row <span class="operator">&amp;&amp;</span> tileCell.tilePath.column <span class="operator">==</span> tilePath.column &#123;</span><br><span class="line">                    tilePaths.remove(at: index)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> randomTilePath <span class="operator">=</span> tilePaths[<span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(tilePaths.count) <span class="operator">-</span> <span class="number">1</span>))]</span><br><span class="line">    <span class="keyword">let</span> tileCell <span class="operator">=</span> <span class="type">ZYTileCell</span>(indexPath: randomTilePath, cellID: currentID)</span><br><span class="line">    currentID <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    tileCell.num <span class="operator">=</span> arc4random() <span class="operator">%</span> <span class="number">3</span> <span class="operator">==</span> <span class="number">0</span> <span class="operator">?</span> <span class="number">4</span> : <span class="number">2</span></span><br><span class="line">    tileCells.append(tileCell)</span><br><span class="line">    tileCell.frame <span class="operator">=</span> tileCellFrame(row: randomTilePath.row, column: randomTilePath.column)</span><br><span class="line">    addSubview(tileCell)</span><br><span class="line">    </span><br><span class="line">    tileCell.transform <span class="operator">=</span> <span class="type">CGAffineTransform</span>(scaleX: <span class="number">0.2</span>, y: <span class="number">0.2</span>)</span><br><span class="line">    <span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, delay: <span class="number">0.1</span>, usingSpringWithDamping: <span class="number">0.5</span>, initialSpringVelocity: <span class="number">0.5</span>, options: <span class="type">UIViewAnimationOptions</span>(rawValue: <span class="number">0</span>), animations: &#123;</span><br><span class="line">        tileCell.transform <span class="operator">=</span> <span class="type">CGAffineTransform</span>.identity</span><br><span class="line">    &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在添加数字块的同时，如果剩余空坐标为0，那么就要进行游戏是否结束的验证，如果游戏结束，就以闭包的形式在控制器进行弹窗操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断游戏是否结束</span></span><br><span class="line"><span class="keyword">if</span> tilePaths.count <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">    swipeAction(direction: .up,    needMove: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">let</span> upSameNumExist <span class="operator">=</span> isAnyLineSameNumExist</span><br><span class="line">    swipeAction(direction: .down,  needMove: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">let</span> downSameNumExist <span class="operator">=</span> isAnyLineSameNumExist</span><br><span class="line">    swipeAction(direction: .left,  needMove: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">let</span> leftSameNumExist <span class="operator">=</span> isAnyLineSameNumExist</span><br><span class="line">    swipeAction(direction: .right, needMove: <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">let</span> rightSameNumExist <span class="operator">=</span> isAnyLineSameNumExist</span><br><span class="line">    <span class="keyword">if</span> gameOver <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> <span class="operator">!</span>(upSameNumExist <span class="operator">||</span> downSameNumExist <span class="operator">||</span> leftSameNumExist <span class="operator">||</span> rightSameNumExist) &#123;</span><br><span class="line">        gameOver<span class="operator">!</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果游戏结束，在控制器进行操作</span></span><br><span class="line">gameBoard.gameOver <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> alertContr <span class="operator">=</span> <span class="type">UIAlertController</span>(title: <span class="string">&quot;提示&quot;</span>, message: <span class="string">&quot;游戏失败，请重试&quot;</span>, preferredStyle: .alert)</span><br><span class="line">    <span class="keyword">let</span> confirmAction <span class="operator">=</span> <span class="type">UIAlertAction</span>(title: <span class="string">&quot;确定&quot;</span>, style: .default, handler: &#123; (alertAction) <span class="keyword">in</span></span><br><span class="line">        gameBoard.resetGame()</span><br><span class="line">        <span class="keyword">self</span>.score <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    alertContr.addAction(confirmAction)</span><br><span class="line">    <span class="keyword">self</span>.present(alertContr, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游戏结束重置游戏"><a href="#游戏结束重置游戏" class="headerlink" title="游戏结束重置游戏"></a>游戏结束重置游戏</h2><p>接下来就是最后一步，重置游戏数据：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resetGame</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> tileCell <span class="keyword">in</span> <span class="keyword">self</span>.tileCells &#123;</span><br><span class="line">        tileCell.removeFromSuperview()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.tileCells.removeAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，大功告成，现在可以装到手机上玩儿一把了。</p><p><a href="https://github.com/zephyrw/2048">看本文源代码点这里</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在网上下了一个&lt;a href=&quot;https://github.com/austinzheng/iOS-2048&quot;&gt;仿2048游戏的Demo&lt;/a&gt;，发现里面的实现思路做得比较复杂：将数字块的移动操作封装成模型并保存起来，然后根据操作模型的值对滑块逐块地进行操作，具体的实现方式可以自己下下来感受一下。&lt;/p&gt;
&lt;p&gt;然后我分析了一下这个游戏，重新整理了一种更简单的实现思路，大体可以分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;界面布局&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字块操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;按方向把所有数字块分成4组，然后进行排序&lt;/li&gt;
&lt;li&gt;查找邻近相同数字块，计算该行（列）合并后的块数&lt;/li&gt;
&lt;li&gt;按方向整行（列）同时移动数字块&lt;/li&gt;
&lt;li&gt;移动块的同时随机添加数字块&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;游戏结束重置游戏&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现效果如下：&lt;/p&gt;
&lt;img src=&quot;http://ogdqxib8j.bkt.clouddn.com/2048.gif&quot; width=&quot;203&quot; height=&quot;384&quot;&gt;</summary>
    
    
    
    
    <category term="2048" scheme="http://anye3210.github.io/tags/2048/"/>
    
    <category term="swift" scheme="http://anye3210.github.io/tags/swift/"/>
    
    <category term="Game" scheme="http://anye3210.github.io/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>CAShapeLayer文字动画</title>
    <link href="http://anye3210.github.io/2017/02/23/%E5%88%B6%E4%BD%9C%E6%96%87%E5%AD%97%E5%8A%A8%E7%94%BB/"/>
    <id>http://anye3210.github.io/2017/02/23/%E5%88%B6%E4%BD%9C%E6%96%87%E5%AD%97%E5%8A%A8%E7%94%BB/</id>
    <published>2017-02-23T15:10:17.000Z</published>
    <updated>2021-08-22T07:39:08.618Z</updated>
    
    <content type="html"><![CDATA[<p>文字动画也是<code>CAShapeLayer</code>图形动画的一种，巧妙运用文字动画可以实现很不错的效果，比如半糖app的下拉动画。本文就主要讲一下其实现原理。</p><p>文字动画主要分为两部分：</p><ul><li><p>将文字转化为<code>CAShapeLayer</code></p></li><li><p>通过更改<code>CAShapeLayer</code>的StrokeEnd属性值生成动画</p><span id="more"></span><h2 id="将文字转换为CAShapeLayer"><a href="#将文字转换为CAShapeLayer" class="headerlink" title="将文字转换为CAShapeLayer"></a>将文字转换为CAShapeLayer</h2><p>将文字转换为<code>CAShapeLayer</code>的过程比较复杂，可以细分为以下几个步骤：</p></li><li><p>创建<code>NSAttributedString</code>并生成<code>CTLineRef</code></p></li><li><p>使用<code>CTLineRef</code>生成<code>CTRunRef</code>数组</p></li><li><p>遍历<code>CTRunRef</code>数组，得到每个<code>CTRunRef</code></p></li><li><p>遍历<code>CTRunRef</code>中每个长度为1的区间生成<code>CGGlyph</code>并转换为<code>CGPath</code>路径，将所有路径拼接起来</p></li><li><p>创建<code>ShapeLayer</code>并将生成的路径赋值给该<code>ShapeLayer</code></p></li></ul><p>以下是每个步骤的实现方式：</p><h4 id="创建NSAttributedString并生成CTLineRef"><a href="#创建NSAttributedString并生成CTLineRef" class="headerlink" title="创建NSAttributedString并生成CTLineRef"></a>创建NSAttributedString并生成CTLineRef</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义字体属性</span><br><span class="line">CTFontRef font = CTFontCreateWithName(CFSTR(&quot;HelveticaNeue-UltraLight&quot;), fontSize, NULL);</span><br><span class="line">NSDictionary *attrs = [NSDictionary dictionaryWithObjectsAndKeys:(__bridge id)font, kCTFontAttributeName,nil];</span><br><span class="line">// 创建NSAttributedString</span><br><span class="line">NSAttributedString *str = [[NSAttributedString alloc] initWithString:text attributes:attrs];</span><br><span class="line">CTLineRef line = CTLineCreateWithAttributedString((CFAttributedStringRef)str);</span><br></pre></td></tr></table></figure><h4 id="使用CTLineRef生成CTRunRef数组"><a href="#使用CTLineRef生成CTRunRef数组" class="headerlink" title="使用CTLineRef生成CTRunRef数组"></a>使用CTLineRef生成CTRunRef数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CTLineRef line = CTLineCreateWithAttributedString((CFAttributedStringRef)str);</span><br><span class="line">CFArrayRef runArray = CTLineGetGlyphRuns(line);</span><br></pre></td></tr></table></figure><h4 id="遍历CTRunRef数组，得到每个CTRunRef"><a href="#遍历CTRunRef数组，得到每个CTRunRef" class="headerlink" title="遍历CTRunRef数组，得到每个CTRunRef"></a>遍历CTRunRef数组，得到每个CTRunRef</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (CFIndex runIndex = 0; runIndex &lt; CFArrayGetCount(runArray); runIndex++) &#123;</span><br><span class="line">// </span><br><span class="line">CTRunRef run = (CTRunRef)CFArrayGetValueAtIndex(runArray, runIndex);</span><br><span class="line">CTFontRef runFont = CFDictionaryGetValue(CTRunGetAttributes(run), kCTFontAttributeName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历CTRunRef中每个长度为1的区间生成CGGlyph并转换为CGPath路径，将所有路径拼接起来"><a href="#遍历CTRunRef中每个长度为1的区间生成CGGlyph并转换为CGPath路径，将所有路径拼接起来" class="headerlink" title="遍历CTRunRef中每个长度为1的区间生成CGGlyph并转换为CGPath路径，将所有路径拼接起来"></a>遍历CTRunRef中每个长度为1的区间生成CGGlyph并转换为CGPath路径，将所有路径拼接起来</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (CFIndex glyphIndex = 0; glyphIndex &lt; CTRunGetGlyphCount(run); glyphIndex++) &#123;</span><br><span class="line">      </span><br><span class="line">CGGlyph glyph;</span><br><span class="line">CGPoint position;</span><br><span class="line">CFRange currentRange = CFRangeMake(glyphIndex, 1);</span><br><span class="line">CTRunGetGlyphs(run, currentRange, &amp;glyph);</span><br><span class="line">CTRunGetPositions(run, currentRange, &amp;position);</span><br><span class="line">            </span><br><span class="line">CGPathRef letter = CTFontCreatePathForGlyph(runFont, glyph, NULL);</span><br><span class="line">CGAffineTransform t = CGAffineTransformMakeTranslation(position.x, position.y);</span><br><span class="line">CGPathAddPath(letters, &amp;t, letter);</span><br><span class="line">CGPathRelease(letter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建ShapeLayer并将生成的路径赋值给该ShapeLayer"><a href="#创建ShapeLayer并将生成的路径赋值给该ShapeLayer" class="headerlink" title="创建ShapeLayer并将生成的路径赋值给该ShapeLayer"></a>创建ShapeLayer并将生成的路径赋值给该ShapeLayer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建UIBezierPath</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPathWithCGPath:letters];</span><br><span class="line">// 创建并配置CAShapeLayer</span><br><span class="line">CAShapeLayer *pathLayer = [CAShapeLayer layer];</span><br><span class="line">pathLayer.frame = self.bounds;</span><br><span class="line">pathLayer.bounds = CGPathGetBoundingBox(path.CGPath);</span><br><span class="line">pathLayer.geometryFlipped = YES;</span><br><span class="line">pathLayer.path = path.CGPath;</span><br><span class="line">pathLayer.strokeColor = fontColor.CGColor;</span><br><span class="line">pathLayer.fillColor = nil;</span><br><span class="line">pathLayer.lineWidth = 1.0f;</span><br><span class="line">pathLayer.lineJoin = kCALineJoinBevel;</span><br><span class="line">pathLayer.strokeStart = 0;</span><br><span class="line">pathLayer.strokeEnd = 0;</span><br></pre></td></tr></table></figure><p>最后，将ShapeLayer添加到动画图层中就行了</p><h2 id="生成文字动画"><a href="#生成文字动画" class="headerlink" title="生成文字动画"></a>生成文字动画</h2><p>通过改变ShapeLayer的StrokeEnd属性值就可以生成文字动画</p><h4 id="添加Slider"><a href="#添加Slider" class="headerlink" title="添加Slider"></a>添加Slider</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupSlider &#123;</span><br><span class="line">    CGFloat leftMargin = 20;</span><br><span class="line">    UISlider *slider = [[UISlider alloc] initWithFrame:CGRectMake(leftMargin, kMainHeight - 30, kMainWidth - leftMargin * 2, 3)];</span><br><span class="line">    slider.minimumValue = 0;</span><br><span class="line">    slider.maximumValue = 1;</span><br><span class="line">    [self.view addSubview:slider];</span><br><span class="line">    [slider addTarget:self action:@selector(sliderValueChanged:) forControlEvents:UIControlEventValueChanged];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Slider的ValueChange方法"><a href="#实现Slider的ValueChange方法" class="headerlink" title="实现Slider的ValueChange方法"></a>实现Slider的ValueChange方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)sliderValueChanged:(UISlider *)sender &#123;</span><br><span class="line">    self.pathLayer.strokeEnd = sender.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个文字动画就完成了</p><p>本文demo的github地址：<a><a href="https://github.com/zephyrw/TextAnimationDemo.git">https://github.com/zephyrw/TextAnimationDemo.git</a></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文字动画也是&lt;code&gt;CAShapeLayer&lt;/code&gt;图形动画的一种，巧妙运用文字动画可以实现很不错的效果，比如半糖app的下拉动画。本文就主要讲一下其实现原理。&lt;/p&gt;
&lt;p&gt;文字动画主要分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将文字转化为&lt;code&gt;CAShapeLayer&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过更改&lt;code&gt;CAShapeLayer&lt;/code&gt;的StrokeEnd属性值生成动画&lt;/p&gt;</summary>
    
    
    
    
    <category term="ShapeLayer" scheme="http://anye3210.github.io/tags/ShapeLayer/"/>
    
    <category term="Animation" scheme="http://anye3210.github.io/tags/Animation/"/>
    
    <category term="动画" scheme="http://anye3210.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
    <category term="文字" scheme="http://anye3210.github.io/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>CAShapeLayer的使用</title>
    <link href="http://anye3210.github.io/2017/02/23/CAShapeLayer%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://anye3210.github.io/2017/02/23/CAShapeLayer%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2017-02-23T14:40:24.000Z</published>
    <updated>2021-08-22T07:39:38.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>官方文档对<code>CAShapeLayer</code>的定义如下：</p><blockquote><p>A layer that draws a cubic Bezier spline in its coordinate space.</p></blockquote><p>可以理解为<code>CAShapeLayer</code>是其坐标空间内绘有贝塞尔曲线的图层。<br>使用<code>CAShapeLayer</code>可以制作蒙板和图层动画，它继承自CALayer，拥有<code>CALayer</code>的全部属性。<code>CAShapeLayer</code>的依赖于贝塞尔曲线<code>UIBezierPath</code>，它决定的ShapeLayer的形状。</p><p><code>StrokeStart</code>和<code>StrokeEnd</code>是<code>ShapeLayer</code>的重要属性，它控制<code>ShapeLayer</code>的<code>cgPath</code>路径的绘制起点和终点，区间都为0~1，0代表从头绘制，1代表绘制到终点。</p><span id="more"></span><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><strong>ShapeLayer图形动画</strong></li><li><strong>ShapeLayer蒙版</strong></li></ul><p>本文demo的github地址：<a><a href="https://github.com/zephyrw/ShapeLayerDemo.git">https://github.com/zephyrw/ShapeLayerDemo.git</a></a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="ShapeLayer图形动画"><a href="#ShapeLayer图形动画" class="headerlink" title="ShapeLayer图形动画"></a>ShapeLayer图形动画</h2><h3 id="动画简介"><a href="#动画简介" class="headerlink" title="动画简介"></a>动画简介</h3><p>使用ShapeLayer制作动画原理是通过改变ShapeLayer的strokeEnd属性值来改变ShapeLayer的path的绘制，strokeEnd值区间为0~1</p><p>下图为使用ShapeLayer制作仿今日头条下拉动画效果</p><img src="http://ogdqxib8j.bkt.clouddn.com/ShapeLayerAnimation.gif" title="shapeLayer动画" width="200" height="400"><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>把整个图形分成三个部分：外边框、左上角的框和所有的横线，分别用贝塞尔曲线绘制这三个部分</p><h5 id="外边框"><a href="#外边框" class="headerlink" title="外边框"></a>外边框</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> draftPath <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: width, height: height), cornerRadius: <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h5 id="左上角边框"><a href="#左上角边框" class="headerlink" title="左上角边框"></a>左上角边框</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squarePath <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: <span class="type">CGRect</span>(x: margin, y: margin, width: smallSquareWH, height: smallSquareWH), cornerRadius: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="所有横线"><a href="#所有横线" class="headerlink" title="所有横线"></a>所有横线</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> linePath <span class="operator">=</span> <span class="type">UIBezierPath</span>()       </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">3</span> &#123;</span><br><span class="line">linePath.move(to: <span class="type">CGPoint</span>(x: shortLineLeft, y: margin <span class="operator">+</span> <span class="number">2</span> <span class="operator">+</span> space <span class="operator">*</span> <span class="type">CGFloat</span>(i)))</span><br><span class="line">linePath.addLine(to: <span class="type">CGPoint</span>(x: shortLineRight, y: margin <span class="operator">+</span> <span class="number">2</span> <span class="operator">+</span> space <span class="operator">*</span> <span class="type">CGFloat</span>(i)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="number">3</span> &#123;</span><br><span class="line">linePath.move(to: <span class="type">CGPoint</span>(x: margin, y: margin <span class="operator">*</span> <span class="number">2</span> <span class="operator">+</span> <span class="number">2</span> <span class="operator">+</span> smallSquareWH <span class="operator">+</span> space <span class="operator">*</span> <span class="type">CGFloat</span>(i)))</span><br><span class="line">linePath.addLine(to: <span class="type">CGPoint</span>(x: longLineRight, y: margin <span class="operator">*</span> <span class="number">2</span> <span class="operator">+</span> <span class="number">2</span> <span class="operator">+</span> smallSquareWH <span class="operator">+</span> space <span class="operator">*</span> <span class="type">CGFloat</span>(i)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="将所有贝塞尔曲线绘制到ShapeLayer中"><a href="#将所有贝塞尔曲线绘制到ShapeLayer中" class="headerlink" title="将所有贝塞尔曲线绘制到ShapeLayer中"></a>将所有贝塞尔曲线绘制到ShapeLayer中</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.draftShapeLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line"><span class="keyword">self</span>.draftShapeLayer<span class="operator">!</span>.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: width, height: height)</span><br><span class="line">setupShapeLayer(shapeLayer: <span class="keyword">self</span>.draftShapeLayer<span class="operator">!</span>, path: draftPath.cgPath)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">self</span>.squareShapeLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line"><span class="keyword">self</span>.squareShapeLayer<span class="operator">!</span>.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: smallSquareWH, height: smallSquareWH)</span><br><span class="line">setupShapeLayer(shapeLayer: <span class="keyword">self</span>.squareShapeLayer<span class="operator">!</span>, path: squarePath.cgPath)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">self</span>.lineShapeLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line"><span class="keyword">self</span>.lineShapeLayer<span class="operator">!</span>.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: width, height: height)</span><br><span class="line">setupShapeLayer(shapeLayer: <span class="keyword">self</span>.lineShapeLayer<span class="operator">!</span>, path: linePath.cgPath)</span><br></pre></td></tr></table></figure><p>这里抽出了辅助方法来设置ShapeLayer和添加到控制器图层</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupShapeLayer</span>(<span class="params">shapeLayer</span> : <span class="type">CAShapeLayer</span>, <span class="params">path</span> : <span class="type">CGPath</span>)</span> &#123;</span><br><span class="line">shapeLayer.path <span class="operator">=</span> path</span><br><span class="line">shapeLayer.strokeColor <span class="operator">=</span> <span class="type">UIColor</span>.gray.cgColor</span><br><span class="line">shapeLayer.fillColor <span class="operator">=</span> <span class="type">UIColor</span>.white.cgColor</span><br><span class="line">shapeLayer.lineWidth <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">shapeLayer.strokeStart <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">shapeLayer.strokeEnd <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">self</span>.containerLayer.addSublayer(shapeLayer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加SliderView"><a href="#添加SliderView" class="headerlink" title="添加SliderView"></a>添加SliderView</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">addSlider</span>()</span> &#123;</span><br><span class="line"><span class="keyword">let</span> slider <span class="operator">=</span> <span class="type">UISlider</span>(frame: <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="type">UIScreen</span>.main.bounds.height <span class="operator">-</span> <span class="number">50</span>, width: <span class="type">UIScreen</span>.main.bounds.width <span class="operator">-</span> <span class="number">40</span>, height: <span class="number">10</span>))</span><br><span class="line">slider.minimumValue <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">slider.maximumValue <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">slider.addTarget(<span class="keyword">self</span>, action: #selector(sliderValueChanged(sender:)), for: <span class="type">UIControlEvents</span>.valueChanged)</span><br><span class="line">view.addSubview(slider)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="sliderValuerChanged方法实现"><a href="#sliderValuerChanged方法实现" class="headerlink" title="sliderValuerChanged方法实现"></a>sliderValuerChanged方法实现</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">sliderValueChanged</span>(<span class="params">sender</span>: <span class="type">UISlider</span>)</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> draftShapeLayer <span class="operator">=</span> <span class="keyword">self</span>.draftShapeLayer <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;<span class="keyword">guard</span> <span class="keyword">let</span> squareShapeLayer <span class="operator">=</span> <span class="keyword">self</span>.squareShapeLayer <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> lineShapeLayer <span class="operator">=</span> <span class="keyword">self</span>.lineShapeLayer <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">draftShapeLayer.strokeEnd <span class="operator">=</span> <span class="type">CGFloat</span>(sender.value)</span><br><span class="line">squareShapeLayer.strokeEnd <span class="operator">=</span> <span class="type">CGFloat</span>(sender.value)</span><br><span class="line">lineShapeLayer.strokeEnd <span class="operator">=</span> <span class="type">CGFloat</span>(sender.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>ShapeLayer</code>图形动画就完成了</p><h2 id="ShapeLayer蒙版"><a href="#ShapeLayer蒙版" class="headerlink" title="ShapeLayer蒙版"></a>ShapeLayer蒙版</h2><p>用ShapeLayer创建一个带图形的蒙版如下图</p><p>&lt;img src=’<a href="http://ogdqxib8j.bkt.clouddn.com/MaskImage.png&#39;">http://ogdqxib8j.bkt.clouddn.com/MaskImage.png&#39;</a> width=’200’, height=’400’&gt;</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>新建一个蒙版视图<code>View</code>,然后将绘有贝塞尔曲线的<code>ShapeLayer</code>设置为蒙版视图图层的<code>mask</code></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h5 id="创建蒙版视图并添加到控制器视图"><a href="#创建蒙版视图并添加到控制器视图" class="headerlink" title="创建蒙版视图并添加到控制器视图"></a>创建蒙版视图并添加到控制器视图</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maskView <span class="operator">=</span> <span class="type">UIView</span>(frame: view.bounds)</span><br><span class="line">maskView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.red.withAlphaComponent(<span class="number">0.3</span>)</span><br><span class="line">maskView.alpha <span class="operator">=</span> <span class="number">0.8</span></span><br><span class="line">view.addSubview(maskView)</span><br></pre></td></tr></table></figure><h5 id="用贝塞尔曲线绘制蒙版的形状"><a href="#用贝塞尔曲线绘制蒙版的形状" class="headerlink" title="用贝塞尔曲线绘制蒙版的形状"></a>用贝塞尔曲线绘制蒙版的形状</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bpath <span class="operator">=</span> <span class="type">UIBezierPath</span>(roundedRect: <span class="type">CGRect</span>(x: <span class="number">10</span>, y: <span class="number">10</span>, width: view.bounds.width <span class="operator">-</span> <span class="number">20</span>, height: view.bounds.height <span class="operator">-</span> <span class="number">20</span>), cornerRadius: <span class="number">15</span>)</span><br><span class="line"><span class="keyword">let</span> circlePath <span class="operator">=</span> <span class="type">UIBezierPath</span>(arcCenter: view.center, radius: <span class="number">100</span>, startAngle: <span class="number">0</span>, endAngle: <span class="type">CGFloat</span>(<span class="type">M_PI</span>) <span class="operator">*</span> <span class="number">2</span>, clockwise: <span class="literal">false</span>)</span><br><span class="line">bpath.append(circlePath)</span><br></pre></td></tr></table></figure><h5 id="创建ShapeLayer，设置之前创建的贝塞尔曲线为cgPath"><a href="#创建ShapeLayer，设置之前创建的贝塞尔曲线为cgPath" class="headerlink" title="创建ShapeLayer，设置之前创建的贝塞尔曲线为cgPath"></a>创建ShapeLayer，设置之前创建的贝塞尔曲线为cgPath</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shapeLayer <span class="operator">=</span> <span class="type">CAShapeLayer</span>()</span><br><span class="line">shapeLayer.path <span class="operator">=</span> bpath.cgPath</span><br></pre></td></tr></table></figure><h5 id="将ShapeLayer设为蒙版"><a href="#将ShapeLayer设为蒙版" class="headerlink" title="将ShapeLayer设为蒙版"></a>将ShapeLayer设为蒙版</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maskView.layer.mask <span class="operator">=</span> shapeLayer</span><br></pre></td></tr></table></figure><p>接下来就可以运行看效果了</p><p>本文demo的github地址：<a><a href="https://github.com/zephyrw/ShapeLayerDemo.git">https://github.com/zephyrw/ShapeLayerDemo.git</a></a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;官方文档对&lt;code&gt;CAShapeLayer&lt;/code&gt;的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A layer that draws a cubic Bezier spline in its coordinate space.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以理解为&lt;code&gt;CAShapeLayer&lt;/code&gt;是其坐标空间内绘有贝塞尔曲线的图层。&lt;br&gt;使用&lt;code&gt;CAShapeLayer&lt;/code&gt;可以制作蒙板和图层动画，它继承自CALayer，拥有&lt;code&gt;CALayer&lt;/code&gt;的全部属性。&lt;code&gt;CAShapeLayer&lt;/code&gt;的依赖于贝塞尔曲线&lt;code&gt;UIBezierPath&lt;/code&gt;，它决定的ShapeLayer的形状。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StrokeStart&lt;/code&gt;和&lt;code&gt;StrokeEnd&lt;/code&gt;是&lt;code&gt;ShapeLayer&lt;/code&gt;的重要属性，它控制&lt;code&gt;ShapeLayer&lt;/code&gt;的&lt;code&gt;cgPath&lt;/code&gt;路径的绘制起点和终点，区间都为0~1，0代表从头绘制，1代表绘制到终点。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ShapeLayer" scheme="http://anye3210.github.io/tags/ShapeLayer/"/>
    
    <category term="CALayer" scheme="http://anye3210.github.io/tags/CALayer/"/>
    
    <category term="Animation" scheme="http://anye3210.github.io/tags/Animation/"/>
    
    <category term="动画" scheme="http://anye3210.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
    <category term="下拉" scheme="http://anye3210.github.io/tags/%E4%B8%8B%E6%8B%89/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://anye3210.github.io/2016/12/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://anye3210.github.io/2016/12/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2016-12-21T15:18:35.000Z</published>
    <updated>2021-08-22T07:45:26.772Z</updated>
    
    <content type="html"><![CDATA[<p>以下是对正则表达式学习的一些整理。</p><h3 id="头部尾部"><a href="#头部尾部" class="headerlink" title="头部尾部"></a>头部尾部</h3><p>^ 表示开始 后接字符串 ^one</p><p>$ 表示结束 前接字符串 dog$</p><p>“banana” 必须包含此字符串</p><h3 id="限制个数"><a href="#限制个数" class="headerlink" title="限制个数"></a>限制个数</h3><p>* 0个或更多个  ab*   (a,ab,abbb…)</p><p>+ 1个或更多个  ab+   (ab, abbb…)</p><p>? 0个或1个     ab?    (a, ab)</p><p>{4} 4个       ab{4}  (abbbb)</p><span id="more"></span><p>{1,} 至少1个   ab{1,} (ab, abbb…)</p><p>{3,4} 3个到4个 ab{3,4} (abbb, abbbb)</p><p>注：必须有下限，ab{,5}是错误的</p><h3 id="或"><a href="#或" class="headerlink" title="或"></a>或</h3><p>| 表示或       (a|b)e  (ae, be)</p><h3 id="字符范围"><a href="#字符范围" class="headerlink" title="字符范围"></a>字符范围</h3><p>[a-z] 所有小写字母</p><p>[0-9] 数字</p><p>. 任意字符</p><h3 id="连续字符"><a href="#连续字符" class="headerlink" title="连续字符"></a>连续字符</h3><p>\4 连续有4个字符 (.)\4  连续4个相同字符</p><p>{1,2} 连续1个或者2个字符  10{1,2} (10,100)</p><p>{3,} 连续3个以上字符      0{3,}   (000,0000)</p><h3 id="不希望出现的字符"><a href="#不希望出现的字符" class="headerlink" title="不希望出现的字符"></a>不希望出现的字符</h3><p>^ 后接不希望出现的字符 @[^a-zA-Z]@ 两个@之前不能有字母</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>\d 匹配一个数字字符  等价于[0-9]</p><p>\D 匹配一个非数字字符 等价于[^0-9]</p><p>\w 匹配包括下划线的任何单词字符 等价于[A-Za-z0-9]</p><p>\W 匹配任何非单词字符  等价于[^A-Za-z0-9]</p><h3 id="转义字符处理"><a href="#转义字符处理" class="headerlink" title="转义字符处理"></a>转义字符处理</h3><p>碰到转义字符 多加一个 <code>\</code></p><h3 id="正则表达式与NSPredicate连用"><a href="#正则表达式与NSPredicate连用" class="headerlink" title="正则表达式与NSPredicate连用"></a>正则表达式与NSPredicate连用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validateNumber:(<span class="built_in">NSString</span> *)textString &#123;</span><br><span class="line"><span class="built_in">NSString</span>* number=<span class="string">@&quot;^[0-9]+$&quot;</span>;</span><br><span class="line"><span class="built_in">NSPredicate</span> *numberPre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@&quot;SELF MATCHES %@&quot;</span>,number];</span><br><span class="line"><span class="keyword">return</span>[numberPre evaluateWithObject:textString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSString方法"><a href="#NSString方法" class="headerlink" title="NSString方法"></a>NSString方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *searchText = <span class="string">@&quot;rangeOfString&quot;</span>;</span><br><span class="line"><span class="built_in">NSRange</span> range = [searchText rangeOfString:<span class="string">@&quot;^[0-9]+$&quot;</span>options:<span class="built_in">NSRegularExpressionSearch</span>];</span><br><span class="line"><span class="keyword">if</span>(range.location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;range ：%@&quot;</span>, [searchText substringWithRange:range]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式类（NSRegularExpression）"><a href="#正则表达式类（NSRegularExpression）" class="headerlink" title="正则表达式类（NSRegularExpression）"></a>正则表达式类（NSRegularExpression）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *searchText = @&quot;you want to match&quot;;</span><br><span class="line">NSError *error = NULL;</span><br><span class="line">NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@&quot;^[0-9]+$&quot;options:NSRegularExpressionCaseInsensitive error:&amp;error];</span><br><span class="line">NSTextCheckingResult *result = [regex firstMatchInString:searchText options:0 range:NSMakeRange(0, [searchText length])];</span><br><span class="line">if(result) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, [searchText substringWithRange:result.range]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下是对正则表达式学习的一些整理。&lt;/p&gt;
&lt;h3 id=&quot;头部尾部&quot;&gt;&lt;a href=&quot;#头部尾部&quot; class=&quot;headerlink&quot; title=&quot;头部尾部&quot;&gt;&lt;/a&gt;头部尾部&lt;/h3&gt;&lt;p&gt;^ 表示开始 后接字符串 ^one&lt;/p&gt;
&lt;p&gt;$ 表示结束 前接字符串 dog$&lt;/p&gt;
&lt;p&gt;“banana” 必须包含此字符串&lt;/p&gt;
&lt;h3 id=&quot;限制个数&quot;&gt;&lt;a href=&quot;#限制个数&quot; class=&quot;headerlink&quot; title=&quot;限制个数&quot;&gt;&lt;/a&gt;限制个数&lt;/h3&gt;&lt;p&gt;* 0个或更多个  ab*   (a,ab,abbb…)&lt;/p&gt;
&lt;p&gt;+ 1个或更多个  ab+   (ab, abbb…)&lt;/p&gt;
&lt;p&gt;? 0个或1个     ab?    (a, ab)&lt;/p&gt;
&lt;p&gt;{4} 4个       ab{4}  (abbbb)&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="http://anye3210.github.io/tags/iOS/"/>
    
    <category term="NSPredicate" scheme="http://anye3210.github.io/tags/NSPredicate/"/>
    
    <category term="正则表达式" scheme="http://anye3210.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
