{"meta":{"title":"Zephyr's Capsule","subtitle":"Stay hungry stay foolish","description":"不断前行","author":"Zephyr","url":"http://anye3210.github.io","root":"/"},"pages":[],"posts":[{"title":"多图详解 Netty","slug":"详解-Netty","date":"2021-08-22T09:26:09.000Z","updated":"2021-08-22T09:48:52.778Z","comments":true,"path":"2021/08/22/详解-Netty/","link":"","permalink":"http://anye3210.github.io/2021/08/22/%E8%AF%A6%E8%A7%A3-Netty/","excerpt":"多图详解 Netty什么是 Netty简单来说 Netty 就是 JBOSS 开源的一个基于 NIO 的网络编程框架。它可以帮助我们快速开发高性能高可靠性的网络 IO 程序。 Netty 在 Java 语言中使用非常广泛，涉及到网络通信的基本上都使用 Netty，很少会直接去使用原生的 NIO 组件或者是其他框架。并且像Dubbo、RocketMQ、Zookeeper、ElasticSearch 这些知名的中间件所使用的网络通讯框架都是基于 Netty 去实现的。 Netty 是在原生 NIO 的基础上发展起来的框架，其中的许多理念都非常像，所以学习 Netty 前需要了解一下原生 NIO 编程。 原生 NIO 编程在了解原生 NIO 编程之前需要了解一个基础概念 Socket。","text":"多图详解 Netty什么是 Netty简单来说 Netty 就是 JBOSS 开源的一个基于 NIO 的网络编程框架。它可以帮助我们快速开发高性能高可靠性的网络 IO 程序。 Netty 在 Java 语言中使用非常广泛，涉及到网络通信的基本上都使用 Netty，很少会直接去使用原生的 NIO 组件或者是其他框架。并且像Dubbo、RocketMQ、Zookeeper、ElasticSearch 这些知名的中间件所使用的网络通讯框架都是基于 Netty 去实现的。 Netty 是在原生 NIO 的基础上发展起来的框架，其中的许多理念都非常像，所以学习 Netty 前需要了解一下原生 NIO 编程。 原生 NIO 编程在了解原生 NIO 编程之前需要了解一个基础概念 Socket。 SocketNetty 是基于 TCP 协议的，我们知道 TCP 协议三个重要的特点分别是面向连接、可靠的和字节流。要达成这三点建立连接时需要客户端与服务端达成三个信息的共享，分别是： Socket：包含五个信息：连接使用的协议、本地主机 IP 地址和端口号、远程主机的 IP 地址和端口号 序列号：解决乱序问题 容器大小：用来做流量控制 Socket 就是两台主机之间的逻辑连接的端点，TCP 所说的面向连接，指的就是面向客户端和服务端两个 Socket 之间的连接。 这里要注意的是，服务端会涉及到两种 socket，一种叫做监听 socket ，一种叫做已完成连接 socket 。当监听 Socket 发现连接成功了之后会返回一个已完成连接 socket 文件描述符，用于后续传输数据。 原生 NIO 组件Netty 底层其实用了很多 Java 原生的 NIO 的组件，Netty 自定义的组件中有些理念也来自于原生的 NIO 组件。因此学习 Netty 之前需要了解一下原生的 NIO 组件的一些知识。 这里主要讲三个非常重要的组件：Channel (通道)、Buffer (缓冲区)、Selector (选择器)。 下图展示了这三个组件在 NIO 模型中发挥的作用： Buffer (缓冲区)Buffer 本质上就是一块可以读写数据的内存块，我们在使用的时候可以把它理解成一个数组。 下图是 Buffer 各个类的继承关系： 这里着重讲一下 ByteBuffer ，ByteBuffer 在原生 NIO 编程时使用频率是最高的。下面主要讲一下它的使用。 注意 ByteBuffer 初始化时其实是 创建并返回了一个它的子类 HeapByteBuffer 对象，我们操作的也是它的子类。 首先是初始化，初始化主要通过两种方式： **allocate(int capacity)**：创建 byte 类型的指定长度的缓冲区； wrap(byte[] array)：创建 byte 类型的有内容的缓冲区。 在学习数据操作之前，有几个 ByteBuffer 非常重要的参数和方法需要了解一下： position：当前读取或写入的起始坐标； limite：最多可以操作到哪个索引； capacity：缓冲区的总长度； remaining()：这个方法返回的是 limit - position 的计算值，代表还有多少空间可以操作。 数据操作主要是两个方法： put()：插入字节，它是一个重载方法，可以传入不同形式的字节； get()：读取字节，不传参获取 position 位置的字节并让 position + 1，也可以通过参数读取指定位置的字节。 下图是添加字节时各属性值的变化： ByteBuffer 虽然即支持读也支持写，但同一时间只能是其中一种模式，模式切换需要调用相应的方法。 下图是调用 flip() 方法将写模式切换为读时各属性的变化： 下图调用 clear() 方法将读切换为写时各属性的变化： Channel (通道)通常来说 NIO 所有的操作都是由通道开始的，它跟我们平常使用的流（InputStream，OutputStream）有点类似。但也有些区别： 通道可以读也可以写，流是单向的，所以需要输入流输出流； 通道可以异步读写 通道总是基于缓冲区来读写（将数据从通道读取到 buffer 或者将数据以 buffer 的形式写入到通道） 下图是 Channel 的继承关系： 常用的 Channel 主要有四种： FileChannel：用于文件数据的读写； DatagramChannel：用于 UDP 数据的读写； ServerSocketChannel 和 SocketChannel：用于 TCP 数据的读写，前者代表服务端的通道，后者代表客户端。 使用 ServerSocketChannel 和 SocketChannel 进行 NIO 编程与直接使用 ServerSocket 和 Socket 类似，这里就不赘述了。 Selector (选择器)Selector 是多路复用器的一种，虽然它的性能不是最好的，但它几乎在所有平台上都支持，具有良好的跨平台性。 Selector 是实现一个线程处理多个客户端请求的核心组件， Channel 注册到 Selector 上之后，如果有就绪事件产生，Selector 就会去获取事件然后针对事件进行相应的处理。 Selector 常用方法如下： open() ：静态方法，获取一个选择器对象； select()：调用后阻塞线程，阻塞期间会监控所有注册的通道，当有就绪事件需要操作时，会将 SelectionKey 放入集合并返回事件数量； select(1000)：只阻塞 1000 毫秒，阻塞期间与上面的方法相同； selectedKeys()：返回集合中保存的全部 SelectionKey 。 这些方法多次提到了 SelectionKey ，那么 SelectionKey 是什么呢？ SelectionKey 就是用来描述各种就绪事件的类，通过它能获取到当前的就绪事件类型。 SelectionKey 通过 4 个常量来定义 4 种不同的就绪事件： OP_READ：值为 1 &lt;&lt; 0，读就绪事件，表示通道中有可读数据，可以执行读操作； OP_WRITE：值为 1 &lt;&lt; 2，写就绪事件，表示可以向通道写数据了； OP_CONNECT：值为 1 &lt;&lt; 3，连接就绪事件，代表客户端与服务器连接已经建立成功了； OP_ACCEPT： = 1 &lt;&lt; 4，接收连接就绪事件，表示服务器监听到了客户端连接。 SelectionKey 通过以下 4 个静态方法判断当前是否是对应的就绪事件： isReadable()：是否是读就绪事件； isWritable()：是否是写就绪事件； isConnectable()：是否是连接就绪事件； isAcceptable()：是否是接收连接就绪事件。 原生 NIO 组件编程示例下面是使用 Selector 、Channel 和 ByteBuffer 进行 NIO 编程的示例。 服务器端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.zephyr.selector;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.nio.charset.StandardCharsets;import java.util.Iterator;import java.util.Set;/** * 服务端-选择器 */public class NIOSelectorServer &#123; public static void main(String[] args) throws IOException &#123; //打开一个服务端通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //绑定对应的端口号 serverSocketChannel.bind(new InetSocketAddress(9999)); //通道默认是阻塞的，需要设置为非阻塞 serverSocketChannel.configureBlocking(false); //创建选择器 Selector selector = Selector.open(); //将服务端通道注册到选择器上,并指定注册监听的事件为OP_ACCEPT serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println(&quot;服务端启动成功...&quot;); while (true) &#123; //检查选择器是否有事件 int select = selector.select(2000); if (select == 0) &#123; continue; &#125; //获取事件集合 Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator(); while (iterator.hasNext()) &#123; //判断事件是否是客户端连接事件 SelectionKey.isAcceptable() SelectionKey key = iterator.next(); //得到客户端通道,并将通道注册到选择器上, 并指定监听事件为OP_READ if (key.isAcceptable()) &#123; SocketChannel socketChannel = serverSocketChannel.accept(); System.out.println(&quot;客户端已连接......&quot; + socketChannel); //必须设置通道为非阻塞, 因为selector需要轮询监听每个通道的事件 socketChannel.configureBlocking(false); //并指定监听事件为OP_READ socketChannel.register(selector, SelectionKey.OP_READ); &#125; //判断是否是客户端读就绪事件SelectionKey.isReadable() if (key.isReadable()) &#123; //得到客户端通道,读取数据到缓冲区 SocketChannel socketChannel = (SocketChannel) key.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int read = socketChannel.read(byteBuffer); if (read &gt; 0) &#123; System.out.println(&quot;客户端消息:&quot; + new String(byteBuffer.array(), 0, read, StandardCharsets.UTF_8)); //给客户端回写数据 socketChannel.write(ByteBuffer.wrap(&quot;yo yo yo, hi man&quot;.getBytes(StandardCharsets.UTF_8))); socketChannel.close(); &#125; &#125; //从集合中删除对应的事件, 因为防止二次处理. iterator.remove(); &#125; &#125; &#125;&#125; 客户端代码： 1234567891011121314151617181920212223242526package com.zephyr.selector;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SocketChannel;import java.nio.charset.StandardCharsets;/** * 客户端 */public class NIOClient &#123; public static void main(String[] args) throws IOException &#123; //打开通道 SocketChannel socketChannel = SocketChannel.open(); //设置连接IP和端口号 socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)); //写出数据 socketChannel.write(ByteBuffer.wrap(&quot;What&#x27;s up.&quot;.getBytes(StandardCharsets.UTF_8))); //读取服务器写回的数据 ByteBuffer readBuffer = ByteBuffer.allocate(1024); int read=socketChannel.read(readBuffer); System.out.println(&quot;服务端消息:&quot; + new String(readBuffer.array(), 0, read, StandardCharsets.UTF_8)); //释放资源 socketChannel.close(); &#125;&#125; 为什么需要 Netty上面讲了原生 NIO 相关的知识，那么问题就来了，既然原生就有完备的 NIO 编程的各个组件，为什么还需要 Netty 呢。 主要原因还是因为原生 NIO 存在一些弊端： NIO 的类库和 API 繁杂：开发者需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等原生组件； 有一定的门槛：必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序； 开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等； JDK NIO 的 Bug：臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。 而 Netty 这个框架就很好地解决了这些问题，前三个比较好理解，简单讲一下第 4 个问题是怎么被解决的。 第 4 个问题讲到了 Selector 空轮询的 Bug，那么，什么是空轮询呢？ 空轮询是指本来 Selector 调用 select() 方法如果没有就绪事件在设置的时间到之前是阻塞的，但由于 Linux 底层实现有问题，导致在没有就绪事件时也有概率直接返回，而 select() 方法一般都是放在 while (true) 循环里的，这时就会开始不断地空轮询，直到 CPU 使用率飙到 100% 。 Netty 解决这个问题主要分别两步： 检测空轮询：判断阻塞时间小于 timeoutMillis (初始化的超时参数)，且 select 执行次数大于阈值； 重建 Selector ：新创建一个 Selector 并把旧 Selector 的 Channel 注册到这个 Selector 上，然后关闭这个 Selector； Netty 线程模型接着我们学习一下 Netty 的线程模型，了解了 Netty 的线程模型之后我们对 Netty 的整体架构也就有了一个大致的了解。 由于 Netty 的线程模型是基于 Reactor 模型改进而来的，因此先讲讲 Reactor 模型，有助于我们对 Netty 线程模型的理解 。 Reactor 模型Reactor 模型是指当服务器接收到多个请求时，服务器程序会把它们分派到不同的方法或线程去处理。Reactor 模式也被称作 Dispatcher 模式。它的核心是多路复用器，多路复用器收到事件后会进行分发，这点是网络服务器高并发的关键。 Reactor 模型分为三种：单 Reactor 单线程、单 Reactor 多线程和多 Reactor 多线程。 这三种模型按顺序来看理解起来复杂度不断提升，也会更接近 Netty 的线程模型，下面来分别看看这三种模型。 单 Reactor 单线程这个最好理解，只有一个线程，只是会把建立连接和处理请求这两种任务分发给不同的类去处理，如下图所示： 整个流程简单来讲就是 Reactor 通过 Selector 监听事件，收到事件使用 dispatch 对事件进行分发，如果是连接事件就由 Acceptor 进行处理，处理完成会创建一个 Handler 对后续业务进行处理。后面的数据请求都会由 Handler 进行处理。 优点： 模型简单，不会有多线程的那些问题 缺点： 性能问题：单线程无法发挥多核 CPU 的性能 可靠性问题：处理业务时往往容易出问题，当 Handler 出问题了，由于只有一个线程，整个节点也挂了 单 Reactor 多线程这个线程模型针对前面的问题作出了一定的优化，多出了处理业务的线程池，如下图所示： 前面的流程与单 Reactor 单线程是一致的，到 Handler 这一步就不一样了。这个模型 Handler 只负责读取数据和发送数据部分，业务处理交给了 Worker 线程，而 Worker 线程是由 Worker 线程池统一管理的。 优点： 可以充分利用多核 CPU 的处理能力 缺点： 多线程资源共享和访问处理会比较复杂，在主线程处理所有的连接、监听和响应也会出现性能瓶颈 主从 Reactor 多线程 主从 Reactor 多线程模型又在前面的模型基础上做了进一步优化，增加了子 Reactor ，如下图所示： 整个流程大概可以分为以下几步： 主线程的 MainReactor 负责监听连接请求，收到连接请求会由 Acceptor 进行处理，成功建立连接之后 MainReactor 会把连接分派给 SubReactor ，由 SubReactor 监听和处理数据请求； SubReactor 监听到数据请求，会派发给 Handler 处理，Handler 只会处理读取数据和发送数据部分，中间业务处理部分也是放在线程池中完成。 优点： MainReactor 与 SubReactor 职责分明，一个处理连接事件，一个处理数据请求； MainReactor 与 SubReactor 交互逻辑比较简单，MainReactor 单向地将建立好的连接传递出去； 多 Reactor 设计能在高并发场景拥有更好的性能。 缺点： 编程复杂度较高 主从 Reactor 多线程模式是业界非常成熟的服务器程序设计模式，在很多中间件中都使用到了这种模式，像 Nginx、Memcached、Netty 等。这种模式也被称为 1 + M + N 模式，分别代指相对少的连接线程（不一定为 1 ），多个 I/O 线程和多个业务处理线程。 Netty 线程模型Netty 线程模型是基于主从 Reactor 多线程模型优化而来的，整体架构如下图所示： Netty 的线程模型主要分为两部分，分别是 BossGroup 和 WorkerGroup，它们都分别管理一个或多个 NioEventLoop。每个 NioEventLoop 对应着一个线程，一个 Selector，一个 Executor 和一个 TaskQueue。 NioEventLoop 可以理解成一个事件循环，当程序启动后每个 NioEventLoop 都会通过 Executor 启动一个线程，开始执行事件循环，在循环中 Selector 会通过 select 方法阻塞并监听就绪事件，当有事件到来时通过 processSeelectedKeys 方法处理 Selector 事件，之后再通过 runAllTasks 方法处理其他的任务。 与前面介绍的 主从 Reactor 多线程模型类似，BossGoup 负责连接事件，当建立连接之后会生成一个 NioSocketChannel 并注册到 WorkGroup 其中一个 NioEventLoop 的 Selector 上。WokerGroup 中的 NioEventLoop 负责处理数据请求，当请求到来时会调用 processSelectedKeys 方法，其中的业务处理会依次经过 Pipeline 中的多个 Handler。 Netty 编程学习完 Netty 线程模型，我们来看一下使用 Netty 写出来的程序大概是什么样的。 服务端代码Nettry 服务器： 123456789101112131415161718192021222324252627282930313233public class NettyServer &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建 BossGroup EventLoopGroup bossGroup = new NioEventLoopGroup(1); // 创建 WorkerGroup EventLoopGroup workerGroup = new NioEventLoopGroup(); // 创建服务器启动类 ServerBootstrap bootstrap = new ServerBootstrap(); // 添加配置 bootstrap.group(bossGroup, workerGroup) // 设置 BossGroup 和 ChildGroup .channel(NioServerSocketChannel.class) // 设置 Channel 具体类 .option(ChannelOption.SO_BACKLOG, 128) // 设置连接队列 .childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE) // 设置开启保活机制 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; // 把自定义 Handler 添加到 pipeline socketChannel.pipeline().addLast(new NettyServerHandler()); &#125; &#125;); // 绑定端口号 ChannelFuture channelFuture = bootstrap.bind(new InetSocketAddress(9999)).sync(); System.out.println(&quot;服务器启动成功！&quot;); // 阻塞直到通道关闭 channelFuture.channel().closeFuture().sync(); // 优雅地关闭 BossGroup bossGroup.shutdownGracefully(); // 优雅地关闭 WorkerGroup workerGroup.shutdownGracefully(); &#125;&#125; 自定义服务器端 ChannelHandler 代码，只列出了主要几个方法的实现： 1234567891011121314151617181920212223public class NettyServerHandler implements ChannelInboundHandler &#123; @Override public void channelRead(ChannelHandlerContext channelHandlerContext, Object o) throws Exception &#123; ByteBuf byteBuf = (ByteBuf) o; System.out.println(byteBuf.toString(CharsetUtil.UTF_8)); Channel channel = channelHandlerContext.pipeline().channel(); System.out.println(channel); &#125; @Override public void channelReadComplete(ChannelHandlerContext channelHandlerContext) throws Exception &#123; channelHandlerContext.writeAndFlush(Unpooled.copiedBuffer(&quot;这是服务器的响应信息...&quot;.getBytes(CharsetUtil.UTF_8))); &#125; @Override public void channelRegistered(ChannelHandlerContext channelHandlerContext) throws Exception &#123; System.out.println(&quot;通道注册&quot;); &#125; ... &#125; 客户端代码Netty 客户端： 123456789101112131415161718192021222324252627public class NettyClient &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建 EventLoopGroup EventLoopGroup eventLoopGroup = new NioEventLoopGroup(1); // 创建启动类 Bootstrap bootstrap = new Bootstrap(); // 设置参数 bootstrap.group(eventLoopGroup) .channel(NioSocketChannel.class) // 设置 Channel 的类 .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; // 添加自定义 Handler socketChannel.pipeline().addLast(new NettyClientHandler()); &#125; &#125;); // 连接服务器 ChannelFuture channelFuture = bootstrap.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999)).sync(); System.out.println(&quot;客户端启动成功！&quot;); // 阻塞直到通道判断 channelFuture.channel().closeFuture().sync(); // 优雅地关闭 EventLoopGroup eventLoopGroup.shutdownGracefully(); &#125;&#125; 自定义客户端 ChannelHandler 代码： 123456789101112131415161718192021public class NettyClientHandler implements ChannelInboundHandler &#123; @Override public void channelActive(ChannelHandlerContext channelHandlerContext) throws Exception &#123; channelHandlerContext.writeAndFlush(Unpooled.copiedBuffer(&quot;这是客户端发来的消息&quot;, CharsetUtil.UTF_8)); &#125; @Override public void channelRead(ChannelHandlerContext channelHandlerContext, Object o) throws Exception &#123; ByteBuf byteBuf = (ByteBuf) o; System.out.println(byteBuf.toString(CharsetUtil.UTF_8)); &#125; @Override public void channelRegistered(ChannelHandlerContext channelHandlerContext) throws Exception &#123; System.out.println(&quot;通道注册&quot;); &#125; ... &#125; 如果对原生 NIO 编程比较熟悉理解上面的代码应该比较容易，同时也能看出使用 Netty 框架编程的难度是远远小于原生 NIO 的。 下面我们就详细了解一下上面代码涉及的这些 Netty 组件。 Netty 的核心组件ChannelHandlerChannelHandler 是一个接口，继承于它的两个接口 ChannelInboundHandler 和 ChannelOutboundHandler 定义了很多事件处理方法，我们可以通过实现这些方法或者重写子类的方法的来实现相应的业务逻辑。 ChannelHandler 的继承关系如图所示： 如果通过实现上述接口来开发，需要实现的方法中常用的有以下几个： public void channelActive(ChannelHandlerContext ctx) 通道就绪事件； public void channelRead(ChannelHandlerContext ctx, Object msg) 通道读取数据事件； public void channelReadComplete(ChannelHandlerContext ctx) 数据读取完毕事件； public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) 通道发生异常事件。 但一般开发中自定义 Handler 会直接继承 SimpleChannelInboundHandler ，我们自己必须要实现的就只有 protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) 这个方法，这种开发方式在继承的时候传入泛型指定出入站消息类型，配合编解码器使用会非常的方便。代码如下： 123456789101112public class NettyChatRoomServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(&quot;Channel active&quot;); &#125; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String msg) throws Exception &#123; System.out.println(msg); &#125;&#125; ChannelHandlerContextChannelHandlerContext 是 ChannelHandler 的上下文，它的核心就是 ChannelHandler ，它同时也保存了 Channel、Pipeline、Executor (NioEventLoop) 等信息。 它的继承关系如下图所示： Netty 中的 Context 分为三种： HeadContext 、TailContext 和 DefaultChannelHandlerContext 。 HeadContext 和 TailContext 比较特殊，它既是 ChannelHandlerContext 也是 ChannelHandler (实现了 Handler 的接口)。 我们通过 ChannelPipeline 的 addLast() 方法添加的 Handler 都会封装成 DefaultChannelHandlerContext 。 ChannelPipelineChannelPipeline 是一个接口，我们平常编程用到的一般是它的实现类 DefaultChannelPipeline 。 Pipeline 队列DefaultChannelPipline 其实就是一个管道，它维护了一个 ChannelHandlerContext 的双链表队列。 在 Pipeline 初始化时会创建头节点和尾节点，它们的类型分别是 HeadContext 和 TailContext，所以整个链表至少有两个节点。 中间的节点类型都是 DefaultChannelHandlerContext 。 链表如图所示： ChannelHandler 的传递性前面说过 Handler 分为 InboundHander 和 OutboundHandler ，消息入站时只会访问 InboundHander ，消息出站时只会访问 OutboundHander 。如果既是 InboundHandler 又是 OutboundHandler 出站入站都会访问。 而 InboundHandler 与 OutboundHandler 都具有传递性，不过传递方法有些区别： InboundHander 是向后传递，需要调用 ChannelHandlerContext 的 fireChannel…() ，比如如果是传递 ChannelRead() 方法就要调用 fireChannelRead() ，那么下一个节点的 ChannelRead() 方法就会被调用； OutboundHandler 是向前传递，需要调用 ChannelHanderContext 的同名方法，比如如果是传递 write() 方法调用的也是 write() ，这里下一个节点的 write() 方法就会被调用。 正常我们在开发中对数据的读写使用一个节点就够了，不需要使用这种传递性，这种传递性一般用在编解码器上。 无论是我们写子类自定义的编解码器还是使用 Netty 提供的编解码器，它们内部都会自动调用这些传递方法，开发者对这些是无感知的。 我们了解这些传递性的最大意义在于确定在添加 Handler 到 pipeline 中时（Handle 会被封装成 DefaultChannelHandlerContext 然后添加到队列中去）的顺序： 先添加编解码器，并且解码器在前，编码器在后； 先添加 OutboundHandler ，后添加 InboundHandler。 Pipeline 消息入站消息入站首先是 Selector 监听到读就绪事件，接着判断就绪事件如果是读事件就调用通道的 read() 方法，通道会把消息读到 ByteBuf 里，然后把 ByteBuf 传递给 Pipeline 自已去处理。 Pipeline 会直接把 ByteBuf 交给 HeadContext 去处理，而 HeadContext 没有具体的处理逻辑，会直接传递给下一个节点去处理。 下图就是 Pipeline 节点的处理顺序： Pipeline 消息出站消息出站与入站最大的不同是发起方。入站的消息是通过 Selector 监听到的。而出站是程序主动发起的。 对外写消息有三种方式： 调用 channel 的 writeAndFlush()，它内部会直接调用 pipeline.writeAndFlush(msg)，最终会从队列尾部开始调用； 调用 pipeline 的 writeAndFlush()，它内部会直接调用 tail.writeAndFlush(msg)，最终也是从队列尾部开始调用； 调用 channelHandlerContext 的 writeAndFlush()，它内部会以当前节点为起点找到下一个 OutboundHandler 让它去处理，最终就是从这个节点的下一个 OutboundHander 开始处理。 下图展示了各个节点处理顺序： NioEventLoopNioEventLoop 就是一个事件循环类，几乎所有事件处理都会经过这个类，它的继承关系如下： NioEventLoopGroupNioEventLoopGroup 就是 NioEventLoop 组，负责管理 NioEventLoop，当有 Channel 需要注册的时候，NioEventLoopGroup 会轮询找到下一个 NioEventLoop 注册上去。在 NioEventLoopGroup 上作出的配置最终都会作用到 NioEventLoop 上。 ChannelOption在程序初始化的时候我们可以通过 ChannelOption 对 Channel 设置一些参数，常用的参数有两个：SO_BACKLOG 和 SO_KEEPALIVE。 下面分别讲讲这两个参数 ： SO_BACKLOG这个参数主要是用来控制 Accept 队列的大小的 （早期的 Linux 内核是控制的 SYN 队列的大小）。 这里展开说一下这两个队列，它们都是由 Linux 内核维护的。一个是保存第一次握手的 SYN 的队列，系统会依次从这个队列取出 SYN 并进行响应，一个是保存三次握手完成后的 Accept 队列，调用 accept 方法就能拿到已完成连接的 socket，反应在 Netty 里面就是返回一个新的 Channel。 SO_KEEPALIVE这个参数对应的是连接的保活机制 ，如果不设置这个参数，请求完成连接就会被关闭。设置了这个参数之后，连接关闭的条件变成了如果客户端与服务器 2 个小时没有数据交互，那么客户端就会开始发探活数据报文，如果多次发送都没有响应，就断开连接。 ServerBootstrap 和 Bootstrap服务端和客户端的启动类，负责对 Netty 的各个组件进行配置。 服务器端配置代码如下： 1234567891011bootstrap.group(bossGroup, workerGroup) // 设置 BossGroup 和 ChildGroup .channel(NioServerSocketChannel.class) // 设置 Channel 具体类 .option(ChannelOption.SO_BACKLOG, 128) // 设置连接队列 .childOption(ChannelOption.SO_KEEPALIVE, Boolean.TRUE) // 设置开启保活机制 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; // 把自定义 Handler 添加到 pipeline socketChannel.pipeline().addLast(new NettyServerHandler()); &#125; &#125;); ChannelFuture下图是 ChannelFuture 的继承关系 从图中可以看出，它继承的 Future 接口是 Netty 自定义的接口，这个接口同时也继承自 Java 原生的 Future 接口。 在 Netty 中最常用的是 ChannelFuture 的子类 DefaultChannelPromise ，而这个类大部分功能都是由 DefaultPromise 实现的。 DefaultPromise 阻塞线程使用的是 Object 的 wait() 方法，而原生 Future 的子类 FutureTask 阻塞线程使用的是 LockSupport 的 park() 方法。 ChannelFuture 支持添加 ChannelFutureListener ，监听各种事件。 Unpooled这个类如果我们在使用 Netty 编程时不使用编解码器就会经常用到，它可以通过传入的字符串快速生成一个 ByteBuf (Netty 独有的类，类似于原生的 ByteBuffer，只是它在 ByteBuffer 的基础上做了封装) 对象。常用的方法如下： 1public static ByteBuf copiedBuffer(CharSequence string, Charset charset) StringDecoder 和 StringEncoder这两个类分别是 Netty 提供的解码器和编码器，它们同时也是 ChannelHandler 的子类。有了这两个编解码器，就不再需要与 ByteBuf 打交道，代码写起来也更简洁方便。 StringDecoder下图是解码器类 StringDecoder 的继承关系，注意它的父类是实现了 ChannelInboundHandler 接口的，作用在消息入站的时候： 如果有特殊需求需要自定义解码器也是可以的，只要实现 MessageToMessageDecoder 接口就可以了。 写法如下： 123456public class MessageDecoder extends MessageToMessageDecoder&lt;ByteBuf&gt; &#123; @Override protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list) throws Exception &#123; list.add(byteBuf.toString(CharsetUtil.UTF_8)); &#125;&#125; StringEncoder下图是编码器类 StringEncoder 的继承关系，注意它的父类是实现了 ChannelOutboundHandler 接口的，作用在消息出站： 如果要自定义编码器，实现 MessageToMessageEncoder 接口就行了。 写法如下： 123456public class MessageEncoder extends MessageToMessageEncoder&lt;String&gt; &#123; @Override protected void encode(ChannelHandlerContext channelHandlerContext, String s, List&lt;Object&gt; list) throws Exception &#123; list.add(Unpooled.copiedBuffer(s, CharsetUtil.UTF_8)); &#125;&#125; 如果嫌为自定义编码器和自定义解码器分别创建一个类太麻烦，还可以直接继承 MessageToMessageCodec 接口。 这个接口继承关系如下，注意它的父类同时实现了 ChannelInboundHandler 和 ChannelOutboundHandler ，作用在消息入站和出站： 写法如下： 12345678910111213public class MessageCodec extends MessageToMessageCodec&lt;ByteBuf, String&gt; &#123; @Override protected void encode(ChannelHandlerContext channelHandlerContext, String s, List&lt;Object&gt; list) throws Exception &#123; list.add(Unpooled.copiedBuffer(s, CharsetUtil.UTF_8)); &#125; @Override protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list) throws Exception &#123; list.add(byteBuf.toString(CharsetUtil.UTF_8)); &#125;&#125; LineBasedFrameDecoder 与 DelimiterBasedFrameDecoder这两个类也都是解码器，但它们解决的问题与上面所讲的编解码器不同，这两个类主要是解决粘包拆包的问题。 那么问题来了，什么是粘包和拆包？为什么会出现粘包和拆包呢？ 首先来说说什么是粘包和拆包： 在文章开始讲了 TCP 的三个重要的特点：面向连接、可靠的和字节流。而 Netty 底层是基于 TCP 的，它的客户端与服务端交互时发送的数据在传输层都是通过字节流传输的，字节流是没有界线的概念的，这时服务器在读取数据时就可能在一次读取中读取到到客户端分几次发的数据，这就叫粘包。如果客户端发送一次数据，服务器分几次才能完整读到，这就是拆包。 粘包拆包大致如下图所示： 粘包拆包大致有以下几个原因： socket缓冲区与滑动窗口: 在发送数据的时，发送方必须要先确认接收方的窗口没有被填充满，如果没有填满，则可以发送 MSS/MTU限制 Nagle算法：Nagle算法是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。 Netty 中解决粘包拆包的方法： FixedLengthFrameDecoder：固定长度拆包器，使用固定长度进行拆分； LineBasedFrameDecoder：行拆包器，使用换行符进行拆分； DelimiterBasedFrameDecoder：分隔符拆包器，使用自定义的分隔符进行拆分； LengthFieldBasedFrameDecoder：基于数据包长度的拆包器，基于应用层协议中传过来的长度进行拆分。 最常用的就是中间两个 LineBasedFrameDecoder 和 DelimiterBasedFrameDecoder。 总结以上就是 Netty 编程相关的知识点。Netty 的组件非常多，可以自定义的地方也非常多，但熟悉这些组件之后使用它们编程会非常方便快捷。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://anye3210.github.io/tags/java/"},{"name":"netty","slug":"netty","permalink":"http://anye3210.github.io/tags/netty/"},{"name":"网络编程","slug":"网络编程","permalink":"http://anye3210.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"nio","slug":"nio","permalink":"http://anye3210.github.io/tags/nio/"}]},{"title":"多图详解AQS","slug":"多图详解AQS","date":"2021-08-08T16:31:01.000Z","updated":"2021-08-22T07:03:30.996Z","comments":true,"path":"2021/08/09/多图详解AQS/","link":"","permalink":"http://anye3210.github.io/2021/08/09/%E5%A4%9A%E5%9B%BE%E8%AF%A6%E8%A7%A3AQS/","excerpt":"什么是AQSAQS 的全称是 AbstractQueuedSynchronizer ，从字面理解它就是抽象的队列同步器。它是可重入锁、各种同步工具类（共享锁）和条件等待唤醒机制实现的基石。 AQS 有一个重要的属性 state，它的值直接关系着其他线程能否获取到锁。 如果我们看过可重入锁、各种同步工具类（共享锁）的源码，会发现这些锁的关注点都在于通过 AQS 的 state 值或者能否通过 CAS 修改 state 的值来判断当前线程能否获取到锁（这里判断是否能获取到锁都是靠 AQS 的子类 Sync 和 Sync的子类实现的，而这些子类的具体方法是锁自己去实现的——归根到底这部分就是锁来实现的）。如果获取锁成功，直接扣减 AQS 的 State 值，不会涉及到 AQS。但如果当前线程获取锁失败，那么剩下的包括阻塞唤醒线程、重新发起获取锁之类的操作全都都会扔给 AQS 。简单来说就是 AQS 包揽了同步机制的各种工作。这就是为什么理解了 AQS 再去理解各种锁就会非常容易，它的重要性也就不言而喻了。 下图就是线程获取锁的大致流程：","text":"什么是AQSAQS 的全称是 AbstractQueuedSynchronizer ，从字面理解它就是抽象的队列同步器。它是可重入锁、各种同步工具类（共享锁）和条件等待唤醒机制实现的基石。 AQS 有一个重要的属性 state，它的值直接关系着其他线程能否获取到锁。 如果我们看过可重入锁、各种同步工具类（共享锁）的源码，会发现这些锁的关注点都在于通过 AQS 的 state 值或者能否通过 CAS 修改 state 的值来判断当前线程能否获取到锁（这里判断是否能获取到锁都是靠 AQS 的子类 Sync 和 Sync的子类实现的，而这些子类的具体方法是锁自己去实现的——归根到底这部分就是锁来实现的）。如果获取锁成功，直接扣减 AQS 的 State 值，不会涉及到 AQS。但如果当前线程获取锁失败，那么剩下的包括阻塞唤醒线程、重新发起获取锁之类的操作全都都会扔给 AQS 。简单来说就是 AQS 包揽了同步机制的各种工作。这就是为什么理解了 AQS 再去理解各种锁就会非常容易，它的重要性也就不言而喻了。 下图就是线程获取锁的大致流程： 下面就是使用 AQS 实现的最简单的独占锁，从代码也可以看出 AQS 大大降低了开发锁的难度： 1234567891011121314151617181920212223242526272829303132333435class Mutex &#123; private static class Sync extends AbstractQueuedSynchronizer &#123; @Override protected boolean tryAcquire(int arg) &#123; return compareAndSetState(0, 1); &#125; @Override protected boolean tryRelease(int arg) &#123; setState(0); return true; &#125; @Override protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; &#125; private final Sync sync = new Sync(); public void lock() &#123; sync.tryAcquire(1); &#125; public void unlock() &#123; sync.tryRelease(1); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125;&#125; AQS 的在 ReentrantLock 中的应用各种锁对于 AQS 的使用方式大致相同，这里以 ReentrantLock 为例来讲解。 ReentrantLock 的实现比上面的例子会复杂一点，但大体思路是相同的。 ReentrantLock 并不是直接继承自 AQS，它实现了 Lock 的接口并对外提供锁的各种功能。它通过内部的 AQS 子类 Sync 来使用 AQS 的功能，这样设计的好处在于锁的功能和同步器的功能划分更清晰，方便扩展和维护。 由于 ReentrantLock 支持公平锁和非公平锁，Sync 又有两个分别实现了公平锁和非公平锁功能的子类 FairSync 和 NonfairSync 。继承关系如下图所示： 这里着重讲一下 ReentrantLock 的 lock()和unlock方法。lock()方法内部就一句代码``sync.lock();实际是调用的 **FairSync** 或 **NonfairSync** 的lock()方法，而unlock方法是直接通过 **Sync** 类来调用 AQS 的release()`方法。 1234567public void lock() &#123; sync.lock(); // 实际是调用的 FairSync 或 NonfairSync 的`lock()`方法&#125;public void unlock() &#123; sync.release(1); // AQS的方法&#125; 下面再看看FairSync 或 NonfairSync 的lock()方法的具体实现： FairSync123final void lock() &#123; acquire(1); // AQS的方法&#125; NonfairSync123456final void lock() &#123; if (compareAndSetState(0, 1)) // 尝试直接获取锁 setExclusiveOwnerThread(Thread.currentThread()); // 获取锁成功后设置当前线程为独占线程 else acquire(1); // AQS的方法&#125; 从上面的代码可以看出，加锁解锁其实本质都是去调用 AQS 的acquire()和 release()方法。这两个方法在后面会详细讲解。 在 Sync和 Sync 的子类里还有两个重要的方法：tryAcquire()和tryRelease()，它们都是AQS 为独占锁提供的勾子方法，分别代表尝试获取锁和尝试释放锁。其中tryRelease()是由 Sync 来实现的，tryAcquire()是由 Sync 的子类来实现的。这点其实也比较好理解，ReentrantLock 支持公平锁和非公平锁，这两种锁的差异就体现的尝试获取锁这里，而释放锁的逻辑是一致的。由于 ReentrantLock 不是本文的重点，这两个方法就不详细说了。 ConditionObject条件等待和条件唤醒功能一般都是 ReentrantLock 与 AQS 的内部类 ConditionObject 配合实现的。一个 ReentrantLock 可以创建多个 ConditionObject 实例，每个实例对应一个条件队列，以保证每个实例都有自己的等待唤醒逻辑，不会相互影响。 条件队列里的线程对应的节点被唤醒时会被放到 ReentrantLock 的同步队列里，让同步队列去完成唤醒和重新尝试获取锁的工作。可以理解为条件队列是依赖同步队列的，它们协同才能完成条件等待和条件唤醒功能。 AQS 的构成讲完应用，下面讲讲AQS 的构成。 AQS 的继承关系如下图所示： 从图中可以看出 AQS 继承了另外一个抽象类 AbstractOwnableSynchronizer，这个类的功能其实就是持有一个不能被序列化的属性 exclusiveOwnerThread ，它代表独占线程。在属性中记录持有独占锁的线程的目的就是为了实现可重入功能，当下一次获取这个锁的线程与当前持有锁的线程相同时，就可以获取到锁，同时 AQS 的 state 值会加1。 图中红线部分标识了 AQS 的两个内部类，一个是 Node， 一个是 ConditionObject。 NodeNode就是 AQS 实现各种队列的基本组成单元。它有以下几个属性： waitStatus：代表节点状态：CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)、0（初始状态） prev：代表同步队列的上一个节点 next：代表同步队列的下一个节点 thread：节点对应的线程 nextWaiter：在同步队列里用来标识节点是独占锁节点还是共享锁节点，在条件队列里代表条件条件队列的下一个节点 队列AQS 总共有两种队列，一种是同步队列，代表的是正常获取锁释放锁的队列，一种是条件队列，代表的是每个 ConditionObject 对应的队列，这两种队列都是 FIFO 队列，也就是先进先出队列。 同步队列而同步队列的节点分为两种，一种是独占锁的节点，一种是共享锁的节点，它们唯一的区别就是 nextWaiter 这个指针的值。如果是独占锁的节点，nextWaiter 的值是 null，如果是共享锁的节点，nextWaiter 会指向一个静态变量 SHARED 节点。独占锁队列和共享锁队列如下图所示： 条件队列条件队列是单链，它没有空的头节点，每个节点都有对应的线程。条件队列头节点和尾节点的指针分别是 firstWaiter 和 lastWaiter ，如下图所示： waiteStatus讲完队列我们来着重看一下节点的这个属性，它代表着节点的等待状态。这个属性非常重要，如果不理解它，后面 AQS 源码部分也会很难理解。 首先看一下 waiteStatus 的取值： CANCELLED 取消状态，值为1 0 初始状态 SIGNAL 通知状态，值为 -1 CONDITION 条件等待状态，值为 -2 PROPAGATE 传播状态，值为 -3 这些状态我们一个一个看。 CANCELLED 代表着取消状态，它的值是 1，注意这些状态里只有它的值是大于 0 的，所以源码里判断是取消状态是直接通过 waiteStatus 值是否大于 0 来判断。 如果 waiterStatus 的值为 0，有两种情况：1、节点状态值没有被更新过（同步队列里最后一个节点的状态）；2、在唤醒线程之前头节点状态会被被修改为 0。 SIGNAL 代表着通知状态，这个状态下的节点如果被唤醒，就有义务去唤醒它的后继节点。这也就是为什么一个节点的线程阻塞之前必须保证前一个节点是 SIGNAL 状态。 CONDITION 代表条件等待状态，条件等待队列里每一个节点都是这个状态，它的节点被移到同步队列之后状态会修改为 0。 PROPAGATE 传播状态，在一些地方用于修复 bug 和提高性能，减少不必要的循环。 park() 和 unpark()讲 AQS 源码之前有一个重要的概念需要理解一下，那就是 Unsafe 这个类的 park() 和 unpark() 方法。 注意在 AQS 里并没有直接调用 Unsafe 的这两个方法，而是通过 LockSupport 间接调用的 Unsafe 的这两个方法，LockSupport 里面封装了一些参数来简化调用过程。 Unsafe 的这两个方法其实就是对许可的管理，park() 方法是让线程去获取一个许可，如果获取失败就阻塞当前线程，unpark() 方法是释放一个许可，如果当前线程是阻塞的，会唤醒当前线程。 这个许可简单理解就像一个人要去过一个城关，规定有令牌才能过，没有令牌就得等着。park()方法就是城关的守卫来检查你的令牌，你能拿出来就过去了，没拿出来就得原地等着。unpark()方法就是有人送来一块令牌，如果发现你已经有了，就不送了，如果发现你正好没有，就送给你。而如果这个时候你刚好等在城门口，那么你顺手就把刚得到的令牌给守卫，守卫就放你过去了。 AQS 源码分析AQS 源码分析分为三部分：独占锁部分、共享锁部分和条件等待条件通知部分。 独占锁部分acquire()首先是 acquire() 方法，下面是源码: 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 这里 Node.EXCLUSIVE 的值是 null selfInterrupt();&#125; 这里 tryAcquire(arg)方法是由具体的锁来实现的，这个方法主要是尝试获取锁，获取成功就不会再执行其他代码了，这个方法结束。获取失败会进入下一步acquireQueued(addWaiter(Node.EXCLUSIVE), arg)。这里有个方法嵌套，我们先看addWaiter(Node.EXCLUSIVE)方法： 1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; // 如果尾节点不为空，就把节点放在尾节点后面并设置为新的尾节点 node.prev = pred; if (compareAndSetTail(pred, node)) &#123; // 尝试把节点设置为新的尾节点 pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 这个方法前半段比较好理解，先创建一个节点，如果有尾节点，就让这个节点指向当前的尾节点，并把它设置成新的尾节点，设置失败也没关系，后面会进入一个重要方法enq()。如果当前没有尾节点，会直接进入到enq()方法。下面是enq()的源码： 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // 如果尾节点为空，那么队列也为空，新建一个头节点，让 head 和 tail 都指向它 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; // 如果有尾节点，把传入的节点放入队尾 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 其实这个方法就做两件事： 1、判断如果没有尾节点，那么队列肯定是空的，也不会有头节点，这个时候就要去新增一个空节点，通过 CAS 将这个空节点设置成头节点，然后 tail 指针也指向这个空节点。 2、如果有尾节点，就把当前节点放在尾节点后面，然后通过 CAS 尝试将 tail 指针指向这个节点，直到成功为止。 下图展示了初始队列为空时节点的变化，队列不为空的情况也类似于下图单节点到双节点的情况，都是在尾节点后续追加节点。 看完了addWaiter()方法，接下来就是另一个非常重要的方法acquireQueued()，源代码如下： 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); // 核验并获取前一个节点，如果前一个节点不存在，直接抛异常 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 如果前一个节点就是头节点，让这个节点的线程尝试获取锁 setHead(node); //获取锁成功后把当前节点设置为头节点 p.next = null; // 将之前头节点的 next 指针置空，后面 GC 时会回收这个节点 failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; // 判断是否应该阻塞当前线程（核心是判断并修正前面节点的 waitStatus） parkAndCheckInterrupt()) // 阻塞当前线程、返回并清除中断标记 interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 这个方法也分两种情况： 1、当前活跃的线程对应的节点就是同步队列的第二个节点，那么就让当前线程去尝试获取锁，直到成功为止，如果获取锁成功就把这个节点设置成头节点； 2、当前活跃线程是第三个或者更后面的节点，那么就会进入判断是否需要阻塞并进而阻塞的逻辑。 出现第一种情况有两种可能： 1、这个节点刚入队列而且这个队列只有头节点和这个节点； 2、本来这个节点是排在后面的，前面的节点一个个被唤醒之后它的位置也不断往前移，最终它作为第二个节点也被唤醒了。 整个方法的大致流程如下图所示： 下面重点讲一下第二种情况，也就是涉及阻塞线程的情况。 先看看shouldParkAfterFailedAcquire()源码： 1234567891011121314private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) // 判断前面节点状态为 SIGNAL ，返回 true return true; if (ws &gt; 0) &#123; // 如果前面的节点状态为取消（CANCEL值为1）,就一直向前查找，直到找到状态不为取消的节点，把它放在这个节点后面 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; compareAndSetWaitStatus(pred, ws, Node.SIGNAL); // 如果前面节点不是取消也不是 SIGNAL 状态，将其设置为 SIGNAL 状态 &#125; return false;&#125; 这个方法主要是判断前一个节点的状态： 1、如果是 SIGNAL 就返回 true 表示可以阻塞当前线程； 2、如果前面节点状态大于零，也就是取消状态，那么一直往前移直到它前面的节点不是取消状态； 3、如果不是前两种状态，那么把前一个节点状态设置成 SIGNAL 。 除了第一种状态，后面两种状态都会返回 false，后面经过循环再次进去这个方法。 当前面一个方法返回 true 时，就会进入下一个判断，也就是parkAndCheckInterrupt()方法，下面是方法源码： 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); // 阻塞当前线程 return Thread.interrupted(); // 返回并清除当前线程中断状态&#125; 这个方法比较简单，就做两件事：阻塞当前线程和返回并清除中断状态。 上面就是acquire()部分的源码，接着讲与它对应的另一个方法release()。 release()下面是 release() 的源码： 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; // 尝试释放锁，如果成功则唤醒后继节点的线程 Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); // 唤醒后面节点中第一个非取消状态节点的线程 return true; &#125; return false;&#125; 在方法的开始做了一个判断： 1、如果当前线程释放锁失败，就直接返回了； 2、如果释放锁成功，那么就会接着判断头节点是否为空和头节点 waitStatus 是否不为 0 。 这里判断头节点状态是一个比较重要的点。为什么头节点的状态一定不能为 0 呢？从后面要讲到源码可以知道，在唤醒头节点的后继之前会做一个将头节点状态置为 0 的操作（虽然这个操作不一定成功）。如果头节点的状态为 0 了，说明正在释放后继节点，这时候也就不再需要释放了，直接返回 true。 头节点状态判断之后，就会进入到释放后继节点这一步，也就是unparkSuccessor()方法： 1234567891011121314private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; // 这里取的是头节点的状态 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); // 尝试将头节点状态设置为 0，不保证能设置成功 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; // 如果后面这个节点状态为取消，那么就找到一个位置最靠前的非取消状态的节点 s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread); // 唤醒符合条件的后继节点&#125; 这个方法的核心目标是唤醒头节点符合条件的后继节点。因此前面做了一个判断，如果后面这个节点不是取消状态也不为空，那么就直接唤醒它。如果后面的节点不符合要求，那么就开始从后往前遍历，找到一个最靠前的并且是非取消状态的非空节点，然后唤醒它对应的线程。 整个方法的流程如下图所示： 共享锁部分acquireShared()了解完独占锁的加锁和解锁的逻辑，接着来讲讲共享锁的加锁和解锁逻辑。 下面是 acquireShared() 方法的源码： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 这个方法就两行：第一行判断尝试获取锁的返回值是否小于0，这里的返回值是指当前信号量减去传入的信号量的结果，小于0就代表当前信号量不足，获取锁失败，这时候就需要 AQS 接管了；第二行是执行阻塞和唤醒后获取锁的方法。 下面是doAcquireShared() 方法的源码： 123456789101112131415161718192021222324252627private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); // 1、共享节点入队 boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); // 2、尝试获取共享锁（相当于尝试扣减信号量） if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); // 3、设置头节点并且做一些判断，符合条件会唤醒下一个节点 p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) parkAndCheckInterrupt()) // 线程会阻塞在这个位置，被唤醒后再继续循环 interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 这个方法大部分代码与前面讲的 acquireQueued() 方法是相同的。这里着重讲不同的地方。 首先是标记的第 1 处 final Node node = addWaiter(Node.SHARED); 这里参数是传的静态常量 SHARED ，这个值会赋给新生成节点的 nextWaiter 。正如前面说的，通过 nextWaiter 的值我们就能判断这个节点是独占锁的节点还是共享锁的节点。 然后是标记为 2 的这行代码 int r = tryAcquireShared(arg); 这代表尝试获取锁之后的值，如果剩下的信号量不为负，那就代表获取锁成功了，就会进入到标识为 3 的这个方法。 下面我们来看看标记为 3 的 setHeadAndPropagate(node, r) 方法的源码： 12345678910private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); // 1 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || // 2 (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; 这个方法代码也不多，主要是两块内容：第一个是 setHead(node) 方法，这个方法让第二个节点变成头节点，置空之前头节点的部分指针；第二块内容做了大量的判断，然后如果符合条件会执行 doReleaseShared();，这个方法也是后面重点要讲的唤醒共享锁同步队列线程的方法。 这里详细讲一下第二块内容做的这些判断： propagate &gt; 0 ：propagate 是传入的参数，代表获取锁成功之后剩余的信号量，如果为正，说明其他线程也可能获取到锁，就会执行后面的唤醒逻辑； h == null：之前的头节点是空，这里代表异常情况，也需要唤醒线程避免后面的线程都不会被唤醒的情况出现； h.waitStatus &lt; 0：这里代表保存旧的头节点和设置新的头节点的间隙又有新的节点将会或已经被阴塞了，这个情况也需要执行唤醒让线程重新尝试获取锁； (h = head) == null ：这里代表新的头节点异常，与旧头节点异常一样需要做唤醒操作； h.waitStatus &lt; 0：这个代表设置新节点成功到做这个判断的间隙又有新节点将会或已经被阻塞了，同样需要唤醒； s == null：这个代表队列只有头节点或者发生异常，统一做唤醒操作，主要还是处理异常情况； s.isShared()：这个判断代表只要是共享节点并且满足唤醒条件都会执行唤醒。 这个方法里实现了链式唤醒：当一个线程被唤醒并获取到锁，如果满足条件就会去唤醒其他线程来尝试获取锁，这种唤醒能一直传递下去，使得共享锁获取锁的效率大大提升。 releaseShared()接着讲另一个重要的方法releaseShared()，下面是源码： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 这个方法除了返回值，核心代码也只有两行：第一行代表尝试释放锁，释放失败就直接返回了，释放成功就会执行唤醒后继节点线程操作；第二行就是具体的唤醒线程的方法； 下面是 doReleaseShared() 方法的源码： 123456789101112131415161718private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 在这个方法的循环里对头节点做了大量的判断，头节点的状态满足条件才会执行唤醒操作，我们挨个来看看这些判断的作用： ws == Node.SIGNAL：从前面的源码可以知道，一个节点阻塞前它前面的节点的 waiteStatus 必须为 SIGNAL ，如果在做唤醒操作这个值就会变，做这个判断主要是确保当前队列没有其他线程在做唤醒操作； !compareAndSetWaitStatus(h, Node.SIGNAL, 0)：尝试将头节点 waiteStatus 值设置为 0，代表这个 FIFO 队列正在做唤醒操作，注意与独占锁不一样，这里要确保这个值是设置成功的； ws == 0 &amp;&amp;!compareAndSetWaitStatus(h, 0, Node.PROPAGATE)：这个判断主要是为了确保前面获取到的头节点 waiteStatus 的值与实时获取的头节点 waiteStatus 值相同。什么样的情况下前面做一个判断的间隙这里头节点的状态就变了呢？那就是有新节点入队放在头节点后面并准备阻塞或者已经阻塞了，由于是否阻塞有不确定性，这里就会重新循环获取最新的状态，避免同时做阻塞和唤醒的动作。 而 unparkSuccessor() 方法前面已经讲过，这里就不重复讲了。 条件等待和条件通知条件等待和条件通知功能主要由 AQS 内部类 ConditionObject 的两个重要的方法： await() 和 signal() 来实现。 await()await() 方法正如字面意思一样，就是等待。它与 Object 对象的 wait() 方法不同的是，Object 的 wait() 方法调用后，任何对象调用 notify 都能唤醒它，而 await() 方法调用后，只有调用 await() 方法的实例调用的 notify() 方法才能唤醒它，因此 await() 是一个条件等待方法。 方法的源码如下： 123456789101112131415161718public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); // 生成一个新的节点添加到条件队列 int savedState = fullyRelease(node); // 调用同步队列释放锁的方法 int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; // 节点是否已经转移到了同步队列中 LockSupport.park(this); // 没有被转移就阻塞线程 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) // 根据线程中断状态设置 interruptMode break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) // 调用同步队列阻塞和尝试获取锁的方法 interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); // 把节点等待状态（waitStatus）不为 CONDITION 的节点移除 if (interruptMode != 0) reportInterruptAfterWait(interruptMode); // 根据不同的中断模式决定是抛出中断异常还是重新标记中断&#125; 需要特别注意的是这个方法是支持中断的，而且方法中很多判断和方法都是与中断有关的，具体哪些地方什么情况会抛出中断异常这里不详细说，这个不是本文的重点。 首先讲讲 addConditionWaiter() 这个方法，源码如下： 123456789101112131415private Node addConditionWaiter() &#123; Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); // 把所有节点等待状态不为 CONDITION 的节点移除 t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION); // 新建一个条件队列的节点 if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node;&#125; 这个方法做了两件事： 1、如果队列不为空而且最后一个节点等待状态异常，就做一个全队列扫描，去掉异常的节点； 2、把节点入队，这里要做一个判断：如果队列为空，把新节点作为头节点，如果队列非空，把新节点放在队尾。 接着是 isOnSyncQueue() 方法，源码如下： 1234567final boolean isOnSyncQueue(Node node) &#123; if (node.waitStatus == Node.CONDITION || node.prev == null) return false; if (node.next != null) // If has successor, it must be on queue return true; return findNodeFromTail(node);&#125; 这个方法主要是用来判断当前线程的节点是否已经在同步队列了，这个方法涉及三个判断： 1、如果节点等待状态是 CONDITION 或者节点的 prev 指针为空（节点在同步队列这个指针才有值），那么一定不是在同步队列； 2、如果节点的 next 指针不为空，那么一定在同步队列； 3、遍历同步队列，看队列中有没有节点与这个节点相同。 signal()signal() 方法是与 await() 方法对应的，一个负责通知，一个负责等待。 下面是 signal 方法的源码： 1234567public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125; isHeldExclusively() 这个方法返回的是该线程是否正在独占资源，如果不是的话会抛出异常。 整个 signal() 方法的重点里面调用的 doSignal() 方法，传入的参数是头节点。 下面是 doSignal() 的源码： 12345678private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) // 判断头节点的下一个节点是否为 null lastWaiter = null; // 如果队列只有头节点，将 lastWaiter 指针置为 null first.nextWaiter = null; // 迁移节点前先将节点的 nextWaiter 置为 null &#125; while (!transferForSignal(first) &amp;&amp; // 把头节点迁移到同步队列中去 (first = firstWaiter) != null); // 没有迁移成功就重新获取头节点判断不为空继续循环&#125; 这个方法也没有太复杂的内容，具体可以看看上面的注释，这里详细讲讲 transferForSignal() 。 方法源码如下： 123456789final boolean transferForSignal(Node node) &#123; if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) // 将节点 waitStatus 通过 CAS 更新为 0 return false; // 更新失败说明节点等待状态已经变了，返回 false 重新获取头节点然后重试 Node p = enq(node); // 将节点放入同步队列中 int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) // 判断前一个节点等待状态，如果状态是正常的赋值为 SIGNAL LockSupport.unpark(node.thread); // 前面节点状态为取消或就会唤醒当前节点，避免后面没办法被唤醒 return true;&#125; 整个迁移队列变化如下图所示： 总结以上就是关于 AQS 的全部内容，看到这里大家应该就会有一个直观的感受：AQS 其实核心就是队列，队列又是为各种锁服务的。了解这些队列节点的阻塞唤醒时机对我们去了解各种锁非常有帮助。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://anye3210.github.io/tags/Java/"},{"name":"AQS","slug":"AQS","permalink":"http://anye3210.github.io/tags/AQS/"},{"name":"锁","slug":"锁","permalink":"http://anye3210.github.io/tags/%E9%94%81/"},{"name":"ReentrantLock","slug":"ReentrantLock","permalink":"http://anye3210.github.io/tags/ReentrantLock/"},{"name":"共享锁","slug":"共享锁","permalink":"http://anye3210.github.io/tags/%E5%85%B1%E4%BA%AB%E9%94%81/"},{"name":"Lock","slug":"Lock","permalink":"http://anye3210.github.io/tags/Lock/"}]},{"title":"详解Java类加载过程","slug":"详解Java类加载过程","date":"2021-08-02T14:53:13.000Z","updated":"2021-08-22T07:14:52.675Z","comments":true,"path":"2021/08/02/详解Java类加载过程/","link":"","permalink":"http://anye3210.github.io/2021/08/02/%E8%AF%A6%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"概述类从被加载到虚拟机开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。整个过程如下图所示： 加载、验证、准备、初始化和卸载这五个阶段顺序是确定的，类的加载过程这些阶段必须按这个顺序开始（注意这里强调的开始的顺序，进行和完成可能是交叉混合着的）。由于 Java 支持动态绑定，在动态绑定时解析阶段会在初始化之后执行。 类加载时机上面讲到类的分为七个阶段，那么什么情况下会开始类的加载呢？ 思考这个问题我们可以从两个维度出发，一个是 JVM 规范维度，一个是从虚拟机运行的维度；","text":"概述类从被加载到虚拟机开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。整个过程如下图所示： 加载、验证、准备、初始化和卸载这五个阶段顺序是确定的，类的加载过程这些阶段必须按这个顺序开始（注意这里强调的开始的顺序，进行和完成可能是交叉混合着的）。由于 Java 支持动态绑定，在动态绑定时解析阶段会在初始化之后执行。 类加载时机上面讲到类的分为七个阶段，那么什么情况下会开始类的加载呢？ 思考这个问题我们可以从两个维度出发，一个是 JVM 规范维度，一个是从虚拟机运行的维度； JVM 规范维度 JVM 规范没有强制约束类的加载时机，但 Java 虚拟机严格规定了有且只有5种情况必须立即对类进行”初始化”，执行初始化自然必须先执行前面的步骤。 遇到 new、getstatic、putstatic、或 invokestatic 这4条字节码指令时，如果类没有初始化，则需要先触发其初始化。其对应的场景分别为：使用 new 关键字初始化实例对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候和调用一个类的静态方法的时候； 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化； 当初始化一个类的时候，如果发现其父类没有初始化，则需要先触发其父类的初始化； 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法那个类），虚拟机会先初始化这个主类； 当使用 JDK1.7 开始的动态语言支持时，如果 􏱏􏰑􏰣􏲝java.lang.invoke.MethodHandle􏲟􏲡􏰿􏱆 实例最后的解析结果为 􏰏􏰲􏱨􏰐􏰑REF_getStatic、􏱦REF_putStatic、􏱦REF_invokeStatic 的方法句柄􏰏􏲶􏵁􏸁􏸂􏰛􏱢􏴪􏱑􏲝􏲶􏵁􏸁􏸂 􏳨􏱣􏲏􏰏􏰇􏴣􏳝􏱔􏱊􏱾􏱩􏱪􏱚􏰛􏴋􏱂􏱃􏳔􏴰􏰡，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 虚拟机运行维度从虚拟机运行的维度来说，有两种时机会触发类加载： 预加载 运行时加载 预加载虚拟机启动时加载，加载的是JAVA_HOME/lib/下的rt.jar下的.class文件，这个jar包里面的内容是程序运行时非常常 常用到的，像java.lang.*、java.util. java.io. 等等，因此随着虚拟机一起加载。 要证明这一点很简单，写一个空的main函数，设置虚拟机参数为-XX:+TraceClassLoading来获取类加载信息，运行一下: 123456[Opened /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Object from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.io.Serializable from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Comparable from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.CharSequence from /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jre/lib/rt.jar]... 运行时加载虚拟机在用到一个.class文件的时候，会先去内存中查看一下这个.class文件有没有被加载，如果没有就会按照类的全限定名来加载这个类。 详解类加载过程加载（重要）加载阶段主要做了三件事： 获取 .class 文件的二进制流； 将类信息、静态变量、字节码、常量这些 .class 文件中的内容放入方法区中； 在内存中生成一个代表这个.class文件的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机比较特殊，这个Class对象是放在方法区中的。 虚拟机规范对这三点的要求并不具体，因此虚拟机实现与具体应用的灵活度都是相当大的。 这种灵活度对于开发者来说主要体现在第一步，由于虚拟机规范并没有规定二进制字节流的来源，开发者可以从以下几个渠道获取： 从zip包中获取，这就是以后jar、ear、war格式的基础 从网络中获取，典型应用就是Applet 运行时计算生成，典型应用就是动态代理技术 由其他文件生成，典型应用就是JSP，即由JSP生成对应的.class文件 从数据库中读取，这种场景比较少见 链接（理解）链接分为三个步骤：验证、准备和解析 验证验证阶段主要是为了确保 .class 文件的字节流中包含的信息符合当前虚拟机要求，并且不会危害虚拟机自身的安全。 正如前面所说，二进制字节流可能有很多种来源，虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节 流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。 验证阶段大致会完成以下四个阶段的检验动作： 文件格式验证 元数据验证 字节码验证 符号引用验证 验证阶段与加载阶段是交叉进行的，加载阶段还没有结束验证阶段就已经开始了。 这个阶段也是最耗费时间的，如果我们所运行的全部代码（包括自己编写的及第三方依赖包中的代码）都已经被反复使用和验证过，那么可以考虑使用 􏱏􏰑􏳨􏱉􏱊􏰏􏶶􏲹􏰋􏰌􏳹􏳟􏳠􏲰􏷠􏰍􏲢􏰏􏵀􏰁􏸗􏲶􏳟􏰹􏰏􏰋 􏰌􏳺􏱁􏲿􏷼􏱯􏵂􏳆􏱌􏱍􏱋􏱥􏳻􏱾􏰛􏱵􏱙􏰸􏲟􏹵􏳾􏳿􏱳􏱭􏱮􏶖􏶗􏱌􏱍-Xverify􏳙none􏵑􏱠􏴦􏴲 􏹯􏰪􏲹􏲺􏰏􏰇􏱥􏳻􏹶􏹵􏰛􏱮􏹷􏶅􏰄􏰅􏰆􏰇􏰈􏰉􏰏􏱶参数来关闭大部分类验证措施，以缩短虚拟机类加载时间。 准备准备阶段是正式为类变量分配内存并设置其初始值的阶段，这些变量所使用的内存都将在方法区中分配 。 这里的类变量是指不被 final 修饰的 static 变量，这里设置的初始值指的是赋零值。 各个数据类型对应的零值如下： 数据类型 零值 int 0 long 0L short (short)0 chart ‘\\u0000’ byte (byte)0 boolean false float 0.0f double 0.0d reference null 这里需要注意一下，类变量由于在这个阶段会有一个初始值，所有代码里可以不指定初始值直接使用，但其他变量不行，使用前必须有初值，否则会编译出错。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 这里就需要了解符号引用和直接引用的概念： 符号引用符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。 下面以简单的代码来理解符号引用： 1234567891011121314package com.zephyr.demo;public class SymbolClass &#123; public static String serial; private int count; public static void calculate() &#123; &#125; public int getCount() &#123; return count; &#125;&#125; 使用javap -verbose SymbolClass反编译一下这个类，我们主要看看常量池部分： 1234567891011121314151617181920212223242526272829Constant pool: #1 = Methodref #4.#25 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#26 // com/zephyr/demo/SymbolClass.count:I #3 = Class #27 // com/zephyr/demo/SymbolClass #4 = Class #28 // java/lang/Object #5 = Utf8 serial #6 = Utf8 Ljava/lang/String; #7 = Utf8 count #8 = Utf8 I #9 = Utf8 &lt;init&gt; #10 = Utf8 ()V #11 = Utf8 Code #12 = Utf8 LineNumberTable #13 = Utf8 LocalVariableTable #14 = Utf8 this #15 = Utf8 Lcom/zephyr/demo/SymbolClass; #16 = Utf8 calculate #17 = Utf8 getCount #18 = Utf8 ()I #19 = Utf8 main #20 = Utf8 ([Ljava/lang/String;)V #21 = Utf8 args #22 = Utf8 [Ljava/lang/String; #23 = Utf8 SourceFile #24 = Utf8 SymbolClass.java #25 = NameAndType #9:#10 // &quot;&lt;init&gt;&quot;:()V #26 = NameAndType #7:#8 // count:I #27 = Utf8 com/zephyr/demo/SymbolClass #28 = Utf8 java/lang/Object 上面带Utf8的那一行就是符号引用，每行最前面的就是符号，后面就是引用的值。对于变量来说都会有两行成对出现，比如#7 是 count，#8就是 count 的类型 Integer(常量池里简写为 I )。方法如果有返回值，方法和返回值也会成对出现，比如 #17 和 #18，分别代表的方法和返回值类型。 简单理解符号引用就是对于类、变量、方法的描述。􏵱􏵲􏷞􏱍􏱮􏰣􏲻􏵱􏵲􏴦􏰺􏰭􏳨􏷞􏱍􏰏􏲽􏷯􏰛􏵱􏵲􏱭 并且􏱮􏰜􏸛􏱐􏱫􏰠􏰏􏰙􏱽􏴽􏰛􏴫􏱃􏱌􏱍􏱶􏱈􏳰􏺂􏲯􏰔􏲨􏵰􏱄􏲽􏷯􏴬􏱭符号引用和虚拟机的内存布局是没有关系的，引用的目标未必已经加载到内存中了。 直接引用直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。 解析过程Java 本身是一个静态语言，但后面又加入了动态加载特性，因此我们理解解析阶段需要从这两方面来考虑。 如果不涉及动态加载，那么一个符号的解析结果是可以缓存的，这样可以避免多次解析同一个符号，因为第一次解析成功后面多次解析也必然成功，第一次解析异常后面重新解析也会是同样的结果。 如果使用了动态加载，前面使用动态加载解析过的符号后面重新解析结果可能会不同。使用动态加载时解析过程发生在在程序执行到这条指令的时候，这就是为什么前面讲的动态加载时解析会在初始化后执行。 整个解析阶段主要做了下面几个工作： 类或接口的解析 类方法解析 接口方法解析 字段解析 初始化（重要）初始化是整个类加载过程的最后一个阶段。整个类加载的五个阶段只有加载和初始化是开发者可以参与的，因此初始化阶段也是需要重点关注的阶段。 初始化阶段简单来说就是执行类的构造器方法（&lt;clinit&gt;() ），要注意的是这里的构造器方法&lt;clinit&gt;()并不是开发者写的，而是编译器自动生成的。 代码顺序的影响编译器编译的时候会按代码顺序进行收集，声明在静态代码块（static {} 块）之后的静态变量，只能在静态代码块里赋值，不能访问。 1234567public class TestClinit &#123; static &#123; i = 0; // 可以给变量赋值 System.out.print(i); // 在这里访问编译器会提示“非法向前引用” &#125; static int i = 1; &#125; 父类与子类&lt;clinit&gt;()方法执行顺序Java 虚拟机会保证父类的&lt;clinit&gt;()方法执行完成后才执行子类的&lt;clinit&gt;()方法，这也就意味着父类的静态代码块一定会先于子类执行的。 这里需要注意的是，如果父类的静态代码块有耗时操作，子类可能会被阻塞迟迟加载不了。 编译器生成&lt;clinit&gt;()方法的条件编译器生成&lt;clinit&gt;()方法的前提是有变量赋值操作或者有静态代码块需要执行。接口虽然没有静态代码块但是有变量赋值操作，所以接口会生成&lt;clinit&gt;()方法。 注意：接口或者接口的实现类在执行&lt;clinit&gt;()方法之前不一定会去执行父类的&lt;clinit&gt;()方法，仅当父类或者被实现的接口变量被使用才会调用这个方法。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://anye3210.github.io/tags/Java/"},{"name":"类加载","slug":"类加载","permalink":"http://anye3210.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"name":"符号引用","slug":"符号引用","permalink":"http://anye3210.github.io/tags/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/"},{"name":"初始化","slug":"初始化","permalink":"http://anye3210.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"}]},{"title":"JMM - Java 内存模型","slug":"JMM-Java-内存模型","date":"2021-07-31T14:57:14.000Z","updated":"2021-08-22T07:15:54.327Z","comments":true,"path":"2021/07/31/JMM-Java-内存模型/","link":"","permalink":"http://anye3210.github.io/2021/07/31/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"JMM定义JMM 即 Java Memory Model，也叫 Java 内存模型。JMM 就是一种规范，它定义了什么情况开发者不需要去感知计算机的各种重排序，什么情况需要开发者去干涉重排序，以保证程序的执行结果可预测。 JMM的由来计算机这么多年来整体运行速度不断地提升，除了像CPU时钟频率、内存读写速度等硬件性能不断提升之外，还要归功于计算机科学家对于计算机对于各种指令处理效率的不断优化，包括超标量流水线技术，动态指令调度，猜测执行，多级缓存技术等。在这其中，允许重排序对于计算机运行效率的提升产生了重要的作用，但同时也带来了一些问题。计算机只能确保单线程情况下重排序对于运行结果没有影响，对于多线程就无能为力了。这个时候就需要一个规范来保证开发者既能享受重排序带来的性能的提升又能让复杂情况下的运行结果可控，JMM 就是这样一个规范。JMM 规定了 JVM 必须遵循的一组最小保证，这组保证规定了对变量的操作何时对其他线程可见。换句话说，JMM 对内存可见性作出了一些承诺，在承诺之外，开发者需要自己去处理内存可见性问题。","text":"JMM定义JMM 即 Java Memory Model，也叫 Java 内存模型。JMM 就是一种规范，它定义了什么情况开发者不需要去感知计算机的各种重排序，什么情况需要开发者去干涉重排序，以保证程序的执行结果可预测。 JMM的由来计算机这么多年来整体运行速度不断地提升，除了像CPU时钟频率、内存读写速度等硬件性能不断提升之外，还要归功于计算机科学家对于计算机对于各种指令处理效率的不断优化，包括超标量流水线技术，动态指令调度，猜测执行，多级缓存技术等。在这其中，允许重排序对于计算机运行效率的提升产生了重要的作用，但同时也带来了一些问题。计算机只能确保单线程情况下重排序对于运行结果没有影响，对于多线程就无能为力了。这个时候就需要一个规范来保证开发者既能享受重排序带来的性能的提升又能让复杂情况下的运行结果可控，JMM 就是这样一个规范。JMM 规定了 JVM 必须遵循的一组最小保证，这组保证规定了对变量的操作何时对其他线程可见。换句话说，JMM 对内存可见性作出了一些承诺，在承诺之外，开发者需要自己去处理内存可见性问题。 内存可见性问题上面提到了内存可见性问题，那么，什么是内存可见性问题。 内存可见性问题的核心是 CPU 的缓存与主内存不一致。 那么，这里就涉及到计算机原理的部分知识，下图是 X86 架构下 CPU 缓存的布局： 从图中可以看出 CPU 有多级缓存，每个核心的一二级缓存数据都是该 CPU 核心私有的，由于有缓存一致性协议（例如 MESI ）的存在，各个核心的缓存之间不会存在不同步的问题。 这里简单讲一下缓存一致性协议 MESI，当各个 CPU 核心都缓存了一个共享变量时，有任何一个核心对它作出了修改都会让其他核心内对应变量的缓存单元失败（这里失效的是整个 CacheLine，不仅仅是变量所占用的区域）并且把修改值同步到主内存。其他核心如果后续要操作这个变量，必须从主内存读，这样就可以保证各个缓存的一致性。 但引入缓存一致性协议会有很大的性能损耗，为了解决这个问题，又进行了各种优化，这其中就有在计算单元和一级缓存之间引入 StoreBuffer 和 LoadBuffer ，如下图所示： StoreBuffer 和 LoadBuffer 的引入，大大提升了计算机性能，但同时也带来了一些问题：各级缓存之间数据是一致的，但 StoreBuffer 和 LoadBuffer 一级缓存之间的数据却是异步的，这里就会存在一致性问题。 当一个缓存中的数据被修改后，会存到 StoreBuffer 中，而 StoreBuffer 不会立即把修改后的数据同步到主内存，这时其他核心在主内存中读取到就是旧数据，也就是说一个数据在一个核心的写操作会出现对其他核心不可见的情况，这就是内存可见性问题。 重排序上面讲的内存可见性问题其本质就是 CPU 内存重排序，它是重排序的一种。这里讲一下什么是重排序。 重排序分为三种：编译重排序、CPU 指令重排序和 CPU 内存重排序。 编译器重排序：对于没有先后依赖的语句，编译器可以重新调整语句的顺序； CPU 指令重排序：对于没有先后依赖的指令并行执行； CPU 内存重排序：CPU 有自己的缓存，指令的执行顺序与写入主内存的顺序不一定一致。 编译器重排序对开发者来说是无感知的，我们主要关注的是 CPU 指令重排序和 CPU 内存重排序，这两者都会对运行结果产生影响。 举个例子：假如有 X，Y，a，b 四个共享变量，我们在两个不同的线程分别执行下面的代码： 线程一： 12X = 1;a = Y; 线程二： 12Y = 1;b = X; 这两个线程的执行顺序是不一定的，有可能是顺序执行，也可能是交叉执行，最终结果可能是： a = 0, b = 1 (线程一执行 -&gt; 线程二执行) b = 0, a = 1 (线程二执行 -&gt; 线程一执行) a = 1, b = 1 (两个线程交叉执行) 上面就是 CPU 指令重排序产生的影响。但实际情况会有第四种结果： a = 0, b = 0 （内存重排序） 导致这个结果的原因是两个线程全部或其中一个的写入操作没有同步到主内存中，因此给 a 或 b 赋值时读取到的还是旧值 0，这就是内存可见性问题。 CPU 指令重排序问题我们可以通过锁、CAS 等同步机制来解决，编译器重排序和 CPU 内存重排序都可以通过引入内存屏障来解决，这里主要关注内存屏障在 CPU 重排序的应用。 内存屏障内存屏障是一个比较底层的概念，它能对重排序作一定的限制，不同的内存屏障对重排序限制不同，一般都是组合使用的。作为 Java 开发者我们知道使用 volatile 关键字修饰的变量不会存在内存可见性问题，它的原理其实就是在对变量的操作前后都加入了两个不同的内存屏障，以保证所有的读写组合都不会发生内存可见性问题。 可以把内存屏障分为四类： LoadLoad：禁止读和读的重排序 StoreStore：禁止写和写的重排序 LoadStore：禁止读和写的重排序 StoreLoad：禁止写和读的重排序 JDK 8 开始，Unsafe 类提供了三个内存屏障方法： 1234567public final class Unsafe &#123; // ... public native void loadFence(); public native void storeFence(); public native void fullFence(); // ...&#125; 这三个方法对应的内存屏障如下： loadFence = LoadLoad + LoadStore storeFence = StoreStore + LoadStore fullFence = loadFence + storeFence + StoreLoad 我们平常在开发中一般不会去主动使用内存屏障，而内存屏障所实现的效果可以用 happen-before 来描述。 happen-before首先来说说什么是 happen-before：它用来描述来个操作之间的内存可见性，如果 A 操作 happen-before 于 B 操作，那么 A 操作的执行结果必须是对 B 操作可见的，这里隐含了一个条件，只有在 A 操作的执行实际发生在 B 操作之前，这个可见性保证才会有效，happen-before 并不会去改变 A 和 B 的执行顺序。 JMM 规范借助 happen-before 可以更好的描述出来。 happen-before 有以下四个基本规则： 单线程中的每个操作，happen-before于该线程中任意后续操作。 对volatile变量的写，happen-before于后续对这个变量的读。 对synchronized的解锁，happen-before于后续对这个锁的加锁。 对final变量的写，happen-before于final域对象的读，happen-before于后续对final变量的读。 除了以上四个基础规则之外，happen-before 还具有传递性。传递性是指当 A happen-before 于 B，B happen-before 于 C ，那么操作 A 的结果一定对操作 C 可见。 这四个基本规则再加上 happen-before 的传递性，就构成了 JMM 对开发者的整个承诺。在这个承诺之后的部分，开发者就需要小心处理内存可见性问题。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://anye3210.github.io/tags/Java/"},{"name":"内存模型","slug":"内存模型","permalink":"http://anye3210.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"name":"happen-before","slug":"happen-before","permalink":"http://anye3210.github.io/tags/happen-before/"},{"name":"内存可见性","slug":"内存可见性","permalink":"http://anye3210.github.io/tags/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/"},{"name":"重排序","slug":"重排序","permalink":"http://anye3210.github.io/tags/%E9%87%8D%E6%8E%92%E5%BA%8F/"}]},{"title":"【React Native进阶】React Native Reanimated的使用","slug":"【React-Native进阶】React-Native-Reanimated的使用","date":"2020-12-15T15:32:58.000Z","updated":"2021-08-22T07:17:09.934Z","comments":true,"path":"2020/12/15/【React-Native进阶】React-Native-Reanimated的使用/","link":"","permalink":"http://anye3210.github.io/2020/12/15/%E3%80%90React-Native%E8%BF%9B%E9%98%B6%E3%80%91React-Native-Reanimated%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"前言上一篇文章讲解了React Native性能优化的总体思路，并进一步讲解了React Native Gesture Handler的使用。本文讲解另外一个库React Native Reanimated，这个库旨在解决React Native在动画方面的性能问题，让我们能够创建运行在UI线程上的顺滑动画和流畅交互。 Reanimated实现动机上一篇文章讲了React Native中业务逻辑和计算都是在JavaScript线程中，渲染是在UI线程中，两个线程是通信又是异步的，因此渲染并不是实时的，至少会有1桢的延迟，在动画方面也是同样的。 Reanimated将JavaScript线程上的动画和事件处理逻辑转移到了UI线程。它通过定义Reanimated worklet(可以被移动到一个单独的JavaScript 虚拟机并在UI线程上同步运行的一小段JavaScript代码）来实现。这种机制让我们的触摸事件可以立即被响应并在同一桢上更新UI，不必再担心JavaScript加载和同步这些问题。 注意：本文讲解的是当前最新的版本2.0.0-alpha.9，它与版本1有较大的差异。","text":"前言上一篇文章讲解了React Native性能优化的总体思路，并进一步讲解了React Native Gesture Handler的使用。本文讲解另外一个库React Native Reanimated，这个库旨在解决React Native在动画方面的性能问题，让我们能够创建运行在UI线程上的顺滑动画和流畅交互。 Reanimated实现动机上一篇文章讲了React Native中业务逻辑和计算都是在JavaScript线程中，渲染是在UI线程中，两个线程是通信又是异步的，因此渲染并不是实时的，至少会有1桢的延迟，在动画方面也是同样的。 Reanimated将JavaScript线程上的动画和事件处理逻辑转移到了UI线程。它通过定义Reanimated worklet(可以被移动到一个单独的JavaScript 虚拟机并在UI线程上同步运行的一小段JavaScript代码）来实现。这种机制让我们的触摸事件可以立即被响应并在同一桢上更新UI，不必再担心JavaScript加载和同步这些问题。 注意：本文讲解的是当前最新的版本2.0.0-alpha.9，它与版本1有较大的差异。 当前版本的问题和限制Reanimated 第二个版本当前还处于早期。由于制作这个库的团队想尽早向公众分享它，这个库还存在一些瑕疵和限制，他们计划很快解决。但有一些限制是来自Reanimated 2所依赖的 React Native 的TurboModules 架构的成熟。这个版本计划解决的一些问题可能需要全面支持TurboModules，而TurboModules尚未向公众开放。 下面就是这个版本的一些问题： 安装步骤比较复杂。这源于TurboModules尚未在React Native应用程序模板中推出； 目前只在Android上支持Hermes JS VM; 由于这个库使用了JSI进行同步本机方法访问，这导致远程调试就没办法使用了。可以使用Flipper调试JS代码，但不支持将调试器连接到UI线程上运行的JS上下文； 库在开发模式下重新加载JS捆绑包或热加载时偶尔会崩溃。 在 worklets 中抛出的JavaScript异常有时会产生非描述性错误，并可能导致应用程序崩溃; 从React Native传递给 worklets 的对象在 JavaScript 中没有正解的 prototype。因此，此类对象不可枚举，即不能使用“for in”构造、扩展运算符（三个点）或Object.assign等函数。 安装Reanimated 2主要使用Turbo Modules架构并在C++中构建，该架构尚未完全部署在React Native（特别是在Android上）。因此，安装新的Reanimated除了向package.json添加依赖项外，还需要额外的步骤。 由于上述原因，React Native的最低支持版本是v0.62。在继续安装之前，请确保我们的项目正在运行在受支持的React Native版本上。 安装包首先在项目中安装react-native-reanimated alpha 依赖： 1&gt; yarn add react-native-reanimated@alpha 配置 Android修改android/app/build.gradle，打开 Hermes 引擎 123project.ext.react = [ enableHermes: true // &lt;- here | clean and rebuild if changing] 在MainApplication.java中插入 Reanimated 1234567891011121314151617import com.facebook.react.bridge.JSIModulePackage; // &lt;- addimport com.swmansion.reanimated.ReanimatedJSIModulePackage; // &lt;- add...private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123;... @Override protected String getJSMainModuleName() &#123; return &quot;index&quot;; &#125; @Override protected JSIModulePackage getJSIModulePackage() &#123; return new ReanimatedJSIModulePackage(); // &lt;- add &#125; &#125;;... 配置iOS在 iOS 上的安装是自动的，不需要额外配置。 核心概念Workletsworklets 的最终目标是定义一小段运行在 UI 线程用来更新视图属性和响应事件的 JavaScript 代码。正常这种结构用 JavaScript 来实现就会是一个简单的方法。在这个版本中有一个次级的运行在 UI 线程的 JS 上下文，JavaScript 代码能够在这个上下文里面运行。实现这个 worklets 方法只需要在方法内部第一行加上”worklet”命令即可： 1234function someWorklet(greeting) &#123; &#x27;worklet&#x27;; console.log(&quot;Hey I&#x27;m running on the UI thread&quot;);&#125; 我们在使用这些方法的时候还可以传递参数。每个 worklet 方法如果你直接在代码里面调用就会运行在 React Native 的主线程上，如果使用runOnUI方法调用就可以运行在 UI 线程上。注意这种调用在使用者的视角上看是异步的（即调用与运行不在同一个线程上）。当你传递了参数，那这个参数会被复制到 UI 线程的 JS 上下文中。 12345678function someWorklet(greeting) &#123; &#x27;worklet&#x27;; console.log(greeting, &#x27;From the UI thread&#x27;);&#125;function onPress() &#123; runOnUI(someWorklet)(&#x27;Howdy&#x27;);&#125; 如果你在 worklet 方法外部定义了一个变量并在方法里使用了它，那么这个变量同样会被复制进来： 123456const width = 135.5;function otherWorklet() &#123; &#x27;worklet&#x27;; console.log(&#x27;Captured width is&#x27;, width);&#125; worklet 也可以从其他的 worklet 方法中获取参数，当这些方法被调用时，它们是在 UI 线程同步运行的： 12345678910function returningWorklet() &#123; &#x27;worklet&#x27;; return &quot;I&#x27;m back&quot;;&#125;function someWorklet() &#123; &#x27;worklet&#x27;; let what = returningWorklet(); console.log(&#x27;On the UI thread, other worklet says&#x27;, what);&#125; 这个特性也同样适用于普通方法。需要注意的是，console.log只在 React Native 上下文中定义了的，在 UI 线程是没有这个方法的，因此上面的这些例子中console.log都是运行在 React Native 主线程上的。 123456789function callback(text) &#123; console.log(&#x27;Running on the RN thread&#x27;, text);&#125;function someWorklet() &#123; &#x27;worklet&#x27;; console.log(&quot;I&#x27;m on UI but can call methods from the RN thread&quot;); callback(&#x27;can pass arguments too&#x27;);&#125; 使用勾子函数（hooks）在平常使用时，我们很少自己去去写”worklet”命令去定义 worklet 方法，一般情况都是直接使用这个库中已经定义好的勾子函数，比如：useAnimatedStyle, useDerivedValue, useAnimatedGestureHandler等。当我们使用这些勾子函数时，系统会自动识别到这是一个 worklet 并运行到 UI 线程上。 123456const style = useAnimatedStyle(() =&gt; &#123; console.log(&quot;Running on the UI thread&quot;); return &#123; opacity: 0.5 &#125;;&#125;); Shared ValuesShared Values 是 Reanimated 2.0 最基础的理念之一。它有点类似于 React Native 内置的 Animated.API。它们都服务于相似的目标：携带动画所需要的数据，提供响应式和驱动式的动画。下面几个小节会详细介绍 Shared Values 的这些关键角色。后面也会有表格详细对照 Shared Values 与 Animated.Value 区别。 携带数据Shared Values 的主要目的是提供共享内存的概念。在前面学习 worklet 时我们了解到 Reanimated 2.0 的动画代码是使用单独的 JS VM 上下文运行在单独的线程中的。Shared Values 就能够对可变数据保持引用以便这些数据能够在不同的线程中被读取和修改。 Shared Value 对象对这些共享数据提供了引用，这些共享数据可以通过对象的.value属性来获取和修改。记住无论是获取数据还是修改数据，都需要使用.value(最经常看到的错误就是直接使用 Shared Value 来获取和修改数据而不是使用它的.value属性）。 为了兼顾安全和速度，Reanimated 2.0 在设计的时候会做一些权衡。使用 worklet 在主线程读取和修改的数据能够立即更新渲染到屏幕上。而在 JavaScript 线程上的更新操作不会立刻执行，变成一个更新计划之后再提交到 UI 线程上执行。这种方式类似于 React Native 的状态管理：我们更新了状态，这些状态不会立即被执行，而是在下一个 re-render 的时候执行。 创建一个 Shared Value 需要使用勾子函数useSharedValue： 1const sharedVal = useSharedValue(3.1415) 这个 Shared Value 构造器勾子函数需要传入一个参数作为初始变量值。这个初始数据可以是对象、数组、数字、字符串或者布尔值。 更新 Shared Value 需要使用.value赋一个新的值： 1234567891011import &#123; useSharedValue &#125; from &#x27;react-native-reanimated&#x27;;function SomeComponent() &#123; const sharedVal = useSharedValue(0); return ( &lt;Button onPress=&#123;() =&gt; (sharedVal.value = Math.random())&#125; title=&quot;Randomize&quot; /&gt; );&#125; 上面这个例子我们是在 JavaScript 线程上更新的数据，这个更新是异步的。使用worklet能够让这个更新变成同步的： 123456789101112131415161718import Animated, &#123; useSharedValue, useAnimatedScrollHandler &#125; from &#x27;react-native-reanimated&#x27;;function SomeComponent(&#123; children &#125;) &#123; const scrollOffset = useSharedValue(0); const scrollHandler = useAnimatedScrollHandler(&#123; onScroll: event =&gt; &#123; scrollOffset.value = event.contentOffset.y; &#125;, &#125;); return ( &lt;Animated.ScrollView onScroll=&#123;scrollHandler&#125;&gt; &#123;children&#125; &lt;/Animated.ScrollView&gt; );&#125; 上面的 scroll handler 就是一个 worklet，它的滚动事件是在 UI 线程上运行的。因此它里面的更新也是同步的。 Shared Values 的响应性Shared Values 第二个非常重要的特性就是为 Reanimated 提供了响应性的理念。基于这个特性，Shared Value 可以驱动相应的代码在 UI 线程执行，也可以执行开始动画、更新视图等操作。 当前两种方法创建反应式的 worklet，分别是useAnimatedStyle和useDerivedValue。当这样的勾子函数捕获了一个 Shared Value，每当 Shared Value的数据被更新时，这些勾子函数都会重新运行。Reanimated 引擎会创建一个 Shared Value 与 worklet 对应关系的表以保证我们只执行需要更新的代码以及执行的顺序。比如，当我们有一个 Shared Value x、一个基于x值变化的变量y和同时使用x与y的 animated style，那么当x的值更新时，只会重新运行起源于x的 worklet。在这个例子中，由于 animated style 会基于y的值，y的值会优先更新以保证 animated style 的更新。 示例代码如下： 123456789101112131415161718import Animated, &#123; useSharedValue, useAnimatedStyle &#125; from &#x27;react-native-reanimated&#x27;;function Box() &#123; const offset = useSharedValue(0); const animatedStyles = useAnimatedStyle(() =&gt; &#123; return &#123; transform: [&#123; translateX: offset.value * 255 &#125;], &#125;; &#125;); return ( &lt;&gt; &lt;Animated.View style=&#123;[styles.box, animatedStyles]&#125; /&gt; &lt;Button onPress=&#123;() =&gt; (offset.value = Math.random())&#125; title=&quot;Move&quot; /&gt; &lt;/&gt; );&#125; 在上面的代码中，我们定义了 Shared Value offset，并把它使用在了useAnimatedStyle这个 worklet 里。offset的初始值是0，然后我们添加了一个按钮通过Math.random()函数更新offset的值。因此每当我们点击一次按钮，offset的值就会更新为一个0到1区间中的平均数。由于 animated style 的 worklet 是响应式的，在这个例子中它是基于offset的值响应，只有初始化的时候或者offset值更新的时候这个 worklet 才会运行。由于在 worklet 里作了一个 * 255的计算，因此实际的translateX在按钮的点击下在0到255变动。 操作动画动画是 Reanimated 2里的重中之重，在这个库中有大量帮助我们运行和自定义动画的实用方法。其中一种动画的方式就是使 Shared Value 的值进行动态变化。它可以通过用 reanimated 库里的方法（例如：withTiming、withSpring）把目标值包装起来来实现： 123import &#123; withTiming &#125; from &#x27;react-native-reanimated&#x27;;someSharedValue.value = withTiming(50); 在上面的代码中offset的值没有直接被设定成50，而是随着时间推移从当前值渐变到50。当然，这种动画形式可以在 UI 线程上实现也可以在 React Native 主线程上实现。下面是完整的从上面小节例子上修改之后的代码： 1234567891011121314151617181920212223import Animated, &#123; withSpring &#125; from &#x27;react-native-reanimated&#x27;;function Box() &#123; const offset = useSharedValue(0); const animatedStyles = useAnimatedStyle(() =&gt; &#123; return &#123; transform: [&#123; translateX: offset.value * 255 &#125;], &#125;; &#125;); return ( &lt;&gt; &lt;Animated.View style=&#123;[styles.box, animatedStyles]&#125; /&gt; &lt;Button onPress=&#123;() =&gt; &#123; offset.value = withSpring(Math.random()); &#125;&#125; title=&quot;Move&quot; /&gt; &lt;/&gt; );&#125; 上面的代码中我们所做的修改仅仅是将Math.random()包裹在了withSpring方法中。加上这个方法后动画会更平滑： 关于withTiming、withSpring等方法的更多信息可以参考官方文档的介绍。 动画进度我们可以通过.value来获取基于 Shared Value 的动画的当前状态。当 Shared Value 的过渡动画开始之后，.value的值将会与动画的进度同步。也就是说，当动画开始时的初始值为0而且使用了withTiming(50)方法，完成这个过渡默认是300毫秒，我们可以在动画进行时通过.value来获取到从0到50之间动画的进度。 中断动画由于 Shared Value 保持其动画过渡状态，我们可以使所有的动画都完全中断。这意味着即使 Shared Value 当前正在运行动画，我们也可以对 Shared Value 进行更新，而不必担心这会导致意外和突然的动画故障。在这种情况下，重新赋值会导致之前的动画中断。如果新分配的值是一个数字（或其他任何常量值），则该新值将立即分配给 Shared Value，之前运行的动画将被取消。如果新分配的值也是动画，那么之前运行的动画将顺利过渡到新的动画中。速度等动画参数也会转变，这在基于 spring 的动画中尤为重要。这种行为模式在下面的动图中就可以看出，我们只是更频繁地点击按钮，这样新动画就会在前一个动画仍在运行时启动（与前一个示例相比没有代码更改）。 取消动画我们可以通过使用cancelAnimation方法实现不开始新动画的情况直接取消当前动画： 123import &#123; cancelAnimation &#125; from &#x27;react-native-reanimated&#x27;cancelAnimation(someSharedValue); 动画可以在 UI 线程被取消，也可以在 React Native 的 JS 线程上被取消。 Shared Values 与 Animated.Value 对比 table th:first-of-type { width: 10%; } table th:nth-of-type(2) { width: 450%; } table th:nth-of-type(3) { width: 45%; } 特性 Animated Value Shared Value Payload 仅支持数值或字符串类型 任何原始或嵌套数据结构（如对象、数组、字符串、数字、布尔值） 连接到视图的属性 直接把Animated.Value当作属性传递 Shared Value 不能直接与视图的属性进行锚定。我们应该使用useAnimatedStyle或者useAnimatedProps并在这些方法里面获取到 Shared Value 的值并将计算后的 styles 返回回去 更新值 使用value.setValue方法（如果使用了 native driver 值的更新就是异步的） 通过更新.value属性，如果在 UI 线程进行更新就是同步的，其他线程更新就是异步的 读取值 通过value.addListener来注册监听器来动态获取更新的值 直接通过.value属性就能获取存储在 Shared Value 里的值（UI 线程和 React Native 的 JS 线程都可以） 运行动画 使用Animated.spring、Animated.timing或其他方法，将 Animated Value 作为参数，通过 .start()方法启动动画。 把目标值用动画方法（例如：withTiming）包装起来并更新它的值即可 停止动画 通过Animated.timing的返回值获取动画对象的引用，并让它调用stopAnimation()方法 把 Shared Value 作为参数传递给cancelAnimation即可 插值 使用 Animated Value 的interplate()方法 使用带数字和配置参数的方法interpolated，并从这个方法返回插值。如果你需要让一个 Shared Value 自动跟踪另一个 Shared Value 的插值也可以单独使用useDerivedValue 动画接下来讲一下如何使用各种辅助方法进一步自定义动画。 useAnimatedStyle除了在给 Shared Value 赋值的时候使用类似withSpring的过渡方法制作动画以外，还可以直接在useAnimatedStyle方法里面使用这些过渡动画方法： 123456789const animatedStyles = useAnimatedStyle(() =&gt; &#123; return &#123; transform: [ &#123; translateX: withSpring(offset.value * 255), &#125;, ], &#125;;&#125;); 上面的代码中，我们将offset的值转换后再包裹在withSpring方法中。效果与之前给offset赋值之前就使用withSpring这个方法相同。这种写法的好处是将动画逻辑的代码都写在一起，在其他地方只需要给 Shared Value 赋值即可。经过上面的修改后，按钮部分的代码就可以改成下面这样： 1&lt;Button onPress=&#123;() =&gt; (offset.value = Math.random())&#125; title=&quot;Move&quot; /&gt; 自定义动画Reanimated 目前内置了三个动画辅助方法：withTiming、withSpring和withDecay。下面介绍一下前两种方法的常用配置选项。 这些动画辅助方法都有类似的结构。方法的第一个参数是目标值，第二个参数是配置选项，第三个参数是回调函数。回调函数会在动画完成或动画被中断或取消时运行，函数里有一个布尔值的参数，代表动画是否顺利完成而没有被取消： 123456789101112&lt;Button onPress=&#123;() =&gt; &#123; offset.value = withSpring(Math.random(), &#123;&#125;, (finished) =&gt; &#123; if (finished) &#123; console.log(&quot;ANIMATION ENDED&quot;); &#125; else &#123; console.log(&quot;ANIMATION GOT CANCELLED&quot;); &#125; &#125;); &#125;&#125; title=&quot;Move&quot;/&gt; Timing配置选项这个参数根据运行的动画不同也存在不同。对于 timing 动画而言，我们可以设置持续时间和 easing 方法（缓动方法）。你可能希望动画先快速加速然后减速，或者缓慢开始，然后在结束时再次加速和减速。我们可以通过 Reanimated 包中的Easing.bezier方法使用贝塞尔曲线来描述这种 easing 。但大多数情况，使用Easing.in、Easing.out或者Easing.inOut分别调整起点、终点或两端的时序曲线就足够了。Timing 动画默认持续时间为300毫秒，默认为平滑进出的曲线(Easing.inOut(Easing.quad))： 下面就是如何自定义 timing 动画的配置： 123456import &#123; Easing, withTiming &#125; from &#x27;react-native-reanimated&#x27;;offset.value = withTiming(0, &#123; duration: 500, easing: Easing.out(Easing.exp),&#125;); 你也可以查看easings.net这个网站来查看不同 timing 动画的 easing 效果。Reanimated 所有的 easing 方法都是在Easing.js文件里定义的，如果在使用的有问题可以参考这个文件。 Spring与 Timing 动画不同的是，Spring 动画不将持续时间作为参数。Spring 动画的持续时间由 spring 物理特性、初始速度和行进距离决定。下面我们通过例子来了解如何自定义 spring 动画并将它与默认的 spring 动画设定进行对比： 123456789101112131415161718192021222324252627282930313233343536import Animated, &#123; withSpring, useAnimatedStyle, useSharedValue,&#125; from &#x27;react-native-reanimated&#x27;;function Box() &#123; const offset = useSharedValue(0); const defaultSpringStyles = useAnimatedStyle(() =&gt; &#123; return &#123; transform: [&#123; translateX: withSpring(offset.value * 255) &#125;], &#125;; &#125;); const customSpringStyles = useAnimatedStyle(() =&gt; &#123; return &#123; transform: [ &#123; translateX: withSpring(offset.value * 255, &#123; damping: 20, stiffness: 90, &#125;), &#125;, ], &#125;; &#125;); return ( &lt;&gt; &lt;Animated.View style=&#123;[styles.box, defaultSpringStyles]&#125; /&gt; &lt;Animated.View style=&#123;[styles.box, customSpringStyles]&#125; /&gt; &lt;Button onPress=&#123;() =&gt; (offset.value = Math.random())&#125; title=&quot;Move&quot; /&gt; &lt;/&gt; );&#125; 与前面的例子不同，这里使用了useAnimatedStyle函数。这样就可以使用一个 Shared Value 来驱动两个不同的动画效果。 动画修饰器除了自定义配置参数以外，另外一种自定义动画的方法就是使用动画修饰器。目前，Reanimated 有三个修饰器：withDecay、withSequence和withRepeat。顾名思义，withDelay修饰器让动画在指定的延时之后开始，withSequence修饰器允许传入多个动画作为参数，并让它们依次运行，withRepeat修饰符可以让动画重复执行。 修饰器通过将一个或多个动画作为参数传入，并返回一个修改后的动画对象。这样就可以让这些动画方法嵌套，或者让这些动画修饰器组成一个修饰链。 现在让我们来练习一下动画修饰器的使用。下面的例子我们来实现单击按钮触发矩形按钮的摆动效果。首先我们先定义需要渲染的视图和需要用到的 Shared Value。 1234567891011121314151617181920212223import Animated, &#123; useSharedValue, useAnimatedStyle &#125; from &#x27;react-native-reanimated&#x27;;function WobbleExample(props) &#123; const rotation = useSharedValue(0); const animatedStyle = useAnimatedStyle(() =&gt; &#123; return &#123; transform: [&#123; rotateZ: `$&#123;rotation.value&#125;deg` &#125;], &#125;; &#125;); return ( &lt;&gt; &lt;Animated.View style=&#123;[styles.box, animatedStyle]&#125; /&gt; &lt;Button title=&quot;wobble&quot; onPress=&#123;() =&gt; &#123; // will be filled in later &#125;&#125; /&gt; &lt;/&gt; );&#125; 在上面的示例中我们定义的 Shared Value 将会用来代表视图的旋转。然后，在useAnimatedStyle我们通过添加 “deg” 后缀将变量的单位更改为度。下面在按钮的onPress方法中添加修饰器代码： 1rotation.value = withRepeat(withTiming(10), 6, true) 上面的代码表示视图将从初始角度0到目标角度10之间重复旋转6次，第三个参数设置代表动画运行到终点时是否需要反向回到起点。将第三个参数设置为true将使旋转进行完整三个循环，最终回到原点。当我们点击按钮时，效果如下： 上面的代码让旋转只在0度和10度之间进行。为了让视图也向左摆，我们可以从角度-10旋转到10度。但如果我们直接把初始值更改为-10，那个矩形一开始就会是斜的。解决这个问题的方法就是使用withSequence，从0度开始，将第一个动画最终值设置为-10度，然后视图从-10度到10度摆动6次，最后再从-10度回到初始位置0度。下面是修改后的代码： 12345rotation.value = withSequence( withTiming(-10, &#123; duration: 50 &#125;), withRepeat(withTiming(ANGLE, &#123; duration: 100 &#125;), 6, true), withTiming(0, &#123; duration: 50 &#125;)); 上面的代码对三个动画设置了不同的持续时长，以保证矩形以相同的速度旋转，下面就是最后的实现效果： 总结至此，关于 React Native Reanimated 的使用就已经学习完了，如果想要进一步学习可以查看官方文档。后面文章会继续讲解 React Native Gesture Handler 与 React Native Reanimated 配合使用。","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://anye3210.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"React Native","slug":"React-Native","permalink":"http://anye3210.github.io/tags/React-Native/"},{"name":"React Native Reanimated","slug":"React-Native-Reanimated","permalink":"http://anye3210.github.io/tags/React-Native-Reanimated/"},{"name":"Reanimated","slug":"Reanimated","permalink":"http://anye3210.github.io/tags/Reanimated/"},{"name":"进阶","slug":"进阶","permalink":"http://anye3210.github.io/tags/%E8%BF%9B%E9%98%B6/"}]},{"title":"【React Native进阶】React Native Gesture Handler的使用","slug":"【React-Native进阶】react-native-gesture-handler的使用","date":"2020-12-14T14:09:41.000Z","updated":"2021-08-22T07:20:33.341Z","comments":true,"path":"2020/12/14/【React-Native进阶】react-native-gesture-handler的使用/","link":"","permalink":"http://anye3210.github.io/2020/12/14/%E3%80%90React-Native%E8%BF%9B%E9%98%B6%E3%80%91react-native-gesture-handler%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"背景说到React Navtive的性能优化，首先要了解React Native的运行机制。React Native程序主要运行在三个并行的线程上： JavaScript Thread：我们写的JavaScript代码逻辑都是在这个线程上执行； UI Thread：即原生线程，当我们需要调用原生的渲染或者能力时会运行到这个线程上； Shadow Thread：这个线程创建和管理着Shadow Tree，它类似于虚拟DOM。它通过Yoga引擎着Flexbox布局转化为原生的布局方式。 这三个线程独立运行的情况下，性能良好，但如果涉及到事件驱动与UI线程有交互的情况，React Native的这种设计效果不佳。 当与触摸屏交互时，用户希望屏幕上的效果是即时的。如果更新发生在单独的线程中，通常情况下，在JavaScript线程中所做的更改无法反映在同一帧中。在React Native中，默认情况下，由于UI和JavaScript线程之间的通信是异步的，并且UI线程从不等待JavaScript线程完成处理事件，因此所有更新都会延迟至少一个帧。 而且由于UI线程与其他线程通信存在序列化和反序列化这个比较消耗性能的步骤，当UI线程与其他线程交互比较频繁或者其他线程负荷较大时，通常事件无法立即处理，从而造成更严重的延迟。 我们的RN代码逻辑都是用JavaScript写的，JavaScript线程也是负荷最大的线程。因此在React Native的性能优化上主要要考虑两个方面： 减少与UI线程的通信； 减少JavaScript线程的负荷； 而React Native Gesture Handler正是从这两个方面优化React Native在手势操作方面的性能。它旨在替换React Native自带的手势处理系统。如果你使用过系统自带的手势处理系统，会发现在JavaScript线程会有大量的计算，这些计算也会频繁与UI线程通信，对性能影响较大。具体代码可以自行比较，这里不再赘述。","text":"背景说到React Navtive的性能优化，首先要了解React Native的运行机制。React Native程序主要运行在三个并行的线程上： JavaScript Thread：我们写的JavaScript代码逻辑都是在这个线程上执行； UI Thread：即原生线程，当我们需要调用原生的渲染或者能力时会运行到这个线程上； Shadow Thread：这个线程创建和管理着Shadow Tree，它类似于虚拟DOM。它通过Yoga引擎着Flexbox布局转化为原生的布局方式。 这三个线程独立运行的情况下，性能良好，但如果涉及到事件驱动与UI线程有交互的情况，React Native的这种设计效果不佳。 当与触摸屏交互时，用户希望屏幕上的效果是即时的。如果更新发生在单独的线程中，通常情况下，在JavaScript线程中所做的更改无法反映在同一帧中。在React Native中，默认情况下，由于UI和JavaScript线程之间的通信是异步的，并且UI线程从不等待JavaScript线程完成处理事件，因此所有更新都会延迟至少一个帧。 而且由于UI线程与其他线程通信存在序列化和反序列化这个比较消耗性能的步骤，当UI线程与其他线程交互比较频繁或者其他线程负荷较大时，通常事件无法立即处理，从而造成更严重的延迟。 我们的RN代码逻辑都是用JavaScript写的，JavaScript线程也是负荷最大的线程。因此在React Native的性能优化上主要要考虑两个方面： 减少与UI线程的通信； 减少JavaScript线程的负荷； 而React Native Gesture Handler正是从这两个方面优化React Native在手势操作方面的性能。它旨在替换React Native自带的手势处理系统。如果你使用过系统自带的手势处理系统，会发现在JavaScript线程会有大量的计算，这些计算也会频繁与UI线程通信，对性能影响较大。具体代码可以自行比较，这里不再赘述。 功能React Native Gesture Handler提供了以下功能： 提供了包括缩放、旋转、屏蔽滑动等手势的处理系统； 能够定义多个手势之间的关系。例如：当你在ScrollView里面加入一个滑动手势（pan handler）时，可以让滑动手势响应结束后再响应ScrollView； 提供了让手势运行在原生线程（UI线程）上并遵从原生平台默认行为机制； 由于使用了原生的动画驱动，即便在JavaScript线程已经超负荷的情况，也能够提供顺滑的手势交互。 安装整个安装分为三个部分：JS部分、Android部分和iOS部分。其中JS和iOS部分都是统一的，Android在使用了第三方导航库和没使用的情况安装配置方式会有不同。 JS使用yarn安装： 1yarn add react-native-gesture-handler 或者你也可以选择使用npm： 1npm install --save react-native-gesture-handler Android如果在项目中使用了导航库（例如：react-native-navigation），直接跳过这部分看后面配合导航库使用的小节。 更新MainActivity.java文件（或者你在其他地方创建的ReactActivityDelegate实例的内部），重写创建ReactRootView的方法，让这个库的根视图包裹安卓的主活动。注意在文件顶部需要导入ReactActivityDelegate、ReactRootView和RNGestureHandlerEnabledRootView： 123456789101112131415161718192021222324package com.swmansion.gesturehandler.react.example;import com.facebook.react.ReactActivity;+ import com.facebook.react.ReactActivityDelegate;+ import com.facebook.react.ReactRootView;+ import com.swmansion.gesturehandler.react.RNGestureHandlerEnabledRootView;public class MainActivity extends ReactActivity &#123; @Override protected String getMainComponentName() &#123; return &quot;Example&quot;; &#125;+ @Override+ protected ReactActivityDelegate createReactActivityDelegate() &#123;+ return new ReactActivityDelegate(this, getMainComponentName()) &#123;+ @Override+ protected ReactRootView createRootView() &#123;+ return new RNGestureHandlerEnabledRootView(MainActivity.this);+ &#125;+ &#125;;+ &#125;&#125; iOS如果在项目中使用了Cocoapods（React Native 0.60及之后的版本创建时会自动使用），需要在启动前安装pods： 1cd ios &amp;&amp; pod install 如果React Native版本为0.61或更高，则需要在index.js文件顶部导入库文件： 1import &#x27;react-native-gesture-handler&#x27;; 配合导航库使用如果你在项目中使用了像react-native-navigation 这样的导航库，由于本地导航库和Gesture Handler库都需要它们自己的ReactRootView子类，在安卓不能使用上述配置，需要如下单独配置。 与上面的修改Java原生代码不同，你需要在JavaScript代码中将每个页面的组件用gestureHandlerRootHOC包裹起来。可以像下面这样配置： 12345678910111213141516171819import &#123; gestureHandlerRootHOC &#125; from &#x27;react-native-gesture-handler&#x27;;import &#123; Navigation &#125; from &#x27;react-native-navigation&#x27;;import FirstTabScreen from &#x27;./FirstTabScreen&#x27;;import SecondTabScreen from &#x27;./SecondTabScreen&#x27;;import PushedScreen from &#x27;./PushedScreen&#x27;;// register all screens of the app (including internal ones)export function registerScreens() &#123; Navigation.registerComponent(&#x27;example.FirstTabScreen&#x27;, () =&gt; gestureHandlerRootHOC(FirstTabScreen) ); Navigation.registerComponent(&#x27;example.SecondTabScreen&#x27;, () =&gt; gestureHandlerRootHOC(SecondTabScreen) ); Navigation.registerComponent(&#x27;example.PushedScreen&#x27;, () =&gt; gestureHandlerRootHOC(PushedScreen) );&#125; 这部分的配置也可以参考官方的示例项目。 记住你需要把每一个页面的组件（也就是导航库里管理的每个页面）都包裹在gestureHandlerRootHOC下，只包裹主页面是不行的。 核心概念Gesture HandlersGesture Handler是这个手势库的核心，它用来描述原生触控系统里的元素，这些元素能够被JavaScript代码使用React的组件进行实例化和控制。 每一个Handler类型都代表了一种手势（例如：滑动、缩放），也包含了每种手势特有的事件（例如：translation, scale）。 这些Handler可以在UI线程同步地解析触摸事件流，即便在JavaScript线程阻塞的情况下也能保证手势交互不被打断。 Gesture Handler的组件并不会在原生的视图层级里面创建一个视图，它仅仅是在自己库里面注册然后连接到原生的视图里。所以当我们在使用这些Handler组件的时候，一定要记得 在内部添加一个对应着原生视图的子组件。 这个库提供了以下几种手势： PanGestureHandler TapGestureHandler LongPressGestureHandler RotationGestureHandler FlingGestureHandler PinchGestureHandler ForceTouchGestureHandler 手势分类这个手势库将手势分为两种：连续的和非连续的。 连续的手势被激活后会持续一段较长的时间，它会产生一个手势事件流。例如像滑动手势（PanGestureHandler），它被激活后就会开始持续为translation和其他属性提供更新。 而非连续性的手势一旦被激活就会立即结束。长按手势（LongPressGestureHandler）就是一个非连续的手势，它只在手指按住持续一段时间后会被激活，并不会追踪手指的移动。 记住只有连续的手势才能使用onGestureEvent，非连续性的手势Handler没有这个属性。 onGestureEventonGestureEvent参数接收Animated.event方法，这个方法是React Native系统自带的动画处理库的事件处理方法，例如： 123456789101112131415161718192021222324252627282930313233343536373839const circleRadius = 30;class Circle extends Component &#123; _touchX = new Animated.Value(windowWidth / 2 - circleRadius); _onPanGestureEvent = Animated.event([&#123; nativeEvent: &#123; x: this._touchX &#125; &#125;], &#123; useNativeDriver: true, &#125;); render() &#123; return ( &lt;PanGestureHandler onGestureEvent=&#123;this._onPanGestureEvent&#125;&gt; &lt;Animated.View style=&#123;&#123; height: 150, justifyContent: &#x27;center&#x27;, &#125;&#125;&gt; &lt;Animated.View style=&#123;[ &#123; backgroundColor: &#x27;#42a5f5&#x27;, borderRadius: circleRadius, height: circleRadius * 2, width: circleRadius * 2, &#125;, &#123; transform: [ &#123; translateX: Animated.add( this._touchX, new Animated.Value(-circleRadius) ), &#125;, ], &#125;, ]&#125; /&gt; &lt;/Animated.View&gt; &lt;/PanGestureHandler&gt; ); &#125;&#125; Animated.event会持续将nativeEvent里的x属性的值同步到对应的_touchX，而_touchX的改变会同步到Animated.View的translateX的改变，从而导致Animated.View的位移。上面就是一个简单的跟随手势移动的小球的例子。 这里其实也可以配合React Native Reanimated库使用，直接传入useAnimatedGestureHandler即可，在使用上也更简单，具体的使用方法以后的文章会讲到。 Handler的嵌套Handler只是锚定了它的子组件，并没有在原生视图层级里创建新的视图，因此这些手势Handler并不支持直接嵌套，需要在两个手势Handler之间放入&lt;Animated.View&gt;组件。 下面这种是不支持的： 1234567const PanAndRotate = () =&gt; ( &lt;PanGestureHandler onGestureEvent=&#123;Animated.event(&#123; ... &#125;, &#123; useNativeDriver: true &#125;)&#125;&gt; &lt;RotationGestureHandler onGestureEvent=&#123;Animated.event(&#123; ... &#125;, &#123; useNativeDriver: true &#125;)&#125;&gt; &lt;Animated.View style=&#123;animatedStyles&#125;/&gt; &lt;/RotationGestureHandler&gt; &lt;/PanGestureHandler&gt;); 需要在两个Handler之间放入&lt;Animated.View&gt;： 123456789const PanAndRotate = () =&gt; ( &lt;PanGestureHandler onGestureEvent=&#123;Animated.event(&#123; ... &#125;, &#123; useNativeDriver: true &#125;)&#125;&gt; &lt;Animated.View&gt; &lt;RotationGestureHandler onGestureEvent=&#123;Animated.event(&#123; ... &#125;, &#123; useNativeDriver: true &#125;)&#125;&gt; &lt;Animated.View style=&#123;animatedStyles&#125;/&gt; &lt;/RotationGestureHandler&gt; &lt;/Animated.View&gt; &lt;/PanGestureHandler&gt;); 另外一个特别需要注意的是当你在Animated.event中使用了useNativeDriver，它里面嵌套的子节点必须是Animated.API类型的。比例像View就必须被替换成Animated.View。 Handler State手势Handler可以被看作是一个状态机，每个Handler在有新的手势事件触发或者手势系统状态变更时都会更新当前的状态。 Handler的状态分为以下几种： UNDETERMINED FAILED BEGAN CANCELLED ACTIVE END 顾名思义，这里就不作过多解释了。 获取状态我们可以通过onHandlerStateChange来监听Handler的状态。状态可以通过nativeEvent的state属性获取到，然后与这个手势库中的State对象里的常量进行对比： 12345678910111213141516import &#123; State, LongPressGestureHandler &#125; from &#x27;react-native-gesture-handler&#x27;;class Demo extends Component &#123; _handleStateChange = (&#123; nativeEvent &#125;) =&gt; &#123; if (nativeEvent.state === State.ACTIVE) &#123; Alert.alert(&#x27;Longpress&#x27;); &#125; &#125;; render() &#123; return ( &lt;LongPressGestureHandler onHandlerStateChange=&#123;this._handleStateChange&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Longpress me&lt;/Text&gt; &lt;/LongPressGestureHandler&gt; ); &#125;&#125; 状态转换顺序最典型的状态转换顺序就是手势Handler捕获到触摸事件，然后识别出具体的手势，手势结束后重置到最初状态。这种状态转换顺序如下所示（长箭头表示状态改变前这里可能有更多的触摸事件）： UNDETERMINED -&gt; BEGAN ——&gt; ACTIVE ——&gt; END -&gt; UNDETERMINED 下面这种是Handler捕获到了触摸事件但是识别手势的时候失败的情况： UNDETERMINED -&gt; BEGAN ——&gt; FAILED -&gt; UNDETERMINED 下面这种是手势中断的情况： UNDETERMINED -&gt; BEGAN ——&gt; ACTIVE ——&gt; CANCELLED -&gt; UNDETERMINED 手势之间的交互这个手势库支持不同的手势Handler之间通信来构建更加复杂的手势交互。 有下面两种方法可以实现这种交互控制。每一种方法手势Handler都需要提供一个引用给其他Handler。手势Handler的引用是通过React.createRef()来创建的引用对象。 同时识别默认情况下同一个时间只有一种手势Handler可以是激活状态。当手势Handler识别到了一个手势，它会取消其他所有处于began状态的手势Handler并且在其激活状态下停止接收其他任何触摸事件。 这种行为可以通过simultaneousHandlers这个属性来改变，并且这个属性每种类型的Handler都有。这个属性持有一个数组，数组里有其他手势Handler的引用。手势Handler可以通过这种方式同时处于激活状态。 使用场景当我们实现图片预览组件的时候就需要这种同时识别，在图片预览中我们可以缩放、旋转而且可以在它缩放时移动它。在这个场景中我们需要使用PinchGestureHandler, RotationGestureHandler和PanGestureHandler并让它们能够被同时识别。 示例可以查看官方示例App中的“Scale, rotate &amp; tilt” example部分，以下是其中的片段： 123456789101112131415161718192021222324252627282930313233class PinchableBox extends React.Component &#123; // ...take a look on full implementation in an Example app render() &#123; const imagePinch = React.createRef(); const imageRotation = React.createRef(); return ( &lt;RotationGestureHandler ref=&#123;imageRotation&#125; simultaneousHandlers=&#123;imagePinch&#125; onGestureEvent=&#123;this._onRotateGestureEvent&#125; onHandlerStateChange=&#123;this._onRotateHandlerStateChange&#125;&gt; &lt;Animated.View&gt; &lt;PinchGestureHandler ref=&#123;imagePinch&#125; simultaneousHandlers=&#123;imageRotation&#125; onGestureEvent=&#123;this._onPinchGestureEvent&#125; onHandlerStateChange=&#123;this._onPinchHandlerStateChange&#125;&gt; &lt;Animated.View style=&#123;styles.container&#125; collapsable=&#123;false&#125;&gt; &lt;Animated.Image style=&#123;[ styles.pinchableImage, &#123; /* events-related transformations */ &#125;, ]&#125; /&gt; &lt;/Animated.View&gt; &lt;/PinchGestureHandler&gt; &lt;/Animated.View&gt; &lt;/RotationGestureHandler&gt; ); &#125;&#125; 等待其他手势完成使用场景这种手势交互方式最好的例子就是当我们在一个视图上同时注册了单次点击和双击事件的情况。这种情况下就需要单击事件等待双击事件识别完成后才识别，否则就会出现只识别单击事件而双击事件无法触发的情况。 示例参考官方示例App中的“Multitap” example部分，以下是部分片段： 1234567891011121314151617const doubleTap = React.createRef();const PressBox = () =&gt; ( &lt;TapGestureHandler onHandlerStateChange=&#123;(&#123; nativeEvent &#125;) =&gt; nativeEvent.state === State.ACTIVE &amp;&amp; Alert.alert(&#x27;Single tap!&#x27;) &#125; waitFor=&#123;doubleTap&#125;&gt; &lt;TapGestureHandler ref=&#123;doubleTap&#125; onHandlerStateChange=&#123;(&#123; nativeEvent &#125;) =&gt; nativeEvent.state === State.ACTIVE &amp;&amp; Alert.alert(&quot;You&#x27;re so fast&quot;) &#125; numberOfTaps=&#123;2&#125;&gt; &lt;View style=&#123;styles.box&#125; /&gt; &lt;/TapGestureHandler&gt; &lt;/TapGestureHandler&gt;); 总结至此，React Native Gesture Handler的基本使用就介绍完了。关于React Native优化，本文介绍的手势库只是解决了手势方面的性能问题，一般来说，手势都是配合了相应的动画使用的，比如手势拖拽功能，后面的文章会继续讲解动画的性能优化库React Native Reanimated以及这两个库如何配合使用。","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://anye3210.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"React Native","slug":"React-Native","permalink":"http://anye3210.github.io/tags/React-Native/"},{"name":"React Native Gesture Handler","slug":"React-Native-Gesture-Handler","permalink":"http://anye3210.github.io/tags/React-Native-Gesture-Handler/"},{"name":"Gesture Handler","slug":"Gesture-Handler","permalink":"http://anye3210.github.io/tags/Gesture-Handler/"}]},{"title":"【React Native教程】Stack Navigation与Tab Navigation嵌套最佳实践","slug":"【React-Native教程】StackNavigation与TabNavigation嵌套最佳实践","date":"2020-12-07T12:55:20.000Z","updated":"2021-08-22T07:21:59.797Z","comments":true,"path":"2020/12/07/【React-Native教程】StackNavigation与TabNavigation嵌套最佳实践/","link":"","permalink":"http://anye3210.github.io/2020/12/07/%E3%80%90React-Native%E6%95%99%E7%A8%8B%E3%80%91StackNavigation%E4%B8%8ETabNavigation%E5%B5%8C%E5%A5%97%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"背景上一篇文章详细讲解了react-navigation的使用，这篇文章主要说一下Stack Navigation与Tab Navigation嵌套的问题。 在iOS原生开发中，一般是在TabController里嵌套NavigationController，也就是说底部导航控制器里放多个堆栈导航控制器，每个堆栈导航控制器控制有独立的堆栈和状态。 但如果在使用react-navigation进行这种嵌套方式，由于根控制器是底部的TabNavigation，每次跳转到子控制器时，底部的导航栏不会隐藏。官方文档说可以用属性更改的方法隐藏底部导航栏，但不推荐，会影响性能。因此本文主要讲解如何使用堆栈导航器中嵌套底部导航控制器来解决这个问题。","text":"背景上一篇文章详细讲解了react-navigation的使用，这篇文章主要说一下Stack Navigation与Tab Navigation嵌套的问题。 在iOS原生开发中，一般是在TabController里嵌套NavigationController，也就是说底部导航控制器里放多个堆栈导航控制器，每个堆栈导航控制器控制有独立的堆栈和状态。 但如果在使用react-navigation进行这种嵌套方式，由于根控制器是底部的TabNavigation，每次跳转到子控制器时，底部的导航栏不会隐藏。官方文档说可以用属性更改的方法隐藏底部导航栏，但不推荐，会影响性能。因此本文主要讲解如何使用堆栈导航器中嵌套底部导航控制器来解决这个问题。 实现方式首先将Main控制器放入Stack Navigation中： 123456789101112131415161718192021class App extends Component &#123; render() &#123; return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen key=&quot;Main&quot; name=&quot;Main&quot; component=&#123;Main&#125; options=&#123;(&#123;route&#125;) =&gt; (&#123; headerTitle: route.name &#125;)&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; ); &#125; &#125; 然后实现Main控制器 1234567891011121314151617181920212223242526272829303132333435363738const Main = (&#123;navigation, route&#125;) =&gt; &#123; return ( &lt;Tab.Navigator screenOptions=&#123;(&#123; route &#125;) =&gt; (&#123; tabBarIcon: (&#123; focused, color, size &#125;) =&gt; &#123;`` return ( &lt;Image style = &#123;&#123; width: 25, height: 25 &#125;&#125; source = &#123;this.iconImage(route, focused)&#125; /&gt;); &#125;, &#125;)&#125; tabBarOptions=&#123;&#123; activeTintColor: &#x27;#32B7FF&#x27;, inactiveTintColor: &#x27;gray&#x27;, &#125;&#125; &gt; &lt;Tab.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; options=&#123;&#123;title: &#x27;Home&#x27;&#125;&#125;/&gt; &lt;Tab.Screen name=&quot;Settings&quot; component=&#123;SettingsScreen&#125; options=&#123;&#123;title: &#x27;Settings&#x27;&#125;&#125;/&gt; &lt;/Tab.Navigator&gt; );&#125;function iconImage(route, focused) &#123; let image; if (route.name === &#x27;Home&#x27;) &#123; image = focused ? require(&#x27;../../images/homePage_sel.png&#x27;) : require(&#x27;../../images/homePage_nor.png&#x27;); &#125; else &#123; image = focused ? require(&#x27;../../images/setting_sel.png&#x27;) : require(&#x27;../../images/setting_nor.png&#x27;); &#125; return image;&#125; 上面Home和Setting页面的实现这里就不再赘述，实现之后运行会发一Home和Setting顶部导航栏的标题和样式都是相同的，也就是Main控制器的。这是由于Tab Navigation作为Stack Navigation的根控制器，顶部导航栏的标题都是按照根控制器的设置来显示的。要实现Tab Navigaiton的子控制器都有自己的独立顶部导航栏，需要使用React的Hook方法，在return前面加上： 123456789101112131415161718React.useLayoutEffect(() =&gt; &#123; navigation.setOptions(&#123; headerTitle: this.getHeaderTitle(route), headerRight: this.getHeaderRight(route), headerLeft: this.getHeaderLeft(route), &#125;); &#125;, [navigation, route]); getHeaderTitle(route) &#123; const routeName = getFocusedRouteNameFromRoute(route) ?? &#x27;Home&#x27;; switch (routeName) &#123; case &#x27;Home&#x27;: return &#x27;首页&#x27;; case &#x27;Settings&#x27;: return &#x27;系统设置&#x27;; &#125;&#125; 这里使用了React的useLayoutEffect方法，这个方法会从DOM里读取布局并同步把新布局添加了布局更新计划中，等一下次重新绘制就会更新上去。在方法中通过route名称动态地改变了导航栏的标题和左右侧的按钮，当底部导航栏按钮被点击进行切换时，顶底的导航栏显示也会同步更新。 至此，Stack Navigation和Tab Navigation嵌套时保证跳转时隐藏底部导航栏的最佳实践就完成了。","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://anye3210.github.io/tags/React-Native/"},{"name":"React","slug":"React","permalink":"http://anye3210.github.io/tags/React/"},{"name":"Stack Navigation","slug":"Stack-Navigation","permalink":"http://anye3210.github.io/tags/Stack-Navigation/"},{"name":"Tab Navigation","slug":"Tab-Navigation","permalink":"http://anye3210.github.io/tags/Tab-Navigation/"},{"name":"嵌套","slug":"嵌套","permalink":"http://anye3210.github.io/tags/%E5%B5%8C%E5%A5%97/"}]},{"title":"【React Native】Redux自定义中间件","slug":"【React-Native】Redux自定义中间件","date":"2020-08-03T14:32:29.000Z","updated":"2021-08-22T07:56:25.999Z","comments":true,"path":"2020/08/03/【React-Native】Redux自定义中间件/","link":"","permalink":"http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91Redux%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"前言在上一篇文章中介绍了Redux在React Native中的基本使用，这篇文章介绍一下如何在Redux中自定义中间件。 中间件功能中间件的作用主要是拦截指定的Action，进行自定义操作后继续执行该Action或指派执行其他Action。这里拦截的Action主要是指同步的Action，异步Action在Thunk中间件已经提供了相关功能。","text":"前言在上一篇文章中介绍了Redux在React Native中的基本使用，这篇文章介绍一下如何在Redux中自定义中间件。 中间件功能中间件的作用主要是拦截指定的Action，进行自定义操作后继续执行该Action或指派执行其他Action。这里拦截的Action主要是指同步的Action，异步Action在Thunk中间件已经提供了相关功能。 自定义流程创建中间件以上一篇文件的Demo为例，这里添加一个参数检查的中间件。新建CheckParameterMidleware.js，添加如下代码： 1234567891011121314151617181920export function checkParameterMiddleware(&#123; dispatch &#125;) &#123; return function(next)&#123; return function(action)&#123; console.debug(action); if (action.type === &#x27;counter/incrementAction&#x27; || action.type === &#x27;counter/decrementActio&#x27;) &#123; console.debug(action); if (!checkIsNumber(action.payload)) &#123; return next(errorInput(&quot;请输入数字！&quot;)); &#125; &#125; return next(action); &#125;; &#125;;&#125;function checkIsNumber(value) &#123; return typeof value === &#x27;number&#x27; &amp;&amp; !isNaN(value);&#125; 这个中间件本质是一个嵌套的方法，外层方法会传入next和action， 我们可以用action的type区分不同的动作。如果是用Slice方式创建的Action``Type格式是这样的：auth名称/action名称。 在上面的方法中拦截了incrementAction和decrementAction两个方法，检查用户输入的是不是数字，如果不是数字则执行errorInput这个Action。 使用中间件要使创建的中间件生效，只需要在创建Store时传入相应的中间件即可。 1234567891011const middleware = [ ...getDefaultMiddleware(), checkParameterMiddleware];export const store = configureStore(&#123; reducer: &#123; count: countReducer, &#125;, middleware,&#125;); 接下来就可以尝试输入非数字检测中间件是否生效。 完整代码可以在这里查看。","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://anye3210.github.io/tags/React-Native/"},{"name":"React","slug":"React","permalink":"http://anye3210.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://anye3210.github.io/tags/Redux/"},{"name":"Middleware","slug":"Middleware","permalink":"http://anye3210.github.io/tags/Middleware/"},{"name":"中间件","slug":"中间件","permalink":"http://anye3210.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"【React Native教程】Redux入门教程","slug":"【React-Native教程】Redux入门","date":"2020-08-03T13:51:35.000Z","updated":"2021-08-22T07:56:05.593Z","comments":true,"path":"2020/08/03/【React-Native教程】Redux入门/","link":"","permalink":"http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E6%95%99%E7%A8%8B%E3%80%91Redux%E5%85%A5%E9%97%A8/","excerpt":"Redux定义Redux在官网上是这么定义的：A Predictable State Container for JS Apps，直译过来就是一个使用在JS应用上的可预测的状态容器。 Redux解决的问题React Native本身是基于前端的React框架，它是通过State来管理页面显示和参数更新。如果在交互比较复杂的页面、需要多页面状态传递或者同步更新状态的情况，状态管理就会比较麻烦。使用Redux就可以解决这些问题。 Redux的核心逻辑和概念Redux的核心逻辑是集中定义和管理状态和动作执行，各个页面使用connect方法绑定相应的方法和状态，并通过发送动作指令更新页面显示。达到状态和操作与页面隔离的效果。","text":"Redux定义Redux在官网上是这么定义的：A Predictable State Container for JS Apps，直译过来就是一个使用在JS应用上的可预测的状态容器。 Redux解决的问题React Native本身是基于前端的React框架，它是通过State来管理页面显示和参数更新。如果在交互比较复杂的页面、需要多页面状态传递或者同步更新状态的情况，状态管理就会比较麻烦。使用Redux就可以解决这些问题。 Redux的核心逻辑和概念Redux的核心逻辑是集中定义和管理状态和动作执行，各个页面使用connect方法绑定相应的方法和状态，并通过发送动作指令更新页面显示。达到状态和操作与页面隔离的效果。 StateState即状态，是React框架最基础的概念之一，通过更改状态实时更新页面显示。 1234&#123; prop1: value1, prop2: value2,&#125; ActionAction是指指令或者动作。在Redux中，页面不直接管理状态，每个页面都是通过发送Action间接地更新状态。Action中有两个参数，一个是Type，字符串类型，代表Action的类型和唯一标识，一个是payload，代表传递的参数，可以是任意类型。 1234&#123; type: &#x27;EXAMPLE_ACTION&#x27;, payload: &#x27;args&#x27;&#125; Reducer在Redux中状态和动作都是集中管理，管理者被称为Reducer，Reducer接收State和Action参数，根据传过来的Action类型和参数进行处理并更新State。 12345678function rootReducer(state = initialState, action) &#123; if (action.type === &#x27;FIRST_ACTION&#x27;) &#123; return Object.assign(&#123;&#125;, state, &#123; props: newValue &#125;); &#125; return state;&#125; Slice在以往的Redux使用中，我们需要自己创建Action和Reducer，并用Switch或者if else语句区分不同的Action，步骤非常繁琐。现在Redux官方推荐使用更方便更现代化的工具**@reduxjs/toolkit，这个工具集成了createAction、createReducer等方法，非常方便。不过这两个方法一般也不用，在tookit提供了一个新的类Slice，创建Slice时也会同时创建State、Reducer和Action。 12345678910111213141516const mySlice = createSlice(&#123; name: &quot;sliceName&quot;, initialState: &#123; prop1: &quot;&quot;, prop2: false, &#125;, reducers: &#123; action1: (state, action) =&gt; &#123; console.debug(&#x27;action1 done&#x27;+action.type); &#125;, action2: (state) =&gt; &#123; state.prop1 = &quot;123&quot;; state.prop2 = true; &#125;, &#125;,&#125;); 在需要使用Reducer和Action时，直接抽取即可 12const &#123; action1, action2 &#125; = authSlice.actions;const myReducer = mySlice.reducer; Thunk上面介绍的是普通Action，但如果是执行的动作需要异步执行后更新状态的就不适用了，因此Redux引入了中间件Thunk，在引入**@reduxjs/toolkit**后创建异步Action方法如下： 1234567891011121314151617181920212223242526272829export const doLogin = createAsyncThunk( &#x27;user/login&#x27;, async (&#123;username, password, code&#125;) =&gt; &#123; return await API.fetchData(&#123; path: &#x27;doLogin&#x27;, params: &#123; code: code, password: AESTool.encrypt(password), userName: username, &#125; &#125;); &#125;, &#123; condition: (&#123;username, password, code&#125;) =&gt; &#123; if (checkStringEmpty(username)) &#123; HUD.show(&quot;请输入用户名！&quot;); return false; &#125; else if (checkStringEmpty(password)) &#123; HUD.show(&quot;请输入密码！&quot;); return false; &#125; else if (checkStringEmpty(code)) &#123; HUD.show(&quot;请输入验证码！&quot;); return false; &#125; return true; &#125;, dispatchConditionRejection: true &#125;) 在上面的代码中，在condition可以控制这个异步Action是否可以继续执行，如果返回false，Action会终止执行而且没有回调。如果希望返回false后有rejected回调，可以设置dispatchConditionRejection为true。 异步Action执行完成后，回调是在Slice的extraReducers中，异步Action有三个状态：pending、fulfilled和rejected，分别代表正在执行、成功执行和执行失败 12345678910111213extraReducers: &#123; [ doLogin.pending ]: () =&gt; &#123; Loading.show(); &#125;, [ doLogin.fulfilled ]: (state, action) =&gt; &#123; Loading.hidden(); console.debug(action.payload) &#125;, [ doLogin.rejected ]: (state, action) =&gt; &#123; Loading.hidden(); console.warn(action.error); &#125;,&#125; StoreStore是Redux的核心类，它的作用是管理所有的Reducer和中间件，并作为参数传递到项目的根视图组件中。 1234567891011121314151617const middleware = [ ...getDefaultMiddleware(), CustomMiddleWare,];export const store = configureStore(&#123; reducer: &#123; auth: authReducer, common: commonReducer &#125;, middleware,&#125;);&lt;Provider store=&#123;store&#125;&gt; &lt;StatusBar barStyle=&#123;&#x27;light-content&#x27;&#125;/&gt; &lt;App/&gt;&lt;/Provider&gt; Redux在React Native中的使用下面以一个简单的计数器为例讲解一下如果在React Native中使用Redux。 安装依赖首先需要安装**@reduxjs/toolkit，可以使用NPM或者Yarn**。 12345# NPMnpm install @reduxjs/toolkit# Yarnyarn add @reduxjs/toolkit 然后安装Redux核心库 12345# NPMnpm install redux# Yarnyarn add redux 创建Slice创建Slice时会同步创建State、Reducer 1234567891011121314151617181920import &#123;createSlice&#125; from &#x27;@reduxjs/toolkit&#x27;;const countSlice = createSlice(&#123; name: &quot;count&quot;, initialState: &#123; value: 0 &#125;, reducers: &#123; incrementAction: (state, action) =&gt; &#123; state.value += action.payload; &#125;, decrementAction: (state, action) =&gt; &#123; state.value -= action.payload; &#125;, &#125;,&#125;);export const &#123;incrementAction, decrementAction &#125; = countSlice.actions;export const countReducer = countSlice.reducer; 在这里创建了名为count的Slice，计算器初始值为0，并在Reducer中定义了两个Action：incrementAction和decrementAction，根据传过来的参数确定每次加减的数值。后面两行export代码确保外部能够访问这里创建的Action和reducer。 创建Store接下来就是创建Store，创建时会传入刚刚创建的reducer。 注意：在页面获取状态值的时候中间一定要先获取reducer，然后再获取reducer里的状态值，例如获取countReducer里的value：state.count.value。 1234567891011121314import &#123;configureStore, createSlice, getDefaultMiddleware&#125; from &quot;@reduxjs/toolkit&quot;;import &#123;countReducer&#125; from &#x27;./slices/CountSlice&#x27;const middleware = [ ...getDefaultMiddleware(),];export const store = configureStore(&#123; reducer: &#123; count: countReducer, &#125;, middleware,&#125;); 至此，Redux部分就准备好了，接下来就是页面的交互部分了。 页面嵌入Redux在index.js文件中将Provider更改为App的根控件，并传入store作为参数： 123456789AppRegistry.registerComponent(appName, () =&gt; ProviderContainer);const ProviderContainer = () =&gt; &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;App/&gt; &lt;/Provider&gt; );&#125; 下面是App.js的主要代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; num: 1 &#125; &#125; render() &#123; return ( &lt;&gt; &lt;StatusBar barStyle=&quot;dark-content&quot; /&gt; &lt;SafeAreaView&gt; &lt;View style=&#123;styles.container&#125;&gt; &lt;TextInput style=&#123;styles.textInput&#125; onChangeText=&#123;(text)=&gt;&#123; this.setState(&#123; num: parseInt(text) &#125;) &#125;&#125;&gt;&#123;isNaN(this.state.num) ? 1 : this.state.num&#125;&lt;/TextInput&gt; &lt;View style=&#123;styles.buttonContainer&#125;&gt; &lt;TouchableOpacity style=&#123;styles.button&#125; activeOpacity = &#123;.9&#125; onPress=&#123;() =&gt; &#123; this.props.decrement(this.state.num) &#125;&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;-&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;Text style=&#123;styles.text&#125;&gt;&#123;this.props.value&#125;&lt;/Text&gt; &lt;TouchableOpacity style=&#123;styles.button&#125; activeOpacity = &#123;.9&#125; onPress=&#123;() =&gt; &#123; this.props.increment(this.state.num) &#125;&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;+&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/&gt; ); &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; value: state.count.value, &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; increment: (num) =&gt; dispatch(incrementAction(num)), decrement: (num) =&gt; dispatch(decrementAction(num)), &#125;;&#125;export default connect(mapStateToProps, mapDispatchToProps)(App); 上面的TextInput用于输入每次增加或者减小的数值，下面有一个加号按钮和一个减号按钮，中间是显示当前数值的文本。 mapStateToProps和mapDispatchToProps，的作用是映射Slice中定义的State和Action到当前页面，在使用时直接this.props.value调用即可。最后通过Redux的connect方法将这些映射和当前页的组件连接起来。 本文的Demo可以在这里查看。 以上就是Redux的入门教程，想深入了解Redux的使用可以参考Redux官方文档，想进一步了解Redux Toolkit可以参考Redux Tookit官方文档。","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://anye3210.github.io/tags/React-Native/"},{"name":"React","slug":"React","permalink":"http://anye3210.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"http://anye3210.github.io/tags/Redux/"},{"name":"Thunk","slug":"Thunk","permalink":"http://anye3210.github.io/tags/Thunk/"}]},{"title":"【React Native】React Navigation 5.x的使用","slug":"【React-Native】React-Navigation的使用","date":"2020-08-03T13:29:05.000Z","updated":"2021-08-22T07:28:29.255Z","comments":true,"path":"2020/08/03/【React-Native】React-Navigation的使用/","link":"","permalink":"http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91React-Navigation%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"前言在App中，底部TabBar导航和顶部的导航栏导航是最常见的页面导航方式，而React Native官方推荐的第三方库是@react-navigation，正好今年React Navigation发布了5.0版本，与前面的版本差别还挺大，不过使用上更方便了。本文主要讲解React Navigation5.0及以上版本的使用。 安装安装核心包 1234# NPMnpm install @react-navigation/native# Yarnyarn add @react-navigation/native","text":"前言在App中，底部TabBar导航和顶部的导航栏导航是最常见的页面导航方式，而React Native官方推荐的第三方库是@react-navigation，正好今年React Navigation发布了5.0版本，与前面的版本差别还挺大，不过使用上更方便了。本文主要讲解React Navigation5.0及以上版本的使用。 安装安装核心包 1234# NPMnpm install @react-navigation/native# Yarnyarn add @react-navigation/native 安装依赖 12345# NPMnpm install react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view#Yarnyarn add react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view React Native 0.60及以上版本是自动链接库的，不需要手动运行react-native link，但如果你用React Native开发的是iOS，还需要手动安装pods来完成库的链接： 1npx pod-install ios 把下面这行代码放在入口文件的顶部，比如index.js或者App.js 1import &#x27;react-native-gesture-handler&#x27;; 最后需要用NavigationContainer将整个App包裹起来，这个代码一般也是放在入口文件，类似下面这样： 123456789import &#x27;react-native-gesture-handler&#x27;;import * as React from &#x27;react&#x27;;import &#123; NavigationContainer &#125; from &#x27;@react-navigation/native&#x27;;export default function App() &#123; return ( &lt;NavigationContainer&gt;&#123;/* Rest of your app code */&#125;&lt;/NavigationContainer&gt; );&#125; 注意： 如果你同时也使用了Redux框架，需要把Provider放在最外层，将NavigationContainer包裹在次外层，类似下面这样： 123456789export default class App() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;NavigationContainer&gt; &#123;/* Screen configuration */&#125; &lt;/NavigationContainer&gt; &lt;/Provider&gt; );&#125; 使用React Navigation有多种导航方式：Stack Navigation、Tab Navigation和Drawer Navigation。这里主要讲Stack Navigation和Tab Navigation。 顶部导航栏导航首先需要安装相应的库： 1234#NPMnpm install @react-navigation/stack#Yarnyarn add @react-navigation/stack Stack Navigation使用上相对来说比较简单，只需要把需要导航的页面组件封装成Stack.Screen，然后包裹在Stack.Navigator就可以了，最上面的Stack.Screen就是默认页面。 1234567891011121314151617181920import * as React from &#x27;react&#x27;;import &#123; NavigationContainer &#125; from &#x27;@react-navigation/native&#x27;;import &#123; createStackNavigator &#125; from &#x27;@react-navigation/stack&#x27;;const Stack = createStackNavigator();function App() &#123; return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen key=&quot;Home&quot; name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;Stack.Screen key=&quot;detail&quot; name=&quot;Detail&quot; component=&#123;DetailScreen&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );&#125;export default App; 也可以在Stack.Screen中设置导航栏的属性，设置导航栏属性options有两种方式，一种是带route参数的，一种是直接设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 带route参数的options */&lt;Stack.Screen key=&#123;name&#125; name=&#123;name&#125; component=&#123;component&#125; options=&#123;(&#123;route&#125;) =&gt; (&#123; headerTitle: route.name, headerStyle: &#123; backgroundColor: &#x27;#01aaff&#x27;, &#125;, headerTintColor: &#x27;#fff&#x27;, headerTitleStyle: &#123; fontWeight: &#x27;bold&#x27;, &#125;, headerRight: () =&gt; ( &lt;Button onPress=&#123;() =&gt; alert(&#x27;This is a button!&#x27;)&#125; title=&quot;Info&quot; color=&quot;#fff&quot; /&gt; ), headerShown: true &#125;)&#125;/&gt;/* 直接设置options */&lt;Stack.Screen key=&#123;name&#125; name=&#123;name&#125; component=&#123;component&#125; options=&#123;&#123; headerTitle: &#x27;name&#x27;, headerStyle: &#123; backgroundColor: &#x27;#01aaff&#x27;, &#125;, headerTintColor: &#x27;#fff&#x27;, headerTitleStyle: &#123; fontWeight: &#x27;bold&#x27;, &#125;, headerRight: () =&gt; ( &lt;Button onPress=&#123;() =&gt; alert(&#x27;This is a button!&#x27;)&#125; title=&quot;Info&quot; color=&quot;#fff&quot; /&gt; ), headerShown: true &#125;&#125;/&gt; 注意： React框架使用的是虚拟DOM，使用diff算法刷新页面显示，在Stack.Screen中，需要添加key属性，否则会报警告。 在需要跳转到其他页面时只需要以下代码就可以了，后面跟的是参数。 1234567891011121314151617function HomeScreen(&#123; navigation &#125;) &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27; &#125;&#125;&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details&quot; onPress=&#123;() =&gt; &#123; /* 1. Navigate to the Details route with params */ navigation.navigate(&#x27;Details&#x27;, &#123; itemId: 86, otherParam: &#x27;anything you want here&#x27;, &#125;); &#125;&#125; /&gt; &lt;/View&gt; );&#125; 如果是用class方式创建的页面，代码会像下面这样： 12345678910111213141516171819export default class HomeScreen extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27; &#125;&#125;&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details&quot; onPress=&#123;() =&gt; &#123; this.props.navigation.navigate(&#x27;Details&#x27;, &#123; itemId: 86, otherParam: &#x27;anything you want here&#x27;, &#125;); &#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 注意： 导航跳转可以使用navigation.navigate或者navigation.push。如果使用navigate，会查找当前堆栈中是否有名字一样的路由，如果没有才创建新的路由并跳转，而push则会直接创建一个新的路由并跳转，也就是说可以重复多次跳转同一个页面。 堆栈导航的返回方式如下： 1234// 返回到上一页面navigation.goBack()// 返回到堆栈里第一个页面navigation.popToPop() 底部导航栏导航除了顶部导航栏，最常用的就是底部导航栏了，首先也需要安装相应的库： 1234# NPMnpm install @react-navigation/bottom-tabs# Yarnyarn add @react-navigation/bottom-tabs 底部导航栏的使用方法类似，需要将这些页面组件包装成Tab.Screen，导航则由框架内部完成，不需要手动控制： 12345678910111213141516import * as React from &#x27;react&#x27;;import &#123; NavigationContainer &#125; from &#x27;@react-navigation/native&#x27;;import &#123; createBottomTabNavigator &#125; from &#x27;@react-navigation/bottom-tabs&#x27;;const Tab = createBottomTabNavigator();export default function App() &#123; return ( &lt;NavigationContainer&gt; &lt;Tab.Navigator&gt; &lt;Tab.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt; &lt;Tab.Screen name=&quot;Settings&quot; component=&#123;SettingsScreen&#125; /&gt; &lt;/Tab.Navigator&gt; &lt;/NavigationContainer&gt; );&#125; 底部导航栏属性可以按如下方式设置： 1234567891011121314151617181920212223&lt;Tab.Navigator screenOptions=&#123;(&#123; route &#125;) =&gt; (&#123; tabBarIcon: (&#123; focused, color, size &#125;) =&gt; &#123; let iconName; if (route.name === &#x27;Home&#x27;) &#123; iconName = focused ? &#x27;ios-information-circle&#x27; : &#x27;ios-information-circle-outline&#x27;; &#125; else if (route.name === &#x27;Settings&#x27;) &#123; iconName = focused ? &#x27;ios-list-box&#x27; : &#x27;ios-list&#x27;; &#125; return &lt;Ionicons name=&#123;iconName&#125; size=&#123;size&#125; color=&#123;color&#125; /&gt;; &#125;, &#125;)&#125; tabBarOptions=&#123;&#123; activeTintColor: &#x27;tomato&#x27;, inactiveTintColor: &#x27;gray&#x27;, &#125;&#125; &gt; &lt;Tab.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt; &lt;Tab.Screen name=&quot;Settings&quot; component=&#123;SettingsScreen&#125; /&gt; &lt;/Tab.Navigator&gt; 顶部堆栈导航栏与底部导航栏嵌套Stack Navigation和Tab Navigation可以相互多层嵌套，比如登录页跳转到带底部导航栏的主页面，需要把登录相关面和Tab.navigator一同放到同一个堆栈中，但官方不推荐这种方式，嵌套层次太多会导致维护起来特别麻烦。官方推荐使用一个变量控制当前显示的页面，把不相关的模块隔离在不同的堆栈中，类似下面这样： 12345678910111213141516171819202122const commonScreens = &#123; Help: HelpScreen,&#125;;const authScreens = &#123; SignIn: SignInScreen, SignUp: SignUpScreen,&#125;;const userScreens = &#123; Home: HomeScreen, Profile: ProfileScreen,&#125;;&lt;Stack.Navigator&gt; &#123;Object.entries(&#123; ...commonScreens, ...(isLoggedIn ? userScreens : authScreens), &#125;).map(([name, component]) =&gt; ( &lt;Stack.Screen name=&#123;name&#125; component=&#123;component&#125; /&gt; ))&#125;&lt;/Stack.Navigator&gt;; 像isLoggedIn这样的全局变量动态刷新页面使用Redux架构实现起来会简单一些，具体实现可以参考这篇教程。","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://anye3210.github.io/tags/React-Native/"},{"name":"React","slug":"React","permalink":"http://anye3210.github.io/tags/React/"},{"name":"Navigation","slug":"Navigation","permalink":"http://anye3210.github.io/tags/Navigation/"}]},{"title":"【React Native】AES+Base64加密","slug":"【React-Native】AES加密","date":"2020-08-03T12:31:27.000Z","updated":"2021-08-22T07:29:53.149Z","comments":true,"path":"2020/08/03/【React-Native】AES加密/","link":"","permalink":"http://anye3210.github.io/2020/08/03/%E3%80%90React-Native%E3%80%91AES%E5%8A%A0%E5%AF%86/","excerpt":"前言在移动端App开发中，AES加密非常常用，本文主要讲解如何在React Native中封装自己的AES加密工具类及会遇到的坑。这里的AES加密是基于前端常用的加密库**crypto-js**。 安装crypto-js使用NPM或者Yarn安装crypto-js 1234# NPMnpm install crypto-js# Yarnyarn add crypto-js 注意：使用crypto-js4.0.0及以上的版本会报找不到Crypto.js的错，这可能是新版本的Bug，需要在package.json中找到crypto-js并把版本号指定为^3.3.0(与3.3.0版本兼容，相当于3.X.X, 即&gt;=3.3.0 &lt; 4.0.0,不改变大版本号)，然后重新执行npm install：","text":"前言在移动端App开发中，AES加密非常常用，本文主要讲解如何在React Native中封装自己的AES加密工具类及会遇到的坑。这里的AES加密是基于前端常用的加密库**crypto-js**。 安装crypto-js使用NPM或者Yarn安装crypto-js 1234# NPMnpm install crypto-js# Yarnyarn add crypto-js 注意：使用crypto-js4.0.0及以上的版本会报找不到Crypto.js的错，这可能是新版本的Bug，需要在package.json中找到crypto-js并把版本号指定为^3.3.0(与3.3.0版本兼容，相当于3.X.X, 即&gt;=3.3.0 &lt; 4.0.0,不改变大版本号)，然后重新执行npm install： 1&quot;crypto-js&quot;: &quot;^3.3.0&quot;, // 创建加密工具类新建AESTool.js文件，添加如下代码： 12345678910111213141516171819202122232425262728import CryptoJS from &#x27;crypto-js&#x27;const key = CryptoJS.enc.Utf8.parse(&#x27;abcdef0123456789&#x27;);const iv = CryptoJS.enc.Utf8.parse(&quot;0123456789abcdef&quot;);export const AESTool = &#123; encrypt: (message) =&gt; &#123; let sendData = CryptoJS.enc.Utf8.parse(message); let encrypted =CryptoJS.AES.encrypt(sendData,key,&#123; iv: iv, mode:CryptoJS.mode.CBC, padding:CryptoJS.pad.Pkcs7 &#125;); return encrypted.toString(); //Base64字符串 &#125;, decrypt: (message) =&gt; &#123; let decrypt = CryptoJS.AES.decrypt(message, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 &#125;); return decrypt.toString(CryptoJS.enc.Utf8); &#125;&#125; 这里使用的是CBC加密模式，使用了Pkcs7补码方式。需要注意的是加密方法里传的明文、偏移量、密钥等参数都需要使用CryptoJS.enc.Utf8.parse()方法解析之后使用。 注意：这里CryptoJS加密后的字符串就是Base64编码的，不需要重复进行Base64编码。解密的时候也直接传Base64字符串即可。","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://anye3210.github.io/tags/React-Native/"},{"name":"AES","slug":"AES","permalink":"http://anye3210.github.io/tags/AES/"},{"name":"React","slug":"React","permalink":"http://anye3210.github.io/tags/React/"}]},{"title":"使用Jenkins+fir/蒲公英持续集成iOS项目(优化版)","slug":"使用Jenkins+蒲公英:fir自动化集成iOS项目-优化版","date":"2020-01-19T15:47:32.000Z","updated":"2021-08-22T07:31:16.226Z","comments":true,"path":"2020/01/19/使用Jenkins+蒲公英:fir自动化集成iOS项目-优化版/","link":"","permalink":"http://anye3210.github.io/2020/01/19/%E4%BD%BF%E7%94%A8Jenkins+%E8%92%B2%E5%85%AC%E8%8B%B1:fir%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9B%86%E6%88%90iOS%E9%A1%B9%E7%9B%AE-%E4%BC%98%E5%8C%96%E7%89%88/","excerpt":"前言在持续集成领域，Jenkins绝对是一个神兵利器，它的插件库非常丰富，我们可以使用它代替执行很多工作中常见的繁琐重复的工作，减少我们在开发之外的不必要的时间花费，从而提高我们的开发效率。在iOS开发中，最常见的就是自动化打包。 我在最初开始接触使用Jenkins的过程中，参考了大量的Jenkins的安装使用教程，发现各有优势，但其中也有很多坑和不合理的地方。通过自己大量的使用、研究和优化，总结了这篇优化版的自动化打包教程。 在安装和使用Jenkins的过程中，很多步骤都会有几种方式实现，本文只详细讲解个人认为比较好的方式。","text":"前言在持续集成领域，Jenkins绝对是一个神兵利器，它的插件库非常丰富，我们可以使用它代替执行很多工作中常见的繁琐重复的工作，减少我们在开发之外的不必要的时间花费，从而提高我们的开发效率。在iOS开发中，最常见的就是自动化打包。 我在最初开始接触使用Jenkins的过程中，参考了大量的Jenkins的安装使用教程，发现各有优势，但其中也有很多坑和不合理的地方。通过自己大量的使用、研究和优化，总结了这篇优化版的自动化打包教程。 在安装和使用Jenkins的过程中，很多步骤都会有几种方式实现，本文只详细讲解个人认为比较好的方式。 安装JenkinsJenkins的安装分为两类，一种是安装包安装，一种是使用Homebrew安装，推荐使用Homebrew进行安装。 安装前请确保系统已经安装了Homebrew，否则请前往Homebrew官网按照提示自行安装。 打开终端安装Jenkins 1brew install jenkins 下面安装完成后日常使用经常会用到的命令 123brew services start jenkins // 启动Jenkinsbrew services restart jenkins // 重启Jenkinsbrew services stop jenkins // 停用Jenkins 上述命令执行后Jenkins都是在后台运行，如果不想使用后台运行Jenkins服务，可以直接在终端输入jenkins以日志的方式运行。 Jenkins默认会使用8080端口，可以使用以下命令自己更换（不建议） 1default write /Library/Preferences/org.jenkins-ci httpPort xxxx // xxxx为更换后的端口号 配置Jenkins初始化配置用浏览器打开http://localhost:8080，首次进入需要输入密码以解锁Jenkins 使用cat命令按页面上的提示的路径在终端输入以下命令在终端打印密码 1cat /Users/用户名/.jenkins/secrets/initialAdminPassword 输入密码登录成功后点击Install suggested plugins按钮安装插件，等待安装完成。 部分插件可能会安装失败，可以选择现点Retry重新安装，也可以选择继续，后面再来安装这些安装失败的插件。 点继续之后会进入到创建用户页面，建议在这里创建用户。如果不创建每次进入都要输入初始密码，比较麻烦。 点击保存会显示以下界面，点击Start using jenkins按钮进入到管理页面。 配置iOS自动化打包插件安装自动化打包需要安装以下插件 12345Keychains and Provisioning Profiles ManagementCocoaPods Jenkins IntegrationBuild TimeoutSSH Agent PluginWorkSpace Cleanup Plugin 选择Manage Jenkins-&gt;Manage Plugins-&gt;已安装，在右上角过滤里面搜索，查看插件是否已安装，如果没有需要在可选插件里搜索并安装 如果想打包完成后自动发送邮件，需要安装Email Extension Plugin插件。 如果想将Jenkins的显示语言更改为中文，需要安装Localization: Chinese (Simplified)插件，重启之后生效。 环境变量配置iOS自动化打包需要使用到cocoapods、XCPretty、xcbuild等工具，如果想直接在脚本中使用不带路径的相关命令，就需要先添加全局变量。 打开Manage Jenkins-&gt;Configure System 页面滚动到全局属性一栏，添加以下几个键值对，前面三个为全局语言编码，最后一个为全局路径，它的值可以通过在终端输入$PATH获取到 证书和描述文件配置接下来我们需要上传钥匙串和描述文件，在上传之前需要一些准备工作。 打开电脑的钥匙串访问应用，进入后鼠标悬停在登录按钮上方会自动显示登录钥匙串的路径 打开终端，输入以下命令将钥匙串从上图所示的路径中复制出来存放到桌面并将文件后缀里的-db去掉（Jenkins上传钥匙串时文件必须以.keychain结尾）。这样，钥匙串就准备好了。 1cp /Users/用户名/Library/Keychains/login.keychain-db ~/Desktop/login.keychain 描述文件如果有就用现成的，如果没有，就上开发者网站生成和下载一个，具体流程如果不了解可以自行上网搜索，这里就赘述了。（注意：描述文件上传前先将iOS工程的证书管理设置为手动模式，将描述文件导入进入看一下是否能用，避免后面发现不能用来回折腾） 接下来就是正式上传。 打开Manage Jenkins-&gt;Keychains and Provisioning Profiles Management 点击选择文件，选择刚准备好的login.keychain，然后点Upload 钥匙串上传完成成显示如下 点击下方的Add Code Signing Identity将项目相关的证书名称添加进去，这个名称点击该证书在钥匙串应用上方就会有显示，复制粘贴即可 添加完成后效果如下 接下来用同样的方法上传证书的描述文件，并在Provisioning Profiles Directory Path一栏填写描述文件地址/Users/用户名/Library/MobileDevice/Provisioning Profiles，完成后如下图所示 点击保存，证书和描述文件就完成了。 新建和配置自动化打包任务在Jenkins首页点击新建Item 为任务起一个名称，选择下面的Freestyle project，然后点确定 这时候会自动跳转到项目配置界面，在这个界面需要配置三个地方： 源码管理 构建环境里的Mobile Provisioning Profiles 构建里的运行脚本 首先是源码管理部分，这里有两种方式进行管理，一种是Git，一种是Subversion，这里主要讲解Git方式。 在Repository URL栏填入项目源码的仓库地址，在下方Credentials栏的凭据选择默认是空的，选择添加，添加完凭据就可以选择了。指定分支栏填入相应分支，默认为master分支。 构建环境部分配置比较简单，勾选Mobile Provisioning Profiles选项并选择之前上传的描述文件即可。 接下来就是最重要的构建脚本了。 在添加脚本以前，需要先把打包需要的ExportOptions.plist准备好，这个文件需要自己手动打包一次，在导出IPA文件后在与.ipa同在的文件夹中可以找到。可以把它放在源码中，也可以放在电脑的某个位置，这个路径在下面的打包脚本中需要用到。（注意：如果后期修改了打包方式、证书或者描述文件，一定要同步修改该plist文件对应的值，否则打包会报错） 准备好.plist文件之后就可以添加脚本了。 在构建中的增加构建步骤里选择Execute shell添加构建脚本。 在脚本输入框添加以下内容，这个脚本是打包脚本，这个版本已经优化并适配最新版本的XCode 11，使用时需要将里面的xxx替换为你自己项目的名称或用户名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123cd $WORKSPACE# 计时SECONDS=0# 是否编译工作空间 (例:若是用Cocopods管理的.xcworkspace项目,赋值true;用Xcode默认创建的.xcodeproj,赋值false)is_workspace=&quot;true&quot;# 指定项目的scheme名称# (注意: 因为shell定义变量时,=号两边不能留空格,若scheme_name与info_plist_name有空格,脚本运行会失败)scheme_name=&quot;xxx&quot;# 工程中Target对应的配置plist文件名称, Xcode默认的配置文件为Info.plistinfo_plist_name=&quot;Info&quot;# 指定要打包编译的方式 : Release,Debug...build_configuration=&quot;Release&quot;# ===============================自动打包部分(如果Info.plist文件位置有变动需要修改&quot;info_plist_path&quot;)============================= ## 导出ipa所需要的plist文件路径，这个路径为之前存放ExportOptions.plist的路径，如果放在源码工程文件的根目录，直接填文件名即可。ExportOptionsPlistPath=&quot;/Users/xxx/ExportOptions.plist&quot;# 获取项目名称project_name=`find . -name *.xcodeproj | awk -F &quot;[/.]&quot; &#x27;&#123;print $(NF-1)&#125;&#x27;`# 获取Info.plist路径，拿到版本号, 编译版本号, BundleIDinfo_plist_path=&quot;$project_name/$info_plist_name.plist&quot;bundle_version=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $info_plist_path`bundle_build_version=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $info_plist_path`bundle_identifier=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleIdentifier&quot; $info_plist_path`#时间戳formattedDate=$(date &quot;+%Y-%m-%d#%H:%M:%S&quot;)# 指定输出ipa名称 : scheme_name + bundle_versionipa_name=&quot;$scheme_name$formattedDate&quot;# 删除旧.xcarchive文件rm -rf ~/Documents/IPA/$scheme_name-IPA/$scheme_name.xcarchive# 指定输出ipa路径export_path=~/Documents/IPA/$scheme_name/$ipa_name# 指定输出归档文件地址export_archive_path=&quot;$export_path/$ipa_name.xcarchive&quot;# 指定输出ipa地址export_ipa_path=&quot;$export_path&quot;# 四种打包方式: AdHoc、AppStore、Enterprise和Developmentmethod=&quot;AdHoc&quot;echo &quot;\\033[************************* 开始构建项目 *************************]\\033&quot;# 指定输出文件目录不存在则创建if [ -d &quot;$export_path&quot; ] ; thenecho $export_pathelsemkdir -pv $export_pathfi# 判断编译的项目类型是workspace还是projectif $is_workspace ; then# 安装第三方库pod install --verbose --no-repo-update# 编译前清理工程xcodebuild clean -workspace $&#123;project_name&#125;.xcworkspace \\ -scheme $&#123;scheme_name&#125; \\ -configuration $&#123;build_configuration&#125;xcodebuild archive -workspace $&#123;project_name&#125;.xcworkspace \\ -scheme $&#123;scheme_name&#125; \\ -configuration $&#123;build_configuration&#125; \\ -archivePath $&#123;export_archive_path&#125; \\ | xcprettyelse# 编译前清理工程xcodebuild clean -project $&#123;project_name&#125;.xcodeproj \\ -scheme $&#123;scheme_name&#125; \\ -configuration $&#123;build_configuration&#125;xcodebuild archive -project $&#123;project_name&#125;.xcodeproj \\ -scheme $&#123;scheme_name&#125; \\ -configuration $&#123;build_configuration&#125; \\ -archivePath $&#123;export_archive_path&#125; \\ | xcprettyfi# 检查是否构建成功# xcarchive 实际是一个文件夹不是一个文件所以使用 -d 判断if [ -d &quot;$export_archive_path&quot; ] ; thenecho &quot;\\033[项目构建成功] \\033&quot;elseecho &quot;\\033[项目构建失败] \\033&quot;exit 1fiecho &quot;\\033[************************* 开始导出ipa文件 *************************]\\033&quot;xcodebuild -exportArchive \\ -archivePath $&#123;export_archive_path&#125; \\ -exportPath $&#123;export_ipa_path&#125; \\ -exportOptionsPlist $&#123;ExportOptionsPlistPath&#125; \\ -allowProvisioningUpdates \\ -allowProvisioningDeviceRegistration \\ CODE_SIGN_IDENTITY=&quot;iPhone Distribution: xxx (xxx)&quot;# 修改ipa文件名称mv $export_ipa_path/$scheme_name.ipa $export_ipa_path/$ipa_name.ipa# 检查文件是否存在if [ -f &quot;$export_ipa_path/$ipa_name.ipa&quot; ] ; thenecho &quot;\\033[导出 $&#123;ipa_name&#125;.ipa 包成功]\\033&quot;open $export_pathelseecho &quot;\\033[导出 $&#123;ipa_name&#125;.ipa 包失败]\\033&quot;exit 1fi# 输出打包总用时echo &quot;\\033[打包总用时: $&#123;SECONDS&#125;s]\\033&quot; 接下来是上传脚本，将上传脚本添加到上面打包脚本末尾就可以在打包完成后自动上传。 上传到蒲公英的脚本如下，请自行替换蒲公英API Key和User Key： 123456789101112131415161718# ============================上传到蒲公英部分(请自行替换蒲公英API Key和User Key)================================ #echo &quot;\\033[************************* 上传到蒲公英 *************************]\\033&quot;# open $export_path# 蒲公英上的User KeyuKey=&quot;xxx&quot; # 蒲公英上的API KeyapiKey=&quot;xxx&quot; # 要上传的ipa文件路径IPA_PATH=&quot;$export_ipa_path/$ipa_name.ipa&quot; # 执行上传至蒲公英的命令echo &quot;[************************* uploading *************************]&quot;curl -F &quot;file=@$&#123;IPA_PATH&#125;&quot; -F &quot;uKey=$&#123;uKey&#125;&quot; -F &quot;_api_key=$&#123;apiKey&#125;&quot; http://www.pgyer.com/apiv1/app/upload 上传到fir的脚本如下，请自行替换fir的API Token： 1234567891011121314# ============================上传到fir.im部分(请自行替换fir的API Token)================================ # # 执行上传至fir.im的命令echo &quot;[************************* uploading *************************]&quot;# fir.im上的API TokenAPI_TOKEN=&quot;xxx&quot;# 要上传的ipa文件路径IPA_PATH=&quot;$export_ipa_path/$ipa_name.ipa&quot;#上传到firfir publish $IPA_PATH -T $API_TOKEN 点击保存并退出，在项目面板中点击Build Now就会执行自动打包，点击下面的Build编号，进入构建面板后点击控制台输入可以看到实时的日志，如果打包失败也可以看到失败原因。打包成功会显示如下：","categories":[],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://anye3210.github.io/tags/Jenkins/"},{"name":"fir","slug":"fir","permalink":"http://anye3210.github.io/tags/fir/"},{"name":"蒲公英","slug":"蒲公英","permalink":"http://anye3210.github.io/tags/%E8%92%B2%E5%85%AC%E8%8B%B1/"},{"name":"profile","slug":"profile","permalink":"http://anye3210.github.io/tags/profile/"},{"name":"ad-hoc","slug":"ad-hoc","permalink":"http://anye3210.github.io/tags/ad-hoc/"},{"name":"iOS","slug":"iOS","permalink":"http://anye3210.github.io/tags/iOS/"},{"name":"持续集成","slug":"持续集成","permalink":"http://anye3210.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"自动化打包","slug":"自动化打包","permalink":"http://anye3210.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"}]},{"title":"使用SonarQube静态检查OC代码质量","slug":"使用SonarQube静态检查OC代码质量","date":"2020-01-13T15:01:17.000Z","updated":"2021-08-22T07:32:59.909Z","comments":true,"path":"2020/01/13/使用SonarQube静态检查OC代码质量/","link":"","permalink":"http://anye3210.github.io/2020/01/13/%E4%BD%BF%E7%94%A8SonarQube%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5OC%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/","excerpt":"前言SonarQube是一个开源的代码质量管理系统，它支持包括ObjectiveC、Java、C/C++、C#、PHP在内的超过25种编程语言。它能够提供包括重复代码、编码标准、单元测试、代码覆盖率、代码复杂度、潜在Bug、注释的报告。它还可以与持续集成工具配合使用实现完全自动化的分析。 之前在网上搜索学习SonarQube在Mac上的集成和使用教程，发现教程都比较老，使用的都是较老版本的SonarQube，在集成最新的8.1版本时踩了不少坑。本文就是对在Mac系统上安装和使用新版SonarQube的总结。后续会继续更新使用SonarQube静态分析Swift代码及结合Jenkins进行自动化分析。 注意：SonarQube需要Java 11及以上的运行环境，在终端输入java --version即可查看系统的Java版本，如果不满足，请先自行下载和安装。","text":"前言SonarQube是一个开源的代码质量管理系统，它支持包括ObjectiveC、Java、C/C++、C#、PHP在内的超过25种编程语言。它能够提供包括重复代码、编码标准、单元测试、代码覆盖率、代码复杂度、潜在Bug、注释的报告。它还可以与持续集成工具配合使用实现完全自动化的分析。 之前在网上搜索学习SonarQube在Mac上的集成和使用教程，发现教程都比较老，使用的都是较老版本的SonarQube，在集成最新的8.1版本时踩了不少坑。本文就是对在Mac系统上安装和使用新版SonarQube的总结。后续会继续更新使用SonarQube静态分析Swift代码及结合Jenkins进行自动化分析。 注意：SonarQube需要Java 11及以上的运行环境，在终端输入java --version即可查看系统的Java版本，如果不满足，请先自行下载和安装。 SonarQube平台架构SonarQube平台主要由四大要件构成： 数据库：存放配置数据和检测数据（7.9及以后的版本不再支持MySQL，本文使用的是PostgreSQL） Web服务：在本地网页上查看配置数据和代码质量检测结果 分析器：对项目代码进行分析（OCLint） 插件：支持各种语言的插件 安装配置PostgreSQL数据库SonarQube运行和储存数据需要数据库，而网上大多数教程使用的MySQL数据库已经不被7.9以后版本的SonarQube支持了，所以我选择了同样开源的关系数据库PostgreSQL。这个数据库和MySQL语法略有不同，但使用上基本大同小异。 我们先来安装和配置PostgreSQL数据库。 安装数据库安装PostgreSQL数据库有两种方式，一种是Homebrew，一种是直接上官网下载安装程序安装，后一种有可视化界面使用上比较简单。 使用Homebrew安装安装Homebrew（电脑上已经安装了的可以跳过这步）。 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装数据库 1brew install postgresql 软件方式安装进入官网按照提示进行下载和安装，安装完之后直接双击运行即可。 使用软件方式安装会自动创建两个用户，一个是postgres，一个是与电脑当前登录用户同名的用户，并且分别为两个用户创建了默认的数据库。后面我们添加用户和数据库时可以登录postgres这个用户进行创建。（注：PostgreSQL数据库可以使用pgAdmin在本地网页图形化界面上进行管理，具体安装和使用请自行搜索） 软件方式安装需要配置一下环境路径，这样我们就可以在命令行直接使用psql命令。 在 ~/.bash_profile中添加以下内容（具体路径可以查看从图形界面进入psql命令行时显示的路径） 1export PATH=$PATH:/Applications/Postgres.app/Contents/Versions/12/bin 保存之后退出，在终端输入source ~/.bash_profile使设置生效。然后就可以直接在终端中键入psql，显示如下则表示设置成功。 12psql (12.1)Type &quot;help&quot; for help. 默认情况下本地用户登录都是受信任的，不需要输入密码，如果想要使用密码登录，可以修改/Users/本地用户名/Library/Application Support/Postgres/var-12/pg_hba.conf文件，将以下内容里的trust替换为md5即可 12345678910111213# TYPE DATABASE USER ADDRESS METHOD# &quot;local&quot; is for Unix domain socket connections onlylocal all all trust# IPv4 local connections:host all all 127.0.0.1/32 trust# IPv6 local connections:host all all ::1/128 trust# Allow replication connections from localhost, by a user with the# replication privilege.local replication all trusthost replication all 127.0.0.1/32 trusthost replication all ::1/128 trust 替换后 12345678910111213# TYPE DATABASE USER ADDRESS METHOD# &quot;local&quot; is for Unix domain socket connections onlylocal all all md5# IPv4 local connections:host all all 127.0.0.1/32 md5# IPv6 local connections:host all all ::1/128 md5# Allow replication connections from localhost, by a user with the# replication privilege.local replication all md5host replication all 127.0.0.1/32 md5host replication all ::1/128 md5 重启PostgreSQL之后使用psql -U 用户名登录就需要输入密码了。 注：PostgreSQL常用指令如下： 12345678910111213psql -U [user] -d [database] -h [host] -p [post] //登录\\password：设置当前登录用户的密码\\h：查看SQL命令的解释，比如\\h select。\\?：查看psql命令列表。\\l：列出所有数据库。\\c [database_name]：连接其他数据库。\\d：列出当前数据库的所有表格。\\d [table_name]：列出某一张表格的结构。\\du：列出所有用户。\\e：打开文本编辑器。\\conninfo：列出当前数据库和连接的信息。\\password [user]: 修改用户密码\\q：退出 配置数据库首先使用postgres用户登录数据库 1psql postgres 然后创建用户sonar并设置密码，这里的密码你可以填写自己的密码 1CREATE USER sonar WITH PASSWORD &#x27;sonar&#x27;; 创建属于用户sonar的数据库sonar 1CREATE DATABASE sonar OWNER sonar; 给sonar用户加上添加数据库的权限 1ALTER ROLE sonar CREATEDB; 这样，数据库配置就完成了，接下来正式安装SonarQube。 安装和配置SonarQube安装SonarQube主要分为三步： 安装配置SonarQube本地服务器 安装配置sonar-scanner 安装配置xcpretty、OCLint、slather等工具和插件 安装配置本地服务器SonarQube的服务可以运行在本地服务器或者远程服务器上，本文主要讲解本地服务器的配置方式。 首先上SonarQube官网上下载SonarQube源文件并解压。 然后配置conf/sonar.properties文件 设置数据库版本 1sonar.jdbc.url=jdbc:postgresql://localhost/sonar 设置数据库账号密码 12sonar.jdbc.username=sonarsonar.jdbc.password=sonar 进入bin/macosx-universal-64文件夹，给sonar.sh设置权限 1chmod 777 sonar.sh 使用./sonar.sh console来启动服务器，在浏览器输入http://localhost:9000来测试服务器是否启动成功。页面正常显示就表示启动成功。 如果启动失败，可以根据SonarQube项目目录的logs文件夹中的日志查找原因。大部分启动不成功的情况都是数据库原因，这个在web.log文件中有记录。 注：SonarQube常用命令如下： 1234./sonar.sh console #Debug信息./sonar.sh start #启动服务./sonar.sh stop #停止服务./sonar.sh restart #重启服务 安装和配置sonar-scanner直接使用HomeBrew安装sonar-scanner 1brew install sonar-scanner 安装完成后输入sonar-scanner -v或者sonar-scanner --version可以看到如下配置文件地址和版本信息 12345INFO: Scanner configuration file: /usr/local/Cellar/sonar-scanner/4.2.0.1873/libexec/conf/sonar-scanner.propertiesINFO: Project root configuration file: NONEINFO: SonarQube Scanner 4.2.0.1873INFO: Java 11.0.5 Oracle Corporation (64-bit)INFO: Mac OS X 10.15.2 x86_64 根据上面显示的配置文件地址打开配置文件，即/usr/local/Cellar/sonar-runner/2.5/libexec/conf/sonar-runner.properties，修改或添加以下内容 1234sonar.host.url=http://localhost:9000sonar.jdbc.username=sonarsonar.jdbc.password=sonarsonar.jdbc.url=jdbc:postgresql://localhost/sonar 修改完后保存，sonar-scanner这部分就完成了。 安装其他工具和插件首先安装环境工具。 安装xcpretty 12345git clone https://github.com/Backelite/xcpretty.gitcd xcprettygit checkout fix/duration_of_failed_tests_workaround gem build xcpretty.gemspec sudo gem install --both xcpretty-0.2.2.gem 安装oclint 1brew cask install oclint 安装slather 1gem install slather 安装lizard 1sudo pip install lizard 然后是安装静态分析插件，由于官方插件SonarCFamily比较贵，使用开源的就好。 在这里可以看到插件版本和与之对应的SonarQube版本，到Release里面下载相应版本的jar文件即可（也可以下载源文件自行编译，这个比较费时间，不推荐）。将下载好的jar文件放到SonarQube安装目录下的extensions/plugins文件夹中，插件安装就完成了。 使用SonarQube静态扫描代码终端路径切换到待扫描项目的根目录下，输入touch run-sonar.sh命令生成run-sonar.sh，然后输入vi run-sonar.sh编辑文件，在里面添加以下内容（注意把里面的xxx更改为你的项目名称的Scheme名称）： 12345678910111213xcodebuild -workspace xxx.xcworkspace -scheme xxx clean build | tee xcodebuild.log | xcpretty --report json-compilation-databasemv build/reports/compilation_db.json compile_commands.jsonoclint-json-compilation-database -exclude Pods -- -report-type pmd -o oclint.xml -max-priority-1 99999 -max-priority-2 99999 -max-priority-3 99999 -rc LONG_LINE=140 -rc LONG_METHOD=80 -rc NCSS_METHOD=50 -rc SHORT_VARIABLE_NAME=1 -rc CYCLOMATIC_COMPLEXITY=13 -rc MINIMUM_CASES_IN_SWITCH=2 -rc NPATH_COMPLEXITY=1500rm -rf sonar-reports mkdir sonar-reportscat oclint.xml | sed &quot;s#Switch Statements Should Have Default Rule#switch statements should have default#g&quot; | sed &quot;s#missing hash method#must override hash with isEqual#g&quot; | sed &quot;s#prefer early exits and continue#use early exits and continue#g&quot; | sed &quot;s#use boxed expression#replace with boxed expression#g&quot; | sed &quot;s#use container literal#replace with container literal#g&quot; | sed &quot;s#use number literal#replace with number literal#g&quot; | sed &quot;s#use object subscripting#replace with object subscripting#g&quot; | sed &quot;s#missing default in switch statements#switch statements should have default#g&quot; | sed &quot;s#unnecessary default statement in covered switch statement#switch statements don&#x27;t need default when fully covered#g&quot; | sed &quot;s#covered switch statements dont need default#switch statements don&#x27;t need default when fully covered#g&quot; &gt; sonar-reports/oclint.xml /bin/sh sonar-scanner -X 以同样的方式新建sonar-project.properties文件，使用vi命令添加以下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859########################### Required configuration ###########################sonar.projectKey=你的项目Keysonar.projectName=项目名sonar.projectVersion=版本号sonar.language=objc # Project descriptionsonar.projectDescription=Text sonarquebe # Path to source directories sonar.sources=项目源码文件夹名称# Path to test directories (comment if no test)# sonar.tests=testSrcDir # Xcode project configuration (.xcodeproj or .xcworkspace)# -&gt; If you have a project: configure only sonar.objectivec.project# -&gt; If you have a workspace: configure sonar.objectivec.workspace and sonar.objectivec.project# and use the later to specify which project(s) to include in the analysis (comma separated list)sonar.objectivec.project=项目名.xcodeproj # sonar.objectivec.workspace=myApplication.xcworkspace# Scheme to build your applicationsonar.objectivec.appScheme=需要编译的Scheme名# Scheme to build and run your tests (comment following line of you don&#x27;t have any tests)# sonar.objectivec.testScheme=myApplicationTests ########################### Optional configuration ############################ Encoding of the source codesonar.sourceEncoding=UTF-8# JUnit report generated by run-sonar.sh is stored in sonar-reports/TEST-report.xml# Change it only if you generate the file on your own# The XML files have to be prefixed by TEST- otherwise they are not processed # sonar.junit.reportsPath=sonar-reports/# Cobertura report generated by run-sonar.sh is stored in sonar-reports/coverage.xml# Change it only if you generate the file on your ownsonar.objectivec.coverage.reportPattern=sonar-reports/coverage*.xml# OCLint report generated by run-sonar.sh is stored in sonar-reports/oclint.xml# Change it only if you generate the file on your ownsonar.objectivec.oclint.report=oclint.xmlsonar.objectivec.oclint.reportPath=sonar-reports/oclint.xml# Paths to exclude from coverage report (tests, 3rd party libraries etc.)# sonar.objectivec.excludedPathsFromCoverage=pattern1,pattern2sonar.objectivec.excludedPathsFromCoverage=.*Tests.*# Project SCM settings# sonar.scm.enabled=true# sonar.scm.url=scm:git:https://... 输入wq命令保存并退出。 为避免编译的时候出现oclint: error: one compiler command contains multiple jobs:的报错，需要使用XCode打开工程文件并且在Build Settings中将COMPILER_INDEX_STORE_ENABLE设置为NO。 进入到SonarQube项目文件夹，进入到bin/macosx-universal-64，使用命令./sonar.sh restart来重启服务器。 上面的步骤全部完成后，就可以在工程目录下使用./run-sonar.sh或sh run-sonar.sh命令来执行脚本。 命令执行行完毕并且没有报错，就可以在浏览器中输入http://localhost:9000查看检测结果。","categories":[],"tags":[{"name":"SonarQube","slug":"SonarQube","permalink":"http://anye3210.github.io/tags/SonarQube/"},{"name":"代码质量","slug":"代码质量","permalink":"http://anye3210.github.io/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"name":"静态检查","slug":"静态检查","permalink":"http://anye3210.github.io/tags/%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/"},{"name":"ObjectiveC","slug":"ObjectiveC","permalink":"http://anye3210.github.io/tags/ObjectiveC/"}]},{"title":"【iOS】Eureka的基本使用和自定义Cell","slug":"Eureka的基本使用和自定义Cell","date":"2019-06-04T12:23:24.000Z","updated":"2021-08-22T07:50:24.610Z","comments":true,"path":"2019/06/04/Eureka的基本使用和自定义Cell/","link":"","permalink":"http://anye3210.github.io/2019/06/04/Eureka%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89Cell/","excerpt":"前言Eureka是一个纯Swift库，它能帮你快速优雅地创建一个TableView。这个库本身也提供了大量内置的不同功能的Cell，使用上也很简单。如果内置的Cell样式或功能不能满足需要，你也可以自定义Cell。 使用Eureka设置TableView的代码大概是下面这样： 123456789form +++ Section() &lt;&lt;&lt; LabelRow() &#123; $0.title = &quot;LabelRow&quot; $0.value = &quot;Default Value&quot; &#125;.cellSetup(&#123; (cell, row) in cell.accessoryType = .disclosureIndicator &#125;).onCellSelection(&#123; (cell, row) in print(&quot;cell selection&quot;) &#125;) 本文主要介绍Eureka的基本使用和自定义Cell的步骤。你可以在这里查看本文的Demo。","text":"前言Eureka是一个纯Swift库，它能帮你快速优雅地创建一个TableView。这个库本身也提供了大量内置的不同功能的Cell，使用上也很简单。如果内置的Cell样式或功能不能满足需要，你也可以自定义Cell。 使用Eureka设置TableView的代码大概是下面这样： 123456789form +++ Section() &lt;&lt;&lt; LabelRow() &#123; $0.title = &quot;LabelRow&quot; $0.value = &quot;Default Value&quot; &#125;.cellSetup(&#123; (cell, row) in cell.accessoryType = .disclosureIndicator &#125;).onCellSelection(&#123; (cell, row) in print(&quot;cell selection&quot;) &#125;) 本文主要介绍Eureka的基本使用和自定义Cell的步骤。你可以在这里查看本文的Demo。 基本使用Eureka的基本使用主要是三步 1. 新建ViewController并将ViewController设置为FormViewController的子类 2. 添加Section 3. 添加Row 新建ViewController 显示tableView首先得有一个控制器，这里我们新建一个控制器并将它设置成FormViewController的子类，如下所示: 12345class ViewController: FormViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#125;&#125; FormViewController本身是UIViewController的子类，而且Eureka框架已经在其中添加和设置好了tableView，所以我们开发时不用操心布局，仅仅关注交互逻辑就可以了。 添加SectionFormViewController里tableView的style属性值为.grouped，这里我们添加多少个Section就会自动生成多少个组，添加语法如下： 1form +++ Section() 有的人看到这里或许有点奇怪，+++是个什么语法，好像没见过啊。其实这是Eureka使用了Swift自定义运算符的特性，定义+++这个中缀运算符，它在源文件里是这么定义的: 1infix operator +++ : FormPrecedence 上面这个添加Section的语法定义是这样的： 12345@discardableResultpublic func +++ (left: Form, right: Section) -&gt; Form &#123; left.append(right) return left&#125; 这里Form遵从了RangeReplaceableCollection这个协议，重写了append这个方法，具体实现有兴趣的可以去看源码。 添加RowRow的创建和设置是所有步骤的核心，所有的交互逻辑都是在这里完成的。Eureka内置了数十种常用的Row，这里我们添加最常用的三种Row： 12345678910111213141516171819202122232425form +++ Section() &lt;&lt;&lt; LabelRow() &#123; $0.title = &quot;LabelRow&quot; $0.value = &quot;Default Value&quot; &#125;.cellSetup(&#123; (cell, row) in cell.accessoryType = .disclosureIndicator &#125;).onCellSelection(&#123; (cell, row) in print(&quot;cell selection&quot;) &#125;) &lt;&lt;&lt; TextRow(tag: &quot;TextRow&quot;) .cellSetup(&#123; (cell, row) in row.tag = &quot;TextRow&quot; row.title = &quot;TextRow&quot; row.placeholder = &quot;Input your message&quot; &#125;) .cellUpdate(&#123; (cell, row) in print(&quot;cell update&quot;) &#125;) &lt;&lt;&lt; SwitchRow() &#123; $0.tag = &quot;SwitchValue&quot; $0.title = &quot;SwitchRow&quot; $0.value = true &#125;.onChange(&#123; (row) in print(&quot;value changed: \\(row.value ?? false)&quot;) &#125;) &lt;&lt;&lt;同样是Eureka自定义的中缀运算符，作用是将Row添加到对应的Section中。在上面的代码中，我是在Row的生成方法的闭包中为title和value赋值，这个操作同样也可以放在cellSetup方法中（这个操作只会在Row创建时调用），效果是一样的。需要动态刷新的值需要在cellUpdate方法中设置。Eureka同时也提供了onCellSelection和onChange这样的响应方法，在里面定义其实响应逻辑即可。 至此，Eureka的基本使用就全部完成了。如果Eureka框架自带的Row已经能完全满足你的需求，就不需要往下看了。但如果你不满足于内置Row，那么我们继续看看如何自定义Cell和Row 自定义Cell这里我们来定义一个模拟软件更新的Cell，效果图如下： 定义结构体首先，我们需要一个结构体Software方便为Cell赋值： 1234567891011121314enum UpdateState: Int &#123; case toUpdate = 0 case updating case alreadyNewest&#125;struct Software: Equatable &#123; var name: String var updateState: UpdateState&#125;func == (lhs: Software, rhs: Software) -&gt; Bool &#123; return lhs.name == rhs.name&#125; 这里有一点需要注意的是，定义的类或者结构体必须遵从Equatable协议，否则在自定义Cell里使用时会报错。 定义Cell定义好了结构体，接下来就是实现Cell部分。 自定义Eureka的Cell和自定义普通UITableView的Cell一样，首先要选择使用纯代码创建还是xib创建。这里我们使用xib的方式。新建自定义Cell，如下图： 自定义布局，Cell连线，UpdateCell的代码如下： 12345678910111213141516171819202122232425262728final class UpdateCell: Cell&lt;Software&gt;, CellType &#123; @IBOutlet weak var titleLabel: UILabel! @IBOutlet weak var updateButton: UIButton! @IBOutlet weak var aniContainerView: UIView! @IBOutlet weak var noNeedUpdateLabel: UILabel! private var shapeLayer = CAShapeLayer() override func setup() &#123; selectionStyle = .none height = &#123; return 44 &#125; //这里省略布局代码 &#125; override func update() &#123; guard let software = row.value else &#123; return &#125; titleLabel.text = software.name updateUI(software.updateState) &#125; &#125; 在创建UpdateCell类的时候，有几点需要注意： 指明为Cell赋值时使用的类 遵从CellType协议 指定Cell的高度 在上面的代码的，Setup方法只会在Cell创建时调用一次，可以在这里写布局代码，而Update方法会在每次刷新的时候调用，可以在这里给Cell的subViews赋值。 定义Row接下来还需要自定义Row，从属于上面我们刚刚定义的Cell，并在里面加载xib： 12345678final class UpdateRow: Row&lt;UpdateCell&gt;, RowType &#123; required init(tag: String?) &#123; super.init(tag: tag) cellProvider = CellProvider&lt;UpdateCell&gt;(nibName: &quot;UpdateCell&quot;) &#125; &#125; 添加自定义Cell到Section中自定义Cell创建完成后，就可以像使用框架中自带的Row一样来使用我们的自定义Row： 123&lt;&lt;&lt; UpdateRow() &#123; $0.value = Software(name: &quot;My Software&quot;, updateState: .toUpdate) &#125; 总结其实Eureka的使用比较简单，熟练操作后会是快速构建UITableView的利器。本文的Demo可以在这里查看。","categories":[],"tags":[{"name":"Eureka","slug":"Eureka","permalink":"http://anye3210.github.io/tags/Eureka/"},{"name":"Custom Cell","slug":"Custom-Cell","permalink":"http://anye3210.github.io/tags/Custom-Cell/"},{"name":"TableView","slug":"TableView","permalink":"http://anye3210.github.io/tags/TableView/"},{"name":"自动生成","slug":"自动生成","permalink":"http://anye3210.github.io/tags/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/"}]},{"title":"【iOS】封装自己的自定义转场组件","slug":"封装自己的自定义转场组件","date":"2019-05-30T13:18:35.000Z","updated":"2021-08-22T07:35:46.116Z","comments":true,"path":"2019/05/30/封装自己的自定义转场组件/","link":"","permalink":"http://anye3210.github.io/2019/05/30/%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E7%BB%84%E4%BB%B6/","excerpt":"自定义转场这个技术相信大家都用过或者听说过，不过如果你经常使用自定义转场或者自定义转场动画做得比较复杂或许会发现AnimatedTransitioning与目标控制器的交互并没有那么友好。本文旨在提供一个新思路，减少AnimatedTransitioning与目标控制器的耦合，引入封装好的类文件后，只需少量代码，就可以实现一个基础的转场动画。 首先，我们来看一下实现一个普通的转场动画的流程。","text":"自定义转场这个技术相信大家都用过或者听说过，不过如果你经常使用自定义转场或者自定义转场动画做得比较复杂或许会发现AnimatedTransitioning与目标控制器的交互并没有那么友好。本文旨在提供一个新思路，减少AnimatedTransitioning与目标控制器的耦合，引入封装好的类文件后，只需少量代码，就可以实现一个基础的转场动画。 首先，我们来看一下实现一个普通的转场动画的流程。 设置转场方式将转场方式设置为自定义 1toVC.modalPresentationStyle = .custom 设置转场代理这里转场代理可以设置为目标控制器，也可以是我们自定义的管理转场的类，这里设置为目标控制器 1toVC.transitioningDelegate = toVC 实现转场代理方法转场的代理方法我们需要实现以下两个方法，指定我们自定义的类来管理转场动画，关于这个自定义的类，后面会详细说。 1234567891011public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; //这里的animationTransitionContr就是自定义的用来管理转场的类 animationTransitionContr.isPresenting = true return animationTransitionContr &#125; public func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; //这里的animationTransitionContr就是自定义的用来管理转场的类 animationTransitionContr.isPresenting = false return animationTransitionContr &#125; 自定义转场动画管理类这个管理类定为NSObject子类就可以，关键是它必须遵从UIViewControllerAnimatedTransitioning协议，并实现以下几个代理方法。 123456789101112131415func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return 0.25 &#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; let containerView = transitionContext.containerView guard let fromVC = transitionContext.viewController(forKey: .from) else &#123; return &#125; guard let toVC = transitionContext.viewController(forKey: .to) else &#123; return &#125; if isPresenting &#123; // 进入目标控制器的动画 &#125; else &#123; // 退出目标控制器的动画 &#125; &#125; 至此，一个常规的自定义转场动画就完成了。到这里就会发现一个问题，在实现具体动画的这一步，只有单个控制器使用这个转场类还好，如果是多个控制器分别需要实现不同的动画效果，这里的逻辑就会很复杂，代码可读性也不好。 要解决这个问题，我们可以把重构一下动画逻辑，将动画代码放在转场类里面，而将动画的具体实现放在目标控制器里。具体实现如下： 为转场控制类定义代理这里的代理方法是将动画的不同时间点的控制暴露给目标控制器 12345678 protocol ZYAnimationTransitionControllerDelegate: NSObjectProtocol &#123; func willPresent(fromView: UIView, toView: UIView) func onPresent(fromView: UIView, toView: UIView) func didPresent(fromView: UIView, toView: UIView) func willDismiss(fromView: UIView, toView: UIView) func onDismiss(fromView: UIView, toView: UIView) func didDismiss(fromView: UIView, toView: UIView)&#125; 在适当的时机调用代理方法123456789101112131415161718192021222324fileprivate func present(transitionContext: UIViewControllerContextTransitioning, container: UIView, fromView: UIView, toView: UIView, completion: @escaping () -&gt; Void) &#123; container.addSubview(toView) guard let delegate = delegate else &#123; return &#125; delegate.willPresent(fromView: fromView, toView: toView) self.startAnimation(transitionContext: transitionContext, animations: &#123; delegate.onPresent(fromView: fromView, toView: toView) &#125;) &#123; delegate.didPresent(fromView: fromView, toView: toView) completion() &#125;&#125;fileprivate func dismiss(transitionContext: UIViewControllerContextTransitioning, container: UIView, fromView: UIView, toView: UIView, completion: @escaping () -&gt; Void) &#123; container.addSubview(fromView) guard let delegate = delegate else &#123; return &#125; delegate.willDismiss(fromView: fromView, toView: toView) self .startAnimation(transitionContext: transitionContext, animations: &#123; delegate.onDismiss(fromView: fromView, toView: toView) &#125;) &#123; delegate.didDismiss(fromView: fromView, toView: toView) completion() &#125;&#125; 这里使用了一个辅助方法： 12345678fileprivate func startAnimation(transitionContext: UIViewControllerContextTransitioning, animations: @escaping () -&gt; Void, completion: @escaping () -&gt; Void) &#123; UIApplication.shared.beginIgnoringInteractionEvents() UIView.animate(withDuration: self.transitionDuration(using: self as? UIViewControllerContextTransitioning), delay: 0, options: UIView.AnimationOptions(rawValue: 7 &lt;&lt; 16), animations: animations, completion: &#123; _ in UIApplication.shared.endIgnoringInteractionEvents() completion() &#125;)&#125; 重构转场代理方法用以下方法替换之前的代理方法实现： 1234567891011121314func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; let containerView = transitionContext.containerView guard let fromVC = transitionContext.viewController(forKey: .from) else &#123; return &#125; guard let toVC = transitionContext.viewController(forKey: .to) else &#123; return &#125; if isPresenting &#123; present(transitionContext: transitionContext, container: containerView, fromView: fromVC.view, toView: toVC.view) &#123; transitionContext.completeTransition(!transitionContext.transitionWasCancelled) &#125; &#125; else &#123; dismiss(transitionContext: transitionContext, container: containerView, fromView: fromVC.view, toView: toVC.view) &#123; transitionContext.completeTransition(!transitionContext.transitionWasCancelled) &#125; &#125; &#125; 至此，动画逻辑的重构就完成了。这时，一个完整的自定义转场的实现逻辑就是这样的： 目标控制器设置转场类型为自定义 目标控制器设置转场代理为自己 目标控制器在转场代理方法中返回自定义的转场控制类 在自定义转场控制类中实现UIViewControllerAnimatedTransitioning协议方法 在自定义类中定义代理暴露动画控制权给目标控制器，并在适当时机调用代理方法 相关代码的完整实现可以参考我的图片预览框架源码","categories":[],"tags":[{"name":"UIViewControllerAnimatedTransitioning","slug":"UIViewControllerAnimatedTransitioning","permalink":"http://anye3210.github.io/tags/UIViewControllerAnimatedTransitioning/"},{"name":"自定义转场","slug":"自定义转场","permalink":"http://anye3210.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA/"}]},{"title":"AFNetworking源码上传图片部分完整解析","slug":"AFNetworking源码上传图片部分完整解析","date":"2017-04-19T14:00:00.000Z","updated":"2021-08-22T07:36:41.604Z","comments":true,"path":"2017/04/19/AFNetworking源码上传图片部分完整解析/","link":"","permalink":"http://anye3210.github.io/2017/04/19/AFNetworking%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E9%83%A8%E5%88%86%E5%AE%8C%E6%95%B4%E8%A7%A3%E6%9E%90/","excerpt":"最近在开发SDK时有上传图片的需求，这个需求用AF的话当然非常简单，多添加一句代码就可以搞定。但为避免第三方耦合并没有使用AFNetworking，这就需要自己走完上传图片的全部流程，所以仔细研究了一下AFNetworking的相关源码，梳理了整个流程，它的流程大致是这样的： &lt;img src=”http://ogdqxib8j.bkt.clouddn.com/image/png%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0.png&quot; title:”AFNetworking图片上传流程”&gt; 看着有点眼花眼花缭乱是吧，没关系，接着往下看，看完这篇文章，你也可以自己封装一套图片上传网络工具类。 目录 基本原理 具体实现 创建NSMutableURLRequest并设置请求方式为POST 自定义HTTPBodyStream 对request进行参数设置 通过NSURLSession的uploadTaskWithStreamedRequest:方法发起Post请求","text":"最近在开发SDK时有上传图片的需求，这个需求用AF的话当然非常简单，多添加一句代码就可以搞定。但为避免第三方耦合并没有使用AFNetworking，这就需要自己走完上传图片的全部流程，所以仔细研究了一下AFNetworking的相关源码，梳理了整个流程，它的流程大致是这样的： &lt;img src=”http://ogdqxib8j.bkt.clouddn.com/image/png%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0.png&quot; title:”AFNetworking图片上传流程”&gt; 看着有点眼花眼花缭乱是吧，没关系，接着往下看，看完这篇文章，你也可以自己封装一套图片上传网络工具类。 目录 基本原理 具体实现 创建NSMutableURLRequest并设置请求方式为POST 自定义HTTPBodyStream 对request进行参数设置 通过NSURLSession的uploadTaskWithStreamedRequest:方法发起Post请求 基本原理首先我们来看一下AF中上传图片的方法长什么样： 123456- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; 请求方式这个方法和AF其他正常的POST请求一样，都是基于NSURLSession，通过自定义的NSMutableURLRequest发起网络请求。不过在这个方法中，并没有使用常用的dataTaskWithRequest方法，而使用的是uploadTaskWithStreamedRequest。 工具类AFStreamingMultipartFormData在整个图片上传请求过程中，核心点在于为网络请求NSURLReqeust进行自定义的参数设定。为此，AFNetworking封装了一个工具类AFStreamingMultipartFormData，在这个类中完成对NSURLRequst除HTTPMethod外所有参数的设定。 InputStream的子类AFMultipartBodyStream图片上传需要封装参数和图片数据，每一个参数的键值对都会封装成一个AFHTTPBodyPart模型，而AFMultipartBodyStream 就负责对AFHTTPBodyPart进行管理，它本身同时也是自定义的HTTPBodyStream。 参数的封装AFHTTPBodyPartAFHTTPBodyPart是对POST请求数据的封装，并实现将请求数据转换为InputStream的方法 具体实现上面的原理讲起来有点儿抽象，下面从图片上传的完整实现中来了解整个过程。 创建NSMutableURLRequest并设置请求方式为POST这一步就是常规步骤，代码如下： 12NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL:[NSURL URLWithString:api] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0f];[request setHTTPMethod:@&quot;POST&quot;]; 自定义HTTPBodyStream首先，需要创建一个工具类来管理刚刚创建的request： 1__block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:request stringEncoding:NSUTF8StringEncoding]; 接下来，需要将所有参数的键值对转换为AFHTTPBodyPart，这里要分两种情况：普通参数和图片相关参数。 普通参数普通参数的转换直接遍历即可，将每一个键值对都转换为AFHTTPBodyPart，不过AFNetworking在这里将键值对又封闭了一个模型AFQueryStringPair，所以你看到的是这样的： 12345678910111213141516if (parameters) &#123; for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123; NSData *data = nil; if ([pair.value isKindOfClass:[NSData class]]) &#123; data = pair.value; &#125; else if ([pair.value isEqual:[NSNull null]]) &#123; data = [NSData data]; &#125; else &#123; data = [[pair.value description] dataUsingEncoding:self.stringEncoding]; &#125; if (data) &#123; [formData appendPartWithFormData:data name:[pair.field description]]; &#125; &#125;&#125; 不过个人觉得完全没有必要，不封装模型这样写可以达到同样的效果： 123456789101112131415if (parameters) &#123; [parameters enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; NSData *data = nil; if ([obj isKindOfClass:[NSData class]]) &#123; data = obj; &#125;else if ([obj isKindOfClass:[NSNull class]]) &#123; data = [NSData data]; &#125;else &#123; data = [[obj description] dataUsingEncoding:NSUTF8StringEncoding]; &#125; if (data) &#123; [formData appendPartWithFormData:data name:[key description]]; &#125; &#125;];&#125; 在上面的方法中，调用了-appendPartWithFormData:name:方法，这个方法的作用有两个：拼装Header字典和封装AFHTTPBodyPart模型： 123456789- (void)appendPartWithFormData:(NSData *)data name:(NSString *)name &#123; NSParameterAssert(name); // 拼装Header字典 NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@&quot;form-data; name=\\&quot;%@\\&quot;&quot;, name] forKey:@&quot;Content-Disposition&quot;]; [self appendPartWithHeaders:mutableHeaders body:data];&#125; 1234567891011121314- (void)appendPartWithHeaders:(NSDictionary *)headers body:(NSData *)body&#123; NSParameterAssert(body); // 创建模型 AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = headers; bodyPart.boundary = self.boundary; bodyPart.bodyContentLength = [body length]; bodyPart.body = body; // bodyStream管理bodyPart [self.bodyStream appendHTTPBodyPart:bodyPart];&#125; 接下来就是在AFMultipartBodyStream中管理生成的多个AFHTTPBodyPart。 图片相关参数如果只需要单一的上传图片的需求，直接将图片的数据、名称、类型等作为方法的参数传进来就可以，实现起来除Header的拼装有差异外几乎和上面正常参数一样。但AF为了可扩展性，添加了一个Block和代理，方便除NSData以外诸如FileURL、InputStream等上传方式。 这个Block长这个样子 1void (^block)(id &lt;AFMultipartFormData&gt; formData) Block传入的参数是除图片参数的键值对外的全部转换完成后的AFStreamingMultipartFormData，遵从AFMultipartFormData 协议。在以上正常参数转换完之后调用，Block的实现为用户自定义，用户可以选择适合的方式添加参数上传数据，这里只讲图片的NSData方式上传： 1[formData appendPartWithFileData:imageData name:key fileName:[NSString stringWithFormat:@&quot;%@.jpg&quot;,key] mimeType:@&quot;image/jpeg&quot;]; 然后同样是拼接Header 1234567891011121314- (void)appendPartWithFileData:(NSData *)data name:(NSString *)name fileName:(NSString *)fileName mimeType:(NSString *)mimeType &#123; NSParameterAssert(name); NSParameterAssert(fileName); NSParameterAssert(mimeType); NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary]; [mutableHeaders setValue:[NSString stringWithFormat:@&quot;form-data; name=\\&quot;%@\\&quot;; filename=\\&quot;%@\\&quot;&quot;, name, fileName] forKey:@&quot;Content-Disposition&quot;]; [mutableHeaders setValue:mimeType forKey:@&quot;Content-Type&quot;]; [self appendPartWithHeaders:mutableHeaders body:data];&#125; 然后是转换成AFHTTPBodyPart，由AFMultipartBodyStream进行管理。 12345678910111213- (void)appendPartWithHeaders:(NSDictionary *)headers body:(NSData *)body &#123; NSParameterAssert(body); AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init]; bodyPart.stringEncoding = self.stringEncoding; bodyPart.headers = headers; bodyPart.boundary = self.boundary; bodyPart.bodyContentLength = [body length]; bodyPart.body = body; [self.bodyStream appendHTTPBodyPart:bodyPart];&#125; AFMultipartBodyStream管理并转换AFHTTPBodyPart内部数据的具体实现每生成一个AFHTTPBodyPart它都会存入AFMultipartBodyStream的HTTPBodyParts这个可变数组中，方便后面对数据进行处理。 而AFMultipartBodyStream的对数据转换要从它的父类NSInputStream说起，NSInputStream是NSStream的子类，方便我们以流文件的形式读取数据。在AF中，它重写了父类的-read:maxLength:方法，在这个方法里进行数据的处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length &#123; if ([self streamStatus] == NSStreamStatusClosed) &#123; return 0; &#125; NSInteger totalNumberOfBytesRead = 0; while ((NSUInteger)totalNumberOfBytesRead &lt; MIN(length, self.numberOfBytesInPacket)) &#123; if (!self.currentHTTPBodyPart || ![self.currentHTTPBodyPart hasBytesAvailable]) &#123; if (!(self.currentHTTPBodyPart = [self.HTTPBodyPartEnumerator nextObject])) &#123; break; &#125; &#125; else &#123; NSUInteger maxLength = MIN(length, self.numberOfBytesInPacket) - (NSUInteger)totalNumberOfBytesRead; NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&amp;buffer[totalNumberOfBytesRead] maxLength:maxLength]; if (numberOfBytesRead == -1) &#123;// self.streamError = self.currentHTTPBodyPart.inputStream.streamError; break; &#125; else &#123; totalNumberOfBytesRead += numberOfBytesRead; if (self.delay &gt; 0.0f) &#123; [NSThread sleepForTimeInterval:self.delay]; &#125; &#125; &#125; &#125; return totalNumberOfBytesRead;&#125;​``` objc上面这个方法核心就是把`bodyPart`挨个取出来进行读取数据操作，`bodyPart`读取数据的操作是在其内部实现的：​``` objc- (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)length &#123; NSInteger totalNumberOfBytesRead = 0; if (_phase == AFEncapsulationBoundaryPhase) &#123; NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:encapsulationBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; if (_phase == AFHeaderPhase) &#123; NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding]; totalNumberOfBytesRead += [self readData:headersData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; if (_phase == AFBodyPhase) &#123; NSInteger numberOfBytesRead = 0; numberOfBytesRead = [self.inputStream read:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; if (numberOfBytesRead == -1) &#123; return -1; &#125; else &#123; totalNumberOfBytesRead += numberOfBytesRead; if ([self.inputStream streamStatus] &gt;= NSStreamStatusAtEnd) &#123; [self transitionToNextPhase]; &#125; &#125; &#125; if (_phase == AFFinalBoundaryPhase) &#123; NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]); totalNumberOfBytesRead += [self readData:closingBoundaryData intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)totalNumberOfBytesRead)]; &#125; return totalNumberOfBytesRead;&#125; 1234567891011121314- (NSInteger)readData:(NSData *)data intoBuffer:(uint8_t *)buffer maxLength:(NSUInteger)length &#123; NSRange range = NSMakeRange((NSUInteger)_phaseReadOffset, MIN([data length] - ((NSUInteger)_phaseReadOffset), length)); [data getBytes:buffer range:range]; _phaseReadOffset += range.length; if (((NSUInteger)_phaseReadOffset) &gt;= [data length]) &#123; [self transitionToNextPhase]; &#125; return (NSInteger)range.length;&#125; 123456789101112131415161718192021222324252627282930- (BOOL)transitionToNextPhase &#123; if (![[NSThread currentThread] isMainThread]) &#123; dispatch_sync(dispatch_get_main_queue(), ^&#123; [self transitionToNextPhase]; &#125;); return YES; &#125; switch (_phase) &#123; case AFEncapsulationBoundaryPhase: _phase = AFHeaderPhase; break; case AFHeaderPhase: [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes]; [self.inputStream open]; _phase = AFBodyPhase; break; case AFBodyPhase: [self.inputStream close]; _phase = AFFinalBoundaryPhase; break; case AFFinalBoundaryPhase: default: _phase = AFEncapsulationBoundaryPhase; break; &#125; _phaseReadOffset = 0; return YES;&#125; 上面三个方法即是bodyPart对数据读取的全部实现，看着比较复杂，梳理下来其实它的逻辑也比较清晰。简单来说就是把数据读取分成几个阶段，不同阶段进行相应操作，其最核心的是这两句： 12[self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];[self.inputStream open]; 这两句不仅仅是把输入流加入运行循环，开始读取数据，这里还用了一个懒加载，重写了inputStream的getter方法，在这个方法里进行了inputStream的初始化，即数据源的指定。 123456789101112131415- (NSInputStream *)inputStream &#123; if (!_inputStream) &#123; if ([self.body isKindOfClass:[NSData class]]) &#123; _inputStream = [NSInputStream inputStreamWithData:self.body]; &#125; else if ([self.body isKindOfClass:[NSURL class]]) &#123; _inputStream = [NSInputStream inputStreamWithURL:self.body]; &#125; else if ([self.body isKindOfClass:[NSInputStream class]]) &#123; _inputStream = self.body; &#125; else &#123; _inputStream = [NSInputStream inputStreamWithData:[NSData data]]; &#125; &#125; return _inputStream;&#125; 所有的参数的数据流读取完毕，我们的自定义HTTPBodyStream也完成了，接下来就可以把它赋值给request了。 对request进行参数设置参数设置这步比较简单，将之前自定义好的HTTPBodyStream赋值然后补充必要的参数即可： 12// 调用方法对request进行配置[formData requestByFinalizingMultipartFormData] 1234567891011121314- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123; if ([self.bodyStream isEmpty]) &#123; return self.request; &#125; // 重设Boundary确保内容长度计算正确 [self.bodyStream setInitialAndFinalBoundaries]; [self.request setHTTPBodyStream:self.bodyStream]; [self.request setValue:[NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, self.boundary] forHTTPHeaderField:@&quot;Content-Type&quot;]; [self.request setValue:[NSString stringWithFormat:@&quot;%llu&quot;, [self.bodyStream contentLength]] forHTTPHeaderField:@&quot;Content-Length&quot;]; return self.request;&#125; 通过NSURLSession的uploadTaskWithStreamedRequest:方法发起Post请求上面request配置完成，就剩最后一步发起请求了： 12345678910111213__block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123; if (error) &#123; if (failure) &#123; failure(task, error); &#125; &#125; else &#123; if (success) &#123; success(task, responseObject); &#125; &#125; &#125;]; [task resume]; 12345678910111213- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; __block NSURLSessionUploadTask *uploadTask = nil; url_session_manager_create_task_safely(^&#123; uploadTask = [self.session uploadTaskWithStreamedRequest:request]; &#125;); [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler]; return uploadTask;&#125; 在AF自定义的上传方法中，使用了自己的代理，并让代理调用Block进行上传进度和完成的回调，具体实现在这里就不赘述了，可以看源代码进一步了解。 其实这个方法也完全可以用- dataTaskWithRequest:completionHandler:代替，这就避免了自己手动实现代理和回调的麻烦。 至此，整个图片上传流程就完成了。如果你自己写一个上传图片方法，其实也完全不用像AF的这么复杂，毕竟AF是要考虑到各种复杂的使用场景，内部的复杂实现可以保证调用更灵活也更方便。","categories":[],"tags":[{"name":"AFNetwork","slug":"AFNetwork","permalink":"http://anye3210.github.io/tags/AFNetwork/"},{"name":"上传图片","slug":"上传图片","permalink":"http://anye3210.github.io/tags/%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"},{"name":"源码解析","slug":"源码解析","permalink":"http://anye3210.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"【iOS】超简单的思路实现2048游戏","slug":"超简单的思路实现一个2048游戏","date":"2017-04-07T11:01:44.000Z","updated":"2021-08-22T07:37:24.268Z","comments":true,"path":"2017/04/07/超简单的思路实现一个2048游戏/","link":"","permalink":"http://anye3210.github.io/2017/04/07/%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA2048%E6%B8%B8%E6%88%8F/","excerpt":"最近在网上下了一个仿2048游戏的Demo，发现里面的实现思路做得比较复杂：将数字块的移动操作封装成模型并保存起来，然后根据操作模型的值对滑块逐块地进行操作，具体的实现方式可以自己下下来感受一下。 然后我分析了一下这个游戏，重新整理了一种更简单的实现思路，大体可以分为三步： 界面布局 数字块操作 按方向把所有数字块分成4组，然后进行排序 查找邻近相同数字块，计算该行（列）合并后的块数 按方向整行（列）同时移动数字块 移动块的同时随机添加数字块 游戏结束重置游戏 实现效果如下：","text":"最近在网上下了一个仿2048游戏的Demo，发现里面的实现思路做得比较复杂：将数字块的移动操作封装成模型并保存起来，然后根据操作模型的值对滑块逐块地进行操作，具体的实现方式可以自己下下来感受一下。 然后我分析了一下这个游戏，重新整理了一种更简单的实现思路，大体可以分为三步： 界面布局 数字块操作 按方向把所有数字块分成4组，然后进行排序 查找邻近相同数字块，计算该行（列）合并后的块数 按方向整行（列）同时移动数字块 移动块的同时随机添加数字块 游戏结束重置游戏 实现效果如下： 具体实现##界面布局界面布局是最简单的一步，主要分为三大块：分数栏，游戏背景板和数字块背景，以下是代码： 123456789101112131415161718192021private func setupUI() &#123; let boardWH = SCREEN_WIDTH - boardLeftMargin * 2 let gameBoard = ZYGameBoard(frame: CGRect(x: 0, y: 0, width: boardWH, height: boardWH)) gameBoard.center = view.center view.addSubview(gameBoard) let cellWH = (gameBoard.frame.width - margin * CGFloat(cellRowCount + 1)) / CGFloat(cellRowCount) let scoreW = cellWH * 3 let scoreH = cellWH * 0.9 scoreView = UILabel(frame: CGRect(x: 0, y: 0, width: scoreW, height: scoreH)) scoreView?.center = CGPoint(x: SCREEN_WIDTH / 2, y: gameBoard.frame.minY - margin * 2 - scoreH / 2) scoreView?.font = UIFont.boldSystemFont(ofSize: 20) scoreView?.textAlignment = .center scoreView?.textColor = UIColor.white scoreView?.backgroundColor = UIColor.gray scoreView?.text = &quot;SCORE:0&quot; scoreView?.layer.cornerRadius = 8 scoreView?.clipsToBounds = true view.addSubview(scoreView!)&#125; 这里ZYGameBoard是一个自定义View，在自定义View是里面添加了数字块的背景还有所有的数字块移动逻辑，以下是ZYGameBoard的界面布局： 123456789101112131415self.backgroundColor = UIColor.blackself.layer.cornerRadius = 8self.clipsToBounds = truefor index in 0..&lt;cellRowCount * cellRowCount &#123; let row = index / cellRowCount let column = index % cellRowCount let cellBgView = UIView(frame: tileCellFrame(row: row, column: column)) cellBgView.backgroundColor = UIColor.darkGray cellBgView.layer.cornerRadius = 5 cellBgView.clipsToBounds = true self.addSubview(cellBgView) &#125; 然后，还需要定义数据块的自定义View: 1234567891011121314151617181920class ZYTileCell: UILabel &#123; var isCombined = false var tilePath : ZYTilePath let cellID : Int init(indexPath: ZYTilePath, cellID : Int) &#123; self.tilePath = indexPath self.cellID = cellID let cellWH = (SCREEN_WIDTH - boardLeftMargin * 2 - margin * CGFloat(cellRowCount + 1)) / CGFloat(cellRowCount) let cellX = CGFloat(indexPath.column) * (cellWH + margin) + margin let cellY = CGFloat(indexPath.row) * (cellWH + margin) + margin super.init(frame: CGRect(x: cellX, y: cellY, width: cellWH, height: cellWH)) self.font = UIFont.boldSystemFont(ofSize: 25) self.backgroundColor = UIColor.clear self.textColor = UIColor.rgbColor(red: 119, green: 110, blue: 100) self.layer.cornerRadius = 5 self.clipsToBounds = true self.textAlignment = .center &#125;&#125; 其中省略了不同数字块颜色的定义，具体的可以看本文的源代码，见文末。至此，界面布局部分就完成了。 数字块操作这部分为整个游戏的核心部分，在这部分之前，需要对4个方向添加不同的swipe手势，每个手势添加不同的响应方法，这里略过了，以下具体讲响应方法的具体实现： 按方向把所有数字块分成4组，然后进行排序123456789101112131415161718192021222324252627282930313233343536373839404142434445var cellLines = [[ZYTileCell]]()for _ in 0..&lt;4 &#123; cellLines.append([ZYTileCell]())&#125; for tileCell in tileCells &#123; for index in 0..&lt;cellLines.count &#123; if ((direction == .up || direction == .down) &amp;&amp; tileCell.tilePath.column == index) || ((direction == .left || direction == .right) &amp;&amp; tileCell.tilePath.row == index) &#123; cellLines[index].append(tileCell) &#125; &#125;&#125;var sortWay : (ZYTileCell, ZYTileCell) -&gt; Boolswitch direction &#123;case .up: sortWay = &#123; (cell1, cell2) -&gt; Bool in return cell1.tilePath.row &lt; cell2.tilePath.row &#125; breakcase .down: sortWay = &#123; (cell1, cell2) -&gt; Bool in return cell1.tilePath.row &gt; cell2.tilePath.row &#125; breakcase .left: sortWay = &#123; (cell1, cell2) -&gt; Bool in return cell1.tilePath.column &lt; cell2.tilePath.column &#125; breakcase .right: sortWay = &#123; (cell1, cell2) -&gt; Bool in return cell1.tilePath.column &gt; cell2.tilePath.column &#125; break&#125;var combinedCellLines = [[ZYTileCell]]()isAnyLineSameNumExist = falsefor index in 0..&lt;cellLines.count &#123; let sortedLine = cellLines[index].sorted(by: sortWay) cellLines[index] = sortedLine combinedCellLines.append(findSameNumAndCombine(needMove: needMove, sortedCells: sortedLine)) if isSameNumExist &#123; isAnyLineSameNumExist = true &#125;&#125; 查找邻近相同数字块，计算该行（列）合并后的块数接下来把排序后的数组相邻的块进行比较，相同的进行合并，把需要删除的数字块从数组移除并执行移除动画： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private func findSameNumAndCombine(needMove: Bool, sortedCells: [ZYTileCell]) -&gt; [ZYTileCell] &#123; if sortedCells.count &lt; 2 &#123; return sortedCells&#125; isSameNumExist = false var newTileCells = [ZYTileCell]() for tileCell in sortedCells &#123; newTileCells.append(tileCell) &#125; var combinedIndex = 1000 for (cellIndex, cell) in sortedCells.enumerated() &#123; cell.isCombined = false if cellIndex + 1 &lt; sortedCells.count &amp;&amp; cellIndex != combinedIndex + 1 &#123; if sortedCells[cellIndex].num == sortedCells[cellIndex + 1].num &#123; if needMove &#123; cell.num = cell.num! * 2 if isSameNumExist &#123; newTileCells.remove(at: cellIndex) &#125;else &#123; newTileCells.remove(at: cellIndex + 1) &#125; let extraCell = sortedCells[cellIndex + 1] UIView.animate(withDuration: 0.1, animations: &#123; extraCell.alpha = 0 &#125;, completion: &#123; (_) in extraCell.removeFromSuperview() &#125;) var index = 0 for tileCell in tileCells &#123; if extraCell.cellID == tileCell.cellID &#123; break &#125; index += 1 &#125; if index &lt; tileCells.count &#123; tileCells.remove(at: index) &#125; cell.isCombined = true if scoreChanged != nil &#123; scoreChanged!(cell.num!) &#125; &#125; combinedIndex = cellIndex isSameNumExist = true &#125; &#125; &#125; return newTileCells&#125; 在上面的方法里有一个细节就是如果所有的数字块满了，需要挨个模拟各个方向的滑动，在这个方法里判断是否有可以合并的数字块，如果有游戏继续，否则游戏结束。 按方向整行（列）同时移动数字块接下来就可以真正地开始移动数字块了，移动数字块的思路就是计算出整行或者整列的数字块移动后的最终位置，然后用最终位置和初始位置的差确定位置的距离和方向。 思路虽然是这样，但在写代码的时候要简单得多，直接遍历整行（整列的）排序后的数字块，下标为最终位置，自身的坐标为初始位置，用这两个值即可计算出位移，坐标轴如下： 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private func moveTile(direction: ZYDirection, cellLines: [[ZYTileCell]], combinedCellLines: [[ZYTileCell]]) &#123; for (lineIndex, lineCells) in cellLines.enumerated() &#123; var needMoreStep = false for (index, originCell) in lineCells.enumerated() &#123; let combinedCells = combinedCellLines[lineIndex] var toIndex = index var distance : CGFloat = 0 var cellFrame = originCell.frame if toIndex &gt; combinedCells.count - 1 &#123; toIndex = combinedCells.count - 1 &#125; var delta = 0 if needMoreStep &#123; delta = 1 &#125; switch direction &#123; case .up: distance = CGFloat(toIndex - originCell.tilePath.row - delta) * (originCell.frame.height + margin) cellFrame.origin.y += distance originCell.tilePath = ZYTilePath(row: toIndex, column: lineIndex) break case .down: toIndex = 3 - toIndex distance = CGFloat(toIndex - originCell.tilePath.row + delta) * (originCell.frame.height + margin) cellFrame.origin.y += distance originCell.tilePath = ZYTilePath(row: toIndex, column: lineIndex) break case .left: distance = CGFloat(toIndex - originCell.tilePath.column - delta) * (originCell.frame.height + margin) cellFrame.origin.x += distance originCell.tilePath = ZYTilePath(row: lineIndex, column: toIndex) break case .right: toIndex = 3 - toIndex distance = CGFloat(toIndex - originCell.tilePath.column + delta) * (originCell.frame.height + margin) cellFrame.origin.x += distance originCell.tilePath = ZYTilePath(row: lineIndex, column: toIndex) break &#125; needMoreStep = originCell.isCombined if distance != 0 &#123; UIView.animate(withDuration: 0.1, animations: &#123; originCell.frame = cellFrame &#125;, completion: &#123; (_) in if originCell.isCombined == false &#123; return &#125; originCell.transform = CGAffineTransform(scaleX: 0.8, y: 0.8) UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: UIViewAnimationOptions(rawValue: 0), animations: &#123; originCell.transform = CGAffineTransform.identity &#125;, completion: nil) &#125;) &#125; &#125; &#125;&#125; 上面的代码对该行存在合并数字块的情况进行了处理：如果该行有数字块合并了（即保留前面一块，移除后面一块），后面所有块都会多移一步，避免中间出现空白。 至此，移动数字块部分也完成了，接下来就是随机添加数字块了。 移动块的同时随机添加数字块这步应该是数字块操作里面最简单的一步，从所有可能的坐标数组中删除有数字块的元素，剩下都是没有数字块的坐标，在这些坐标中随机选一个添加数字块即可。 12345678910111213141516171819202122232425262728293031private func addRandomTileCell() &#123; var tilePaths = [ZYTilePath]() for index in 0..&lt;cellRowCount * cellRowCount &#123; let row = index / cellRowCount let column = index % cellRowCount tilePaths.append(ZYTilePath(row: row, column: column)) &#125; if tileCells.count &gt; 0 &#123; for tileCell in tileCells &#123; for (index, tilePath) in tilePaths.enumerated() &#123; if tileCell.tilePath.row == tilePath.row &amp;&amp; tileCell.tilePath.column == tilePath.column &#123; tilePaths.remove(at: index) &#125; &#125; &#125; &#125; let randomTilePath = tilePaths[Int(arc4random_uniform(UInt32(tilePaths.count) - 1))] let tileCell = ZYTileCell(indexPath: randomTilePath, cellID: currentID) currentID += 1 tileCell.num = arc4random() % 3 == 0 ? 4 : 2 tileCells.append(tileCell) tileCell.frame = tileCellFrame(row: randomTilePath.row, column: randomTilePath.column) addSubview(tileCell) tileCell.transform = CGAffineTransform(scaleX: 0.2, y: 0.2) UIView.animate(withDuration: 0.5, delay: 0.1, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: UIViewAnimationOptions(rawValue: 0), animations: &#123; tileCell.transform = CGAffineTransform.identity &#125;, completion: nil) &#125; 当然，在添加数字块的同时，如果剩余空坐标为0，那么就要进行游戏是否结束的验证，如果游戏结束，就以闭包的形式在控制器进行弹窗操作： 12345678910111213141516171819202122232425// 判断游戏是否结束if tilePaths.count == 0 &#123; swipeAction(direction: .up, needMove: false) let upSameNumExist = isAnyLineSameNumExist swipeAction(direction: .down, needMove: false) let downSameNumExist = isAnyLineSameNumExist swipeAction(direction: .left, needMove: false) let leftSameNumExist = isAnyLineSameNumExist swipeAction(direction: .right, needMove: false) let rightSameNumExist = isAnyLineSameNumExist if gameOver != nil &amp;&amp; !(upSameNumExist || downSameNumExist || leftSameNumExist || rightSameNumExist) &#123; gameOver!() &#125; return&#125;// 如果游戏结束，在控制器进行操作gameBoard.gameOver = &#123; let alertContr = UIAlertController(title: &quot;提示&quot;, message: &quot;游戏失败，请重试&quot;, preferredStyle: .alert) let confirmAction = UIAlertAction(title: &quot;确定&quot;, style: .default, handler: &#123; (alertAction) in gameBoard.resetGame() self.score = 0 &#125;) alertContr.addAction(confirmAction) self.present(alertContr, animated: true, completion: nil)&#125; 游戏结束重置游戏接下来就是最后一步，重置游戏数据： 123456func resetGame() &#123; for tileCell in self.tileCells &#123; tileCell.removeFromSuperview() &#125; self.tileCells.removeAll()&#125; 好了，大功告成，现在可以装到手机上玩儿一把了。 看本文源代码点这里","categories":[],"tags":[{"name":"2048","slug":"2048","permalink":"http://anye3210.github.io/tags/2048/"},{"name":"swift","slug":"swift","permalink":"http://anye3210.github.io/tags/swift/"},{"name":"Game","slug":"Game","permalink":"http://anye3210.github.io/tags/Game/"}]},{"title":"CAShapeLayer文字动画","slug":"制作文字动画","date":"2017-02-23T15:10:17.000Z","updated":"2021-08-22T07:39:08.618Z","comments":true,"path":"2017/02/23/制作文字动画/","link":"","permalink":"http://anye3210.github.io/2017/02/23/%E5%88%B6%E4%BD%9C%E6%96%87%E5%AD%97%E5%8A%A8%E7%94%BB/","excerpt":"文字动画也是CAShapeLayer图形动画的一种，巧妙运用文字动画可以实现很不错的效果，比如半糖app的下拉动画。本文就主要讲一下其实现原理。 文字动画主要分为两部分： 将文字转化为CAShapeLayer 通过更改CAShapeLayer的StrokeEnd属性值生成动画","text":"文字动画也是CAShapeLayer图形动画的一种，巧妙运用文字动画可以实现很不错的效果，比如半糖app的下拉动画。本文就主要讲一下其实现原理。 文字动画主要分为两部分： 将文字转化为CAShapeLayer 通过更改CAShapeLayer的StrokeEnd属性值生成动画 将文字转换为CAShapeLayer将文字转换为CAShapeLayer的过程比较复杂，可以细分为以下几个步骤： 创建NSAttributedString并生成CTLineRef 使用CTLineRef生成CTRunRef数组 遍历CTRunRef数组，得到每个CTRunRef 遍历CTRunRef中每个长度为1的区间生成CGGlyph并转换为CGPath路径，将所有路径拼接起来 创建ShapeLayer并将生成的路径赋值给该ShapeLayer 以下是每个步骤的实现方式： 创建NSAttributedString并生成CTLineRef123456// 定义字体属性CTFontRef font = CTFontCreateWithName(CFSTR(&quot;HelveticaNeue-UltraLight&quot;), fontSize, NULL);NSDictionary *attrs = [NSDictionary dictionaryWithObjectsAndKeys:(__bridge id)font, kCTFontAttributeName,nil];// 创建NSAttributedStringNSAttributedString *str = [[NSAttributedString alloc] initWithString:text attributes:attrs];CTLineRef line = CTLineCreateWithAttributedString((CFAttributedStringRef)str); 使用CTLineRef生成CTRunRef数组12CTLineRef line = CTLineCreateWithAttributedString((CFAttributedStringRef)str);CFArrayRef runArray = CTLineGetGlyphRuns(line); 遍历CTRunRef数组，得到每个CTRunRef12345for (CFIndex runIndex = 0; runIndex &lt; CFArrayGetCount(runArray); runIndex++) &#123; // CTRunRef run = (CTRunRef)CFArrayGetValueAtIndex(runArray, runIndex); CTFontRef runFont = CFDictionaryGetValue(CTRunGetAttributes(run), kCTFontAttributeName);&#125; 遍历CTRunRef中每个长度为1的区间生成CGGlyph并转换为CGPath路径，将所有路径拼接起来12345678910111213for (CFIndex glyphIndex = 0; glyphIndex &lt; CTRunGetGlyphCount(run); glyphIndex++) &#123; CGGlyph glyph; CGPoint position; CFRange currentRange = CFRangeMake(glyphIndex, 1); CTRunGetGlyphs(run, currentRange, &amp;glyph); CTRunGetPositions(run, currentRange, &amp;position); CGPathRef letter = CTFontCreatePathForGlyph(runFont, glyph, NULL); CGAffineTransform t = CGAffineTransformMakeTranslation(position.x, position.y); CGPathAddPath(letters, &amp;t, letter); CGPathRelease(letter);&#125; 创建ShapeLayer并将生成的路径赋值给该ShapeLayer1234567891011121314// 创建UIBezierPathUIBezierPath *path = [UIBezierPath bezierPathWithCGPath:letters];// 创建并配置CAShapeLayerCAShapeLayer *pathLayer = [CAShapeLayer layer];pathLayer.frame = self.bounds;pathLayer.bounds = CGPathGetBoundingBox(path.CGPath);pathLayer.geometryFlipped = YES;pathLayer.path = path.CGPath;pathLayer.strokeColor = fontColor.CGColor;pathLayer.fillColor = nil;pathLayer.lineWidth = 1.0f;pathLayer.lineJoin = kCALineJoinBevel;pathLayer.strokeStart = 0;pathLayer.strokeEnd = 0; 最后，将ShapeLayer添加到动画图层中就行了 生成文字动画通过改变ShapeLayer的StrokeEnd属性值就可以生成文字动画 添加Slider12345678- (void)setupSlider &#123; CGFloat leftMargin = 20; UISlider *slider = [[UISlider alloc] initWithFrame:CGRectMake(leftMargin, kMainHeight - 30, kMainWidth - leftMargin * 2, 3)]; slider.minimumValue = 0; slider.maximumValue = 1; [self.view addSubview:slider]; [slider addTarget:self action:@selector(sliderValueChanged:) forControlEvents:UIControlEventValueChanged];&#125; 实现Slider的ValueChange方法123- (void)sliderValueChanged:(UISlider *)sender &#123; self.pathLayer.strokeEnd = sender.value;&#125; 至此，一个文字动画就完成了 本文demo的github地址：https://github.com/zephyrw/TextAnimationDemo.git","categories":[],"tags":[{"name":"ShapeLayer","slug":"ShapeLayer","permalink":"http://anye3210.github.io/tags/ShapeLayer/"},{"name":"Animation","slug":"Animation","permalink":"http://anye3210.github.io/tags/Animation/"},{"name":"动画","slug":"动画","permalink":"http://anye3210.github.io/tags/%E5%8A%A8%E7%94%BB/"},{"name":"文字","slug":"文字","permalink":"http://anye3210.github.io/tags/%E6%96%87%E5%AD%97/"}]},{"title":"CAShapeLayer的使用","slug":"CAShapeLayer的使用","date":"2017-02-23T14:40:24.000Z","updated":"2021-08-22T07:39:38.855Z","comments":true,"path":"2017/02/23/CAShapeLayer的使用/","link":"","permalink":"http://anye3210.github.io/2017/02/23/CAShapeLayer%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"简介官方文档对CAShapeLayer的定义如下： A layer that draws a cubic Bezier spline in its coordinate space. 可以理解为CAShapeLayer是其坐标空间内绘有贝塞尔曲线的图层。使用CAShapeLayer可以制作蒙板和图层动画，它继承自CALayer，拥有CALayer的全部属性。CAShapeLayer的依赖于贝塞尔曲线UIBezierPath，它决定的ShapeLayer的形状。 StrokeStart和StrokeEnd是ShapeLayer的重要属性，它控制ShapeLayer的cgPath路径的绘制起点和终点，区间都为0~1，0代表从头绘制，1代表绘制到终点。","text":"简介官方文档对CAShapeLayer的定义如下： A layer that draws a cubic Bezier spline in its coordinate space. 可以理解为CAShapeLayer是其坐标空间内绘有贝塞尔曲线的图层。使用CAShapeLayer可以制作蒙板和图层动画，它继承自CALayer，拥有CALayer的全部属性。CAShapeLayer的依赖于贝塞尔曲线UIBezierPath，它决定的ShapeLayer的形状。 StrokeStart和StrokeEnd是ShapeLayer的重要属性，它控制ShapeLayer的cgPath路径的绘制起点和终点，区间都为0~1，0代表从头绘制，1代表绘制到终点。 目录 ShapeLayer图形动画 ShapeLayer蒙版 本文demo的github地址：https://github.com/zephyrw/ShapeLayerDemo.git 使用ShapeLayer图形动画动画简介使用ShapeLayer制作动画原理是通过改变ShapeLayer的strokeEnd属性值来改变ShapeLayer的path的绘制，strokeEnd值区间为0~1 下图为使用ShapeLayer制作仿今日头条下拉动画效果 实现把整个图形分成三个部分：外边框、左上角的框和所有的横线，分别用贝塞尔曲线绘制这三个部分 外边框1let draftPath = UIBezierPath(roundedRect: CGRect(x: 0, y: 0, width: width, height: height), cornerRadius: 5) 左上角边框1let squarePath = UIBezierPath(roundedRect: CGRect(x: margin, y: margin, width: smallSquareWH, height: smallSquareWH), cornerRadius: 2) 所有横线123456789let linePath = UIBezierPath() for i in 0..&lt;3 &#123; linePath.move(to: CGPoint(x: shortLineLeft, y: margin + 2 + space * CGFloat(i))) linePath.addLine(to: CGPoint(x: shortLineRight, y: margin + 2 + space * CGFloat(i)))&#125;for i in 0..&lt;3 &#123; linePath.move(to: CGPoint(x: margin, y: margin * 2 + 2 + smallSquareWH + space * CGFloat(i))) linePath.addLine(to: CGPoint(x: longLineRight, y: margin * 2 + 2 + smallSquareWH + space * CGFloat(i)))&#125; 将所有贝塞尔曲线绘制到ShapeLayer中1234567891011self.draftShapeLayer = CAShapeLayer()self.draftShapeLayer!.frame = CGRect(x: 0, y: 0, width: width, height: height)setupShapeLayer(shapeLayer: self.draftShapeLayer!, path: draftPath.cgPath) self.squareShapeLayer = CAShapeLayer()self.squareShapeLayer!.frame = CGRect(x: 0, y: 0, width: smallSquareWH, height: smallSquareWH)setupShapeLayer(shapeLayer: self.squareShapeLayer!, path: squarePath.cgPath) self.lineShapeLayer = CAShapeLayer()self.lineShapeLayer!.frame = CGRect(x: 0, y: 0, width: width, height: height)setupShapeLayer(shapeLayer: self.lineShapeLayer!, path: linePath.cgPath) 这里抽出了辅助方法来设置ShapeLayer和添加到控制器图层 123456789private func setupShapeLayer(shapeLayer : CAShapeLayer, path : CGPath) &#123; shapeLayer.path = path shapeLayer.strokeColor = UIColor.gray.cgColor shapeLayer.fillColor = UIColor.white.cgColor shapeLayer.lineWidth = 2 shapeLayer.strokeStart = 0 shapeLayer.strokeEnd = 0 self.containerLayer.addSublayer(shapeLayer)&#125; 添加SliderView1234567private func addSlider() &#123; let slider = UISlider(frame: CGRect(x: 20, y: UIScreen.main.bounds.height - 50, width: UIScreen.main.bounds.width - 40, height: 10)) slider.minimumValue = 0 slider.maximumValue = 1 slider.addTarget(self, action: #selector(sliderValueChanged(sender:)), for: UIControlEvents.valueChanged) view.addSubview(slider) &#125; sliderValuerChanged方法实现12345678910111213@objc private func sliderValueChanged(sender: UISlider) &#123; guard let draftShapeLayer = self.draftShapeLayer else &#123; return &#125;guard let squareShapeLayer = self.squareShapeLayer else &#123; return &#125; guard let lineShapeLayer = self.lineShapeLayer else &#123; return &#125; draftShapeLayer.strokeEnd = CGFloat(sender.value) squareShapeLayer.strokeEnd = CGFloat(sender.value) lineShapeLayer.strokeEnd = CGFloat(sender.value)&#125; 至此，ShapeLayer图形动画就完成了 ShapeLayer蒙版用ShapeLayer创建一个带图形的蒙版如下图 &lt;img src=’http://ogdqxib8j.bkt.clouddn.com/MaskImage.png&#39; width=’200’, height=’400’&gt; 思路新建一个蒙版视图View,然后将绘有贝塞尔曲线的ShapeLayer设置为蒙版视图图层的mask 实现创建蒙版视图并添加到控制器视图1234let maskView = UIView(frame: view.bounds)maskView.backgroundColor = UIColor.red.withAlphaComponent(0.3)maskView.alpha = 0.8view.addSubview(maskView) 用贝塞尔曲线绘制蒙版的形状123let bpath = UIBezierPath(roundedRect: CGRect(x: 10, y: 10, width: view.bounds.width - 20, height: view.bounds.height - 20), cornerRadius: 15)let circlePath = UIBezierPath(arcCenter: view.center, radius: 100, startAngle: 0, endAngle: CGFloat(M_PI) * 2, clockwise: false)bpath.append(circlePath) 创建ShapeLayer，设置之前创建的贝塞尔曲线为cgPath12let shapeLayer = CAShapeLayer()shapeLayer.path = bpath.cgPath 将ShapeLayer设为蒙版1maskView.layer.mask = shapeLayer 接下来就可以运行看效果了 本文demo的github地址：https://github.com/zephyrw/ShapeLayerDemo.git","categories":[],"tags":[{"name":"ShapeLayer","slug":"ShapeLayer","permalink":"http://anye3210.github.io/tags/ShapeLayer/"},{"name":"CALayer","slug":"CALayer","permalink":"http://anye3210.github.io/tags/CALayer/"},{"name":"Animation","slug":"Animation","permalink":"http://anye3210.github.io/tags/Animation/"},{"name":"动画","slug":"动画","permalink":"http://anye3210.github.io/tags/%E5%8A%A8%E7%94%BB/"},{"name":"下拉","slug":"下拉","permalink":"http://anye3210.github.io/tags/%E4%B8%8B%E6%8B%89/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2016-12-21T15:18:35.000Z","updated":"2021-08-22T07:45:26.772Z","comments":true,"path":"2016/12/21/正则表达式/","link":"","permalink":"http://anye3210.github.io/2016/12/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"以下是对正则表达式学习的一些整理。 头部尾部^ 表示开始 后接字符串 ^one $ 表示结束 前接字符串 dog$ “banana” 必须包含此字符串 限制个数* 0个或更多个 ab* (a,ab,abbb…) + 1个或更多个 ab+ (ab, abbb…) ? 0个或1个 ab? (a, ab) {4} 4个 ab{4} (abbbb)","text":"以下是对正则表达式学习的一些整理。 头部尾部^ 表示开始 后接字符串 ^one $ 表示结束 前接字符串 dog$ “banana” 必须包含此字符串 限制个数* 0个或更多个 ab* (a,ab,abbb…) + 1个或更多个 ab+ (ab, abbb…) ? 0个或1个 ab? (a, ab) {4} 4个 ab{4} (abbbb) {1,} 至少1个 ab{1,} (ab, abbb…) {3,4} 3个到4个 ab{3,4} (abbb, abbbb) 注：必须有下限，ab{,5}是错误的 或| 表示或 (a|b)e (ae, be) 字符范围[a-z] 所有小写字母 [0-9] 数字 . 任意字符 连续字符\\4 连续有4个字符 (.)\\4 连续4个相同字符 {1,2} 连续1个或者2个字符 10{1,2} (10,100) {3,} 连续3个以上字符 0{3,} (000,0000) 不希望出现的字符^ 后接不希望出现的字符 @[^a-zA-Z]@ 两个@之前不能有字母 其他\\d 匹配一个数字字符 等价于[0-9] \\D 匹配一个非数字字符 等价于[^0-9] \\w 匹配包括下划线的任何单词字符 等价于[A-Za-z0-9] \\W 匹配任何非单词字符 等价于[^A-Za-z0-9] 转义字符处理碰到转义字符 多加一个 \\ 正则表达式与NSPredicate连用12345- (BOOL)validateNumber:(NSString *)textString &#123; NSString* number=@&quot;^[0-9]+$&quot;; NSPredicate *numberPre = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,number]; return[numberPre evaluateWithObject:textString];&#125; NSString方法12345NSString *searchText = @&quot;rangeOfString&quot;;NSRange range = [searchText rangeOfString:@&quot;^[0-9]+$&quot;options:NSRegularExpressionSearch];if(range.location != NSNotFound) &#123; NSLog(@&quot;range ：%@&quot;, [searchText substringWithRange:range]);&#125; 正则表达式类（NSRegularExpression）1234567NSString *searchText = @&quot;you want to match&quot;;NSError *error = NULL;NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@&quot;^[0-9]+$&quot;options:NSRegularExpressionCaseInsensitive error:&amp;error];NSTextCheckingResult *result = [regex firstMatchInString:searchText options:0 range:NSMakeRange(0, [searchText length])];if(result) &#123; NSLog(@&quot;%@&quot;, [searchText substringWithRange:result.range]);&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://anye3210.github.io/tags/iOS/"},{"name":"NSPredicate","slug":"NSPredicate","permalink":"http://anye3210.github.io/tags/NSPredicate/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://anye3210.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Carthage的使用","slug":"Carthage的使用","date":"2016-11-23T13:13:32.000Z","updated":"2021-08-22T07:47:48.163Z","comments":true,"path":"2016/11/23/Carthage的使用/","link":"","permalink":"http://anye3210.github.io/2016/11/23/Carthage%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"简介Cathage 一直致力于成为给 Cocoa 应用添加框架最简单的方式。它的使用流程如下： 创建一个 Cathage ，在里面列出你的项目要使用的第三方框架； 运行 Cathage， Cathage 会获取并创建你列出的所有框架； 把生成的 .frameword 二进制文件拖到你的工程文件中。 Cathage 帮你创建第三方依赖、提供二进制的 framework 文件，并且不会改变你的项目架构和创建。","text":"简介Cathage 一直致力于成为给 Cocoa 应用添加框架最简单的方式。它的使用流程如下： 创建一个 Cathage ，在里面列出你的项目要使用的第三方框架； 运行 Cathage， Cathage 会获取并创建你列出的所有框架； 把生成的 .frameword 二进制文件拖到你的工程文件中。 Cathage 帮你创建第三方依赖、提供二进制的 framework 文件，并且不会改变你的项目架构和创建。 Cathage 在你使用的过程中并不会修改的你工程文件和你的项目设置。 Cathage 与 CocoaPods 的不同CocoaPods 是存在已久的 Cocoa 的第三方依赖管理方式，在此基础上为什么还要使用 Cathage ？ 首先，CocoaPods 会自动为你的应用与第三方依赖创建和更新一个 Xcode workspace；Carthage 使用 xcodebuild 创建二进制 framework ，添加和使用这此框架是用户自己操作的。CocoaPods 使用上更简单，而 Carthage 更灵活，耦合性更低。 从 CocoaPods 的 README 可以看出它有以下的目标： 通过创建一个集中式的生态系统使发现和管理第三方框架更便捷。 相反， Carthage 是一个非集中式的第三方管理工具。它在工程文件中没有集中的列表，这可以大大降低维护的难度，避免集中列表的一些错误导致的编译失败。然而，发现第三方框架也是一个麻烦的事情，用户必须要到 GitHub 的趋势页面去查找或者去类似的网站。 CocoaPods 的工程文件中一定要有 podspec 文件，在 podspec 文件中用户要填写元数据和它创建的方式。Carthage 用 xcodebuild 去创建第三方框架。它不会把你的第三方依赖放在一个单独的 workspace 中去管理，你写的第三方框架一定要包含自己的 Xcode 项目用来描述怎么去生成和使用。 总之，Carthage 的目标就是成为管理第三方框架第简单的工具，它可以在不使用 Xcode 的情况下完成它的任务，也不会让框架作者做额外的工作。但 CocoaPods 也确实提供了很多非常好而且 Carthage 介于成本考虑可能永远也不会有的功能。 安装 Carthage安装 Carthage 有以下几种方法： 通过安装程序安装：下载并运行 Carthage.pkg ，根据软件提示安装即可； Homebrew安装：使用 brew install carthage 命令安装(注意：如果你安装过二进制版本的 Carthage，你要先删除 /Library/Frameworks/CarthageKit.framework)； 从GigHub源安装：如果你想安装最新版本(注意最新版可以不太稳定)，直接克隆Carthage 在GigHub上的 master 分支，并运行 make install 即可，仅支持 Xcode 8.0及以上（Swift支持 2.3 版本，现在还不支持 3.0 以上的版本）。 为应用添加第三方框架如果你安装了 Carthage ，你就可以为你的项目添加第三方框架了。注意 Carthage 只支持动态库，动态库只在 iOS 8 及以上才支持（任意版本的 OS X 都支持动态库）。 开始使用针对 iOS, tvOS 或者 watchOS 的使用方法： 创建一个 Cartfile 并列出你想使用的第三方库； 使用 carthage update 命令，Carthage 就会把第三方框架更新到 Carthage/Checkouts 文件夹中，然后挨个编译； 在你的工程文件的 “General” 选项卡中，把你的框架从 Carthage/Build 文件夹拖到 “Linked Frameworks and Libraries” 区域内； 在你的工程文件 “Build Phases” 选项卡中，点 “+” 然后选择 “New Run Script Phase” 创建一个新的运行脚本来声明你的 shell（比如：bin/sh），把下面的内容粘贴到 shell 中： 1/usr/local/bin/carthage copy-frameworks 然后在 “Input Files” 中添加你要使用的框架的路径，比如： 123$(SRCROOT)/Carthage/Build/iOS/Box.framework$(SRCROOT)/Carthage/Build/iOS/Result.framework$(SRCROOT)/Carthage/Build/iOS/ReactiveCocoa.framework 当这些调试信息被复制到产品目录中， 无论你的应用停在哪个断点，Xcode 都能够 symbolicate 你的堆栈信息。这也能够让你用第三方的调试工具进行调试。 无论你的应用提交到 AppStore 还是打包测试，Xcode 都会复制这些文件到你应用的 .xcarchive 沙盒中 dSYMs 文件夹的子目录中。 升级第三方框架如果你修改了 Cartfile 文件，或者你想使用第三方框架的最新版，只要再运行一次 carthage update 就行了。 如果你只是想更新某一个或者某几个，只要用空格隔开就行了，比如： 1carthage update Box 或者 1carthage update Box Result CartfileCartfile 是用来描述第三方框架的，它严格遵守 Ordered Graph Data Language 的语法，任何标准的 OGDL 工具都能解析它。 第三方框架声明分为两部分：基础部分和版本需求部分。 基础部分如果使用 GigHub 的仓库（GitHub.com 或者 GitHub Enterprise），使用时必须加入 github 关键字，比如： 12github &quot;ReactiveCocoa/ReactiveCocoa&quot; # GitHub.comgithub &quot;https://enterprise.local/ghe/desktop/git-error-translations&quot; # GitHub Enterprise 其他 git 仓库要加 git 关键字，如下： 1git &quot;https://enterprise.local/desktop/git-error-translations2.git&quot; 版本需求Carthage 支持以下几种版本声明： &gt;= 1.0 大于等于版本 1.0 ~&gt; 1.0 兼容版本 1.0 == 1.0 必须是版本 1.0 some-branch-or-tag-or-commit 针对一个明确的 Git 项目 如果没有版本声明，就代表任何版本都可以使用。 兼容性是根据语义化版本规范确定的，任何大于或者等于版本 1.5.1 小于版本 2.0 的，都被认定 兼容于 1.5.1。 但是根据语义化版本规范，任何 0.x.y 的版本都会在运行中崩溃，所以0.x 的版本没有遵守语义化版本规范，如果你定义了 0.1.1 的版本，那么 兼容的版本就是 0.1.2，而不是 0.2。 Cartfile 示例123456789101112131415161718192021222324# Require version 2.3.1 or latergithub &quot;ReactiveCocoa/ReactiveCocoa&quot; &gt;= 2.3.1# Require version 1.xgithub &quot;Mantle/Mantle&quot; ~&gt; 1.0 # (1.0 or later, but less than 2.0)# Require exactly version 0.4.1github &quot;jspahrsummers/libextobjc&quot; == 0.4.1# Use the latest versiongithub &quot;jspahrsummers/xcconfigs&quot;# Use the branchgithub &quot;jspahrsummers/xcconfigs&quot; &quot;branch&quot;# Use a project from GitHub Enterprisegithub &quot;https://enterprise.local/ghe/desktop/git-error-translations&quot;# Use a project from any arbitrary server, on the &quot;development&quot; branchgit &quot;https://enterprise.local/desktop/git-error-translations2.git&quot; &quot;development&quot;# Use a local projectgit &quot;file:///directory/to/project&quot; &quot;branch&quot;","categories":[],"tags":[{"name":"Cathage","slug":"Cathage","permalink":"http://anye3210.github.io/tags/Cathage/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://anye3210.github.io/tags/CocoaPods/"},{"name":"第三方库","slug":"第三方库","permalink":"http://anye3210.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"框架管理","slug":"框架管理","permalink":"http://anye3210.github.io/tags/%E6%A1%86%E6%9E%B6%E7%AE%A1%E7%90%86/"}]},{"title":"【iOS】AsyncDisplayKit的布局","slug":"AsyncDisplayKit的布局","date":"2016-11-10T14:36:21.000Z","updated":"2021-08-22T07:48:52.303Z","comments":true,"path":"2016/11/10/AsyncDisplayKit的布局/","link":"","permalink":"http://anye3210.github.io/2016/11/10/AsyncDisplayKit%E7%9A%84%E5%B8%83%E5%B1%80/","excerpt":"AsyncDisplayKit布局的优势UIKit由于复杂的层级结构变得越来越expensive，而AsyncDisplayKit的 Layout API 作为一个新的选择，具有以下的优势。 快速：与手动布局代码一样快，比自动布局快了很多； 异步和同步：布局可以在子线程中进行，避免打断用户的操作； 声明：布局声明使用的是不可变的数据结构。这样使布局代码可以更容易开发，注释，预览，调试，介绍和维护； 缓存管理：布局的结果是不可变的数据结构，所以可以在后台进行计算和缓存，改善用户的体验； 可扩展性：很容易在类共享代码。","text":"AsyncDisplayKit布局的优势UIKit由于复杂的层级结构变得越来越expensive，而AsyncDisplayKit的 Layout API 作为一个新的选择，具有以下的优势。 快速：与手动布局代码一样快，比自动布局快了很多； 异步和同步：布局可以在子线程中进行，避免打断用户的操作； 声明：布局声明使用的是不可变的数据结构。这样使布局代码可以更容易开发，注释，预览，调试，介绍和维护； 缓存管理：布局的结果是不可变的数据结构，所以可以在后台进行计算和缓存，改善用户的体验； 可扩展性：很容易在类共享代码。 布局受 CSS3 Flexbox布局的启发熟悉Flexbox的人可以注意到这两个系统有很多共同点。但是 AsyncDisplayKit Layout Api 并没有实现全部的CSS。 基本概念AsyncDisplayKit 的布局系统有两个核心理念： 布局说明（ Layout Specs ） 布局元素（ Layout Elements ） 布局声明Layout Specs 是 layout specification 的简写，不是物理上的概念。布局声明的作用是作为一个容器让它的布局元素了解他们是怎么相互联系和影响的。 AsyncDisplayKit 为 ASLayoutSpec 提供了很多子类，从简单的只包含一个子元素的子类到非常复杂的含有各种各样布局元素的都有。 布局元素布局声明包含和管理布局元素。 所有的 ASDisplayNode 和 ASLayoutSpec 都遵从 &lt;ASLayoutElement&gt; 协议。因此可以从节点或其他布局声明中组成自己的布局声明。 ASLayoutElement 协议有一些特性可以帮助我们创建非常复杂的布局。而且，布局声明有它自己的设定用来管理它的布局元素。 结合布局声明和布局元素来创建复杂的界面如下图所示，我们可以用 ASTextNode (黄色高亮)，一个 ASVideoNode (顶部的图片) 和 一个 ASStackLayoutSpec （堆栈布局声明）来合成一个复杂的布局。 顶部图片中间的播放按钮布局使用的是一个 ASCenterLayoutSpec 和一个 ASOverlayLayoutSpec。 一些节点需要设置尺寸一些节点的尺寸根据它的内容计算有它固有的尺寸。比如 ASTextNode 可以根据它的 attibuted string 来计算尺寸。其它有固有尺寸的节点包括： ASImageNode ASTextNode ASButtonNode ASTextNode 其他的节点没有自己的固有尺寸或者它的数据加载完成之后才有自己的固有尺寸。比如 ASNetworkImageNode ，在图片下载完成之前并不知道图片的尺寸。这一类的节点包括： ASVideoNode ASVideoPlayerNode ASNetworkImageNode ASEditableTextNode 这些节点必须在初始化的时候通过 ASRatioLayoutSpec 、 ASAbsoluteLayoutSpec 或者尺寸属性设置尺寸。 布局调试ASDisplayNode 或者 ASLayoutSpec 调用 -asciiArtString 就可以显示一个包含元素和子元素的 ascii-art 图形，如下图所示。同样你也可以通过 .debugName 来打印图形。 123456-----------------------ASStackLayoutSpec----------------------| -----ASStackLayoutSpec----- -----ASStackLayoutSpec----- || | ASImageNode | | ASImageNode | || | ASImageNode | | ASImageNode | || --------------------------- --------------------------- |-------------------------------------------------------------- 你也可以通过打印布局元素来进行调试，这在调试尺寸属性的时候非常有用。 12(lldb) po _photoImageNode.styleLayout Size = min &#123;414pt, 414pt&#125; &lt;= preferred &#123;20%, 50%&#125; &lt;= max &#123;414pt, 414pt&#125;","categories":[],"tags":[{"name":"ASDK","slug":"ASDK","permalink":"http://anye3210.github.io/tags/ASDK/"},{"name":"AsyncDisplayKit","slug":"AsyncDisplayKit","permalink":"http://anye3210.github.io/tags/AsyncDisplayKit/"},{"name":"ASDK布局","slug":"ASDK布局","permalink":"http://anye3210.github.io/tags/ASDK%E5%B8%83%E5%B1%80/"}]},{"title":"【iOS】AsyncDisplayKit初识","slug":"AsyncDisplayKit介绍","date":"2016-11-10T13:38:58.000Z","updated":"2021-08-22T07:49:17.694Z","comments":true,"path":"2016/11/10/AsyncDisplayKit介绍/","link":"","permalink":"http://anye3210.github.io/2016/11/10/AsyncDisplayKit%E4%BB%8B%E7%BB%8D/","excerpt":"简介 AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库。 在 ASDK 中最基本的单位就是 ASDisplayNode，每一个 node 都是对 UIView 以及 CALayer 的抽象。但是与 UIView 不同的是，ASDisplayNode 是线程安全的，它可以在后台线程中完成初始化以及配置工作。 如果按照 60 FPS 的刷新频率来计算，每一帧的渲染时间只有 16ms，在 16ms 的时间内要完成对 UIView 的创建、布局、绘制以及渲染，CPU 和 GPU 面临着巨大的压力。 但是从 A5 处理器之后，多核的设备成为了主流，原有的将所有操作放入主线程的实践已经不能适应复杂的 UI 界面，所以 ASDK 将耗时的 CPU 操作以及 GPU 渲染纹理（Texture）的过程全部放入后台进程，使主线程能够快速响应用户操作。 ASDK 通过独特的渲染技巧、代替 AutoLayout 的布局系统、智能的预加载方式等模块来实现对 App 性能的优化。","text":"简介 AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库。 在 ASDK 中最基本的单位就是 ASDisplayNode，每一个 node 都是对 UIView 以及 CALayer 的抽象。但是与 UIView 不同的是，ASDisplayNode 是线程安全的，它可以在后台线程中完成初始化以及配置工作。 如果按照 60 FPS 的刷新频率来计算，每一帧的渲染时间只有 16ms，在 16ms 的时间内要完成对 UIView 的创建、布局、绘制以及渲染，CPU 和 GPU 面临着巨大的压力。 但是从 A5 处理器之后，多核的设备成为了主流，原有的将所有操作放入主线程的实践已经不能适应复杂的 UI 界面，所以 ASDK 将耗时的 CPU 操作以及 GPU 渲染纹理（Texture）的过程全部放入后台进程，使主线程能够快速响应用户操作。 ASDK 通过独特的渲染技巧、代替 AutoLayout 的布局系统、智能的预加载方式等模块来实现对 App 性能的优化。 初步使用节点 nodes的使用大致与view的使用方法相同，少数像(.clipsToBounds vs .masksToBounds)这样的不同node也会自动使用UIView的命名,唯一的例外是node使用position而不是center。 使用node的时候也可以随时在主线程拿到node.view或者node.layer。 AsyncDisplayKit提供了各种各样的node以代替UIKit中的大部分组件。 节点容器 当一个app转成使用AsyncDisplayKit时，一个常见的错误就是直接把nodes添加到现有的视图层级中，这样做会造成你的node渲染时屏闪。 正确的做法是将nodes作为subnodes添加到node container classes中，这些容器的作用是告诉容器内的nodes它们现在的状态，这样才能保证高效地进行数据的加载和nodes的渲染。 布局引擎 AsyncDisplayKit的Layout Engine也是它最强大和最独特的特性之一。基于CSS FlexBox model它提供了一种公开的方式来区分用户自定义的node的subnodes的size和layout。当所有的node全部以默认的同步方式渲染完毕，尺寸设置和布局计算将会以异步的方式进行。 想要参与这个过程的主要方式就是通过在子类中实现layoutSpecThatFits:方法，在这里你声明和建立布局规则对象，返回最重的包含所有信息的对象。 1234567- (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize &#123; ASStackLayoutSpec *verticalStack = [ASStackLayoutSpec verticalStackLayoutSpec]; verticalStack.direction = ASStackLayoutDirectionVertical; verticalStack.spacing = 4.0; [verticalStack setChildren:_commentNodes]; return verticalStack;&#125; 核心理念智能预加载node非常强大，它有能力同步和异常进行渲染和计算，另一个至关重要的层面则是它智能预加载的理念。 同之前所说，node在node containers以外的地方使用并没有什么性能改善作用。那是因为所有的node都有interfaceState的概念。 这个interfaceState特性是被所有的containers创建和维持的一个ASRangeController进行持续更新的。 如果一个node在container之外使用，它的状态就不会被任何range controller更新，这就会导致偶尔会出现屏闪(nodes在没有发出任何警告的情况下已经显示在屏幕上，但它的渲染和布局还没有完成) 当nodes被添加到滚动或者页面视图的时候，它们通常会进入下图的区域范围内。这就意味着如果这个视图滚动到它这里了，它的界面状态就会被更新。 一个node将会有三种状态： Fetch Data Display Visible 上面的这三种状态都是由 ASDK 来管理的，而每一个 ASCellNode 的状态都是由 SRangeController 控制，所有的状态都对应一个 ASInterfaceState： ASInterfaceStatePreload 当前元素貌似要显示到屏幕上，需要从磁盘或者网络请求数据； ASInterfaceStateDisplay 当前元素非常可能要变成可见的，需要进行异步绘制； ASInterfaceStateVisible 当前元素最少在屏幕上显示了 1px 当用户滚动当前视图时，ASRangeController 就会修改不同区域内元素的状态： 上图是用户在向下滑动时，ASCellNode 是如何被标记的，假设当前视图可见的范围高度为 1，那么在默认情况下，五个区域会按照上图的形式进行划分： 在滚动方向（Leading）上 Fetch Data 区域会是非滚动方向（Trailing）的两倍，ASDK 会根据滚动方向的变化实时改变缓冲区的位置；在向下滚动时，下面的 Fetch Data 区域就是上面的两倍，向上滚动时，上面的 Fetch Data 区域就是下面的两倍。 这里的两倍并不是一个确定的数值，ASDK 会根据当前设备的不同状态，改变不同区域的大小，但是滚动方向的区域总会比非滚动方向大一些。 智能预加载能够根据当前的滚动方向，自动改变当前的工作区域，选择合适的区域提前触发请求资源、渲染视图以及异步布局等操作，让视图的滚动达到真正的流畅。","categories":[],"tags":[{"name":"ASDK","slug":"ASDK","permalink":"http://anye3210.github.io/tags/ASDK/"},{"name":"AsyncDisplayKit","slug":"AsyncDisplayKit","permalink":"http://anye3210.github.io/tags/AsyncDisplayKit/"},{"name":"性能优化","slug":"性能优化","permalink":"http://anye3210.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"UIKit","slug":"UIKit","permalink":"http://anye3210.github.io/tags/UIKit/"}]},{"title":"【iOS】AsyncDisplayKit的组件","slug":"AsyncDisplayKit的组件","date":"2016-11-10T12:30:58.000Z","updated":"2021-08-22T07:49:04.473Z","comments":true,"path":"2016/11/10/AsyncDisplayKit的组件/","link":"","permalink":"http://anye3210.github.io/2016/11/10/AsyncDisplayKit%E7%9A%84%E7%BB%84%E4%BB%B6/","excerpt":"节点容器在容器中使用NodesAsyncDisplayKit有以下几种 Container ASDK Node Container UIKit Equivalent ASCollectionNode 代替UIKit的 UICollectionView ASPagerNode 代替UIKit的 UIPageViewController ASTableNode 代替UIKit的 UITableView ASViewController 代替UIKit的 UIViewController ASNavigationControllerv 代替UIKit的 UINavigationController，遵循ASVisibility协议 ASTabBarController 代替UIKit的 UITabBarController，遵循ASVisibility协议","text":"节点容器在容器中使用NodesAsyncDisplayKit有以下几种 Container ASDK Node Container UIKit Equivalent ASCollectionNode 代替UIKit的 UICollectionView ASPagerNode 代替UIKit的 UIPageViewController ASTableNode 代替UIKit的 UITableView ASViewController 代替UIKit的 UIViewController ASNavigationControllerv 代替UIKit的 UINavigationController，遵循ASVisibility协议 ASTabBarController 代替UIKit的 UITabBarController，遵循ASVisibility协议 Node Container的优势Node Container可以自动地管理node的智能预加载，它会保证node的的布局计算、数据获取、解码和渲染会以异步的方式进行。 Node的子类AsyncDisplayKit提供了以下几种node。 相对UIKit的组件来说 node 最大的改进就是将所有布局和显示都放在子线程，因此主线程就能够即时地响应各种事件。 ASDK Node UIKit Equivalent ASDisplayNode 代替UIKit的 UIView ，其他的node都继承于它 ASCellNode 代替UIKit的 UITableViewCell 和 UICollectionViewCell，用在 ASTableNode , ASCollectionNode 和 ASPagerNode中 ASScrollNode 代替UIKit的 UIScrollView，这个 node 用在自定义滚动区域上非常有用 ASEditableTextNode 代替UIKit的 UITextView ASTextNode 代替UIKit的 UILabel ASImageNode 代替UIKit的 UIImage ASNetworkImageNode ASMultiplexImageNode ASVideoNode 代替UIKit的 AVPlayerLayer ASVideoPlayerNode 代替UIKit的 UIMoviePlayer SControlNode 代替UIKit的 UIControl ASButtonNode 代替UIKit的 UIButton ASMapNode 代替UIKit的 MKMapView AsyncDisplayKit 中的 node 相比UIKit中的组件更先进而且更方便。比如 ASNetworkImageNode 可以自动地加载和进行内存管理，而且还支持逐步加载Jpeg和动态gif图片。 node 的层级结构如下 上图中蓝色高亮的node是对UIKit元素的封装而成。比如 ASScrollNode 封装自 UIScrollView ， ASCollectionNode 封装自 UICollectionView ，ASMapNode 在实时地图模式中就是 UIMapView 封装。 基本重载方法 创建子类时，子类是 ASViewController 还是 ASDisplayNode 有很大的区别。这感觉上是显而易见的，但是有的区别是很微妙的，所有也需要特别注意。 ASDisplayNode如果你使用的 node 组件类型于 UIView 的子控件，就必须注意下面几条准则以确保你充分发挥了这个框架的潜力， node 也能很好的显示。 -init当使用 nodeBlock 的时候这个方法是在子线程进行的。但是，如何 -init 没有运行完，其他方法就无法运行，所以这个方法永远不要上锁。 最重要的是你的 init 方法一定要能在任何队列中调用。尤其是不要在初始化的时候初始化任何 UIKit 控件、点击 node 的 view 或者 layer 或者添加任何手势。这些事情应该放在 -didLoad 中。 -didLoad这个方法在概念上类似于 UIViewController 的 -viewDidLoad 方法，它代表着后台的 view 已经被加载完成了。要确保它是在主线程中执行的，在这个方法中很适合处理 UIKit 的各种操作（比如添加手势，点击 view 或者 layer，初始化 UIKit 组件）。 -layout在这个方法里调用 super 之后，布局规则对象会把所有的子节点都计算并且定位好，所以这个时间点是你手动进行布局所有子view的时机。或许更有用的是，有时候你想手动布局，但并不太容易创建一个布局规则对象，或者有时候你不想等所有子节点布局完毕，而只是很简单的手动设置frame，如果是这样的话，就在这个方法里写。 layoutSpecThatFits这个方法就是用来建立布局规则对象，产生 node 大小以及所有子 node 大小的地方，你创建的布局规则对象一直持续到这个方法返回的时间点，经过了这个时间点后，它就不可变了。尤其重要要记住的一点事，千万不要缓存布局规则对象，当你以后需要他的时候，请重新创建。 ASViewControllerASViewController 是 UIViewController 的子类，包含了管理 node 的特性。因此它的所有方法一定要在主线程中使用。 -init这个方法只调用一次，是在 ASViewController 的生命周期的最开始的时候调用。在它初始化的过程中，不要使用 self.view 或者 self.node.view ，它会强制 view 被提前创建。这些事情应该在 viewDidLoad 中完成。 ASViewController 的初始化方法是 initWithNode: ，代码如下所示。一个 ASViewController 管理节点就像 UIViewController 管理 view 一样，但是初始化的过程有小小的差异。 12345678910111213- (instancetype)init &#123; _pagerNode = [[ASPagerNode alloc] init]; self = [super initWithNode:_pagerNode]; // setup any instance variables or properties here if (self) &#123; _pagerNode.dataSource = self; _pagerNode.delegate = self; &#125; return self;&#125; -loadView建议不要使用这个方法，因为它相对于 viewDidLoad 来说没有明显的优势反而有很多不足的地方。但如果你不去设置 self.view 的属性就没什么问题。调用 [super loadView] 它就会执行 node.view 。 -viewDidLoad它会在 ASViewController 的生命周期的最开始调用，仅次于 -loadView 。这是你使用节点的 view 最早的时机。在这个方法里适合放只执行一次并且要使用 view/layer 的代码，比如加手势。 布局的代码千万不要放在这个方法里，因为界面发生改变也不会再调用这个方法重新布局。 -viewWillLayoutSubviews这个方法调用的时机和节点 -layout 方法调用的时机一样，它可以被执行很多次。只要它的节点被改变（比如旋转，分屏，显示键盘）或者继承（）都会立即被调用。","categories":[],"tags":[{"name":"ASDK","slug":"ASDK","permalink":"http://anye3210.github.io/tags/ASDK/"},{"name":"AsyncDisplayKit","slug":"AsyncDisplayKit","permalink":"http://anye3210.github.io/tags/AsyncDisplayKit/"},{"name":"性能优化","slug":"性能优化","permalink":"http://anye3210.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"使用","slug":"使用","permalink":"http://anye3210.github.io/tags/%E4%BD%BF%E7%94%A8/"}]}],"categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://anye3210.github.io/tags/java/"},{"name":"netty","slug":"netty","permalink":"http://anye3210.github.io/tags/netty/"},{"name":"网络编程","slug":"网络编程","permalink":"http://anye3210.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"nio","slug":"nio","permalink":"http://anye3210.github.io/tags/nio/"},{"name":"Java","slug":"Java","permalink":"http://anye3210.github.io/tags/Java/"},{"name":"AQS","slug":"AQS","permalink":"http://anye3210.github.io/tags/AQS/"},{"name":"锁","slug":"锁","permalink":"http://anye3210.github.io/tags/%E9%94%81/"},{"name":"ReentrantLock","slug":"ReentrantLock","permalink":"http://anye3210.github.io/tags/ReentrantLock/"},{"name":"共享锁","slug":"共享锁","permalink":"http://anye3210.github.io/tags/%E5%85%B1%E4%BA%AB%E9%94%81/"},{"name":"Lock","slug":"Lock","permalink":"http://anye3210.github.io/tags/Lock/"},{"name":"类加载","slug":"类加载","permalink":"http://anye3210.github.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"},{"name":"符号引用","slug":"符号引用","permalink":"http://anye3210.github.io/tags/%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/"},{"name":"初始化","slug":"初始化","permalink":"http://anye3210.github.io/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"name":"内存模型","slug":"内存模型","permalink":"http://anye3210.github.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"name":"happen-before","slug":"happen-before","permalink":"http://anye3210.github.io/tags/happen-before/"},{"name":"内存可见性","slug":"内存可见性","permalink":"http://anye3210.github.io/tags/%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/"},{"name":"重排序","slug":"重排序","permalink":"http://anye3210.github.io/tags/%E9%87%8D%E6%8E%92%E5%BA%8F/"},{"name":"性能优化","slug":"性能优化","permalink":"http://anye3210.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"React Native","slug":"React-Native","permalink":"http://anye3210.github.io/tags/React-Native/"},{"name":"React Native Reanimated","slug":"React-Native-Reanimated","permalink":"http://anye3210.github.io/tags/React-Native-Reanimated/"},{"name":"Reanimated","slug":"Reanimated","permalink":"http://anye3210.github.io/tags/Reanimated/"},{"name":"进阶","slug":"进阶","permalink":"http://anye3210.github.io/tags/%E8%BF%9B%E9%98%B6/"},{"name":"React Native Gesture Handler","slug":"React-Native-Gesture-Handler","permalink":"http://anye3210.github.io/tags/React-Native-Gesture-Handler/"},{"name":"Gesture Handler","slug":"Gesture-Handler","permalink":"http://anye3210.github.io/tags/Gesture-Handler/"},{"name":"React","slug":"React","permalink":"http://anye3210.github.io/tags/React/"},{"name":"Stack Navigation","slug":"Stack-Navigation","permalink":"http://anye3210.github.io/tags/Stack-Navigation/"},{"name":"Tab Navigation","slug":"Tab-Navigation","permalink":"http://anye3210.github.io/tags/Tab-Navigation/"},{"name":"嵌套","slug":"嵌套","permalink":"http://anye3210.github.io/tags/%E5%B5%8C%E5%A5%97/"},{"name":"Redux","slug":"Redux","permalink":"http://anye3210.github.io/tags/Redux/"},{"name":"Middleware","slug":"Middleware","permalink":"http://anye3210.github.io/tags/Middleware/"},{"name":"中间件","slug":"中间件","permalink":"http://anye3210.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Thunk","slug":"Thunk","permalink":"http://anye3210.github.io/tags/Thunk/"},{"name":"Navigation","slug":"Navigation","permalink":"http://anye3210.github.io/tags/Navigation/"},{"name":"AES","slug":"AES","permalink":"http://anye3210.github.io/tags/AES/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://anye3210.github.io/tags/Jenkins/"},{"name":"fir","slug":"fir","permalink":"http://anye3210.github.io/tags/fir/"},{"name":"蒲公英","slug":"蒲公英","permalink":"http://anye3210.github.io/tags/%E8%92%B2%E5%85%AC%E8%8B%B1/"},{"name":"profile","slug":"profile","permalink":"http://anye3210.github.io/tags/profile/"},{"name":"ad-hoc","slug":"ad-hoc","permalink":"http://anye3210.github.io/tags/ad-hoc/"},{"name":"iOS","slug":"iOS","permalink":"http://anye3210.github.io/tags/iOS/"},{"name":"持续集成","slug":"持续集成","permalink":"http://anye3210.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"自动化打包","slug":"自动化打包","permalink":"http://anye3210.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"},{"name":"SonarQube","slug":"SonarQube","permalink":"http://anye3210.github.io/tags/SonarQube/"},{"name":"代码质量","slug":"代码质量","permalink":"http://anye3210.github.io/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/"},{"name":"静态检查","slug":"静态检查","permalink":"http://anye3210.github.io/tags/%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/"},{"name":"ObjectiveC","slug":"ObjectiveC","permalink":"http://anye3210.github.io/tags/ObjectiveC/"},{"name":"Eureka","slug":"Eureka","permalink":"http://anye3210.github.io/tags/Eureka/"},{"name":"Custom Cell","slug":"Custom-Cell","permalink":"http://anye3210.github.io/tags/Custom-Cell/"},{"name":"TableView","slug":"TableView","permalink":"http://anye3210.github.io/tags/TableView/"},{"name":"自动生成","slug":"自动生成","permalink":"http://anye3210.github.io/tags/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90/"},{"name":"UIViewControllerAnimatedTransitioning","slug":"UIViewControllerAnimatedTransitioning","permalink":"http://anye3210.github.io/tags/UIViewControllerAnimatedTransitioning/"},{"name":"自定义转场","slug":"自定义转场","permalink":"http://anye3210.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA/"},{"name":"AFNetwork","slug":"AFNetwork","permalink":"http://anye3210.github.io/tags/AFNetwork/"},{"name":"上传图片","slug":"上传图片","permalink":"http://anye3210.github.io/tags/%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"},{"name":"源码解析","slug":"源码解析","permalink":"http://anye3210.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"2048","slug":"2048","permalink":"http://anye3210.github.io/tags/2048/"},{"name":"swift","slug":"swift","permalink":"http://anye3210.github.io/tags/swift/"},{"name":"Game","slug":"Game","permalink":"http://anye3210.github.io/tags/Game/"},{"name":"ShapeLayer","slug":"ShapeLayer","permalink":"http://anye3210.github.io/tags/ShapeLayer/"},{"name":"Animation","slug":"Animation","permalink":"http://anye3210.github.io/tags/Animation/"},{"name":"动画","slug":"动画","permalink":"http://anye3210.github.io/tags/%E5%8A%A8%E7%94%BB/"},{"name":"文字","slug":"文字","permalink":"http://anye3210.github.io/tags/%E6%96%87%E5%AD%97/"},{"name":"CALayer","slug":"CALayer","permalink":"http://anye3210.github.io/tags/CALayer/"},{"name":"下拉","slug":"下拉","permalink":"http://anye3210.github.io/tags/%E4%B8%8B%E6%8B%89/"},{"name":"NSPredicate","slug":"NSPredicate","permalink":"http://anye3210.github.io/tags/NSPredicate/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://anye3210.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Cathage","slug":"Cathage","permalink":"http://anye3210.github.io/tags/Cathage/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://anye3210.github.io/tags/CocoaPods/"},{"name":"第三方库","slug":"第三方库","permalink":"http://anye3210.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"},{"name":"框架管理","slug":"框架管理","permalink":"http://anye3210.github.io/tags/%E6%A1%86%E6%9E%B6%E7%AE%A1%E7%90%86/"},{"name":"ASDK","slug":"ASDK","permalink":"http://anye3210.github.io/tags/ASDK/"},{"name":"AsyncDisplayKit","slug":"AsyncDisplayKit","permalink":"http://anye3210.github.io/tags/AsyncDisplayKit/"},{"name":"ASDK布局","slug":"ASDK布局","permalink":"http://anye3210.github.io/tags/ASDK%E5%B8%83%E5%B1%80/"},{"name":"UIKit","slug":"UIKit","permalink":"http://anye3210.github.io/tags/UIKit/"},{"name":"使用","slug":"使用","permalink":"http://anye3210.github.io/tags/%E4%BD%BF%E7%94%A8/"}]}